/** Bamboo utility functions, please consult the documention https://docs.atlassian.com/atlassian-bamboo/REST/ and check for latest release version. */
import fetch from 'node-fetch';
import retry from 'async-retry';
import {
  CustomBuildInformation,
  BambooBranchBuilds,
  JobSearchResult,
} from './types';

const retryTimeout = 10000;

/* This function extracts the baseUrl and the default identifier of a plan. */
function extractUrlIdentifier(planUrl: string) {
  if (planUrl.includes('/rest/')) {
    const [baseUrl, restPlan] = planUrl.split('/rest/');
    const [, defaultIdentifier] = restPlan.split('/plan/');
    return { baseUrl, defaultIdentifier };
  } else {
    throw Error('The url of the bamboo plan, we are passing is invalid!');
  }
}

function getHeaders(
  authToken: string,
  mimeTypes = ['application/json'],
  params = {},
) {
  return {
    Accept: mimeTypes.join(','),
    Authorization: `Bearer ${authToken}`,
    ...params,
  };
}

/* This function checks if a branch build exists. */
function branchBuildRequest(
  planUrl: string,
  branchName: string,
  authToken: string,
  method: 'GET' | 'PUT',
) {
  const branchPlanUrl = `${planUrl}/branch/${branchName}?os_authType=basic&vcsBranch=${branchName}&enabled=true&cleanupEnabled=true`;
  const headers = getHeaders(authToken);

  return fetch(branchPlanUrl, {
    method,
    headers,
  });
}

/* This function returns the build information for an existing branch / plan. */
export async function getBambooBranchBuilds(
  planUrl: string,
  identifier: string,
  branchName: string,
  authToken: string,
): Promise<BambooBranchBuilds> {
  const branchPlanUrl = `${planUrl}/rest/api/latest/result/${identifier}/branch/${branchName}?includeAllStates`;

  const headers = getHeaders(authToken);

  const response = await fetch(branchPlanUrl, {
    method: 'GET',
    headers,
  });

  return response.json();
}

/**
 * This function returns the build identifier for `ProjectKey-PlanKey-branchId`.
 * We consider the `ProjectKey-PlanKey` as the default identifier, for example 'CONFMICRO-CFCPB'.
 * However, for some API call, we need the identifier as such `ProjectKey-PlanKey-branchId`.
 * For example,`CONFMICRO-CFCPB14702` is an identifier composed of:
 * the project `CONFMICRO`
 * the plan `CFCPB`
 * a branch id 14702 - this is generated by bamboo.
 */
export async function getBuildIdentifier(
  planUrl: string,
  defaultIdentifier: string,
  branchName: string,
  authToken: string,
): Promise<string> {
  const { link } = await getBambooBranchBuilds(
    planUrl,
    defaultIdentifier,
    branchName,
    authToken,
  );

  const buildIdentifier = link.href.split('result/').pop();

  if (!buildIdentifier) {
    throw new Error(`No build identifier: ${link.href}`);
  }

  return buildIdentifier;
}

/* This function returns the latest build status (and buildKey - useful as used for identifier) for an existing branch / plan. */
export async function getLatestBuildStatus(
  planUrl: string,
  identifier: string,
  branchName: string,
  authToken: string,
): Promise<CustomBuildInformation> {
  const branchBuildsInformation = await getBambooBranchBuilds(
    planUrl,
    identifier,
    branchName,
    authToken,
  );

  // buildInformation.results.result is a queue where the last build is the first element.
  const latestBuildResult = branchBuildsInformation.results.result[0];
  const latestBuildIndex = branchBuildsInformation.results.size;
  let { buildState, buildResultKey, lifeCycleState } = latestBuildResult;

  // If the latest build result is a spec then these vars are undefined so we hardcode them
  // Example link.href: 'baseUrl/rest/api/latest/result/PROJECT-PLANBRANCH'.
  if (!buildResultKey || !buildState || !lifeCycleState) {
    buildResultKey =
      branchBuildsInformation.link.href.split('/result/').pop() || '';
    buildState = 'Running';
    lifeCycleState = 'InProgress';
  }

  return { buildState, buildResultKey, lifeCycleState, latestBuildIndex };
}

/* This function encapsulates `getLatestBuildStatus` to add the link to the next triggered bamboo build.
 * This will be used to upload the build status with the link to the current running bamboo build in pipeline.
 */
export async function getLatestBuildUrlInformation(
  planUrl: string,
  branchName: string,
  defaultIdentifier: string,
  authToken: string,
): Promise<CustomBuildInformation> {
  let {
    buildState,
    buildResultKey,
    lifeCycleState,
    latestBuildIndex,
  } = await getLatestBuildStatus(
    planUrl,
    defaultIdentifier,
    branchName,
    authToken,
  );
  const [plan, planBranch] = buildResultKey.split('-');
  // The `buildResultKey` return the last build that completed for this plan.
  // To access the current running build, we iterate the build index.
  // We default the first index of the build if undefined to 1.

  buildResultKey = `${plan}-${planBranch}-${latestBuildIndex}`;

  const latestBuildUrl = `${planUrl}/browse/${buildResultKey}`;

  return {
    buildState,
    buildResultKey,
    lifeCycleState,
    latestBuildIndex,
    latestBuildUrl,
  };
}

/* This function returns if a build is running for an existing branch / plan. */
export async function isBuildRunning(
  planUrl: string,
  identifier: string,
  authToken: string,
): Promise<boolean> {
  const branchPlanUrl = `${planUrl}/rest/api/latest/plan/${identifier}.json`;

  const headers = getHeaders(authToken);

  const response = await fetch(branchPlanUrl, {
    method: 'GET',
    headers,
  });

  const { isBuilding } = await response.json();

  return isBuilding;
}

/* This function searches Bamboo Plan / Jobs and return the job ids. */
export async function searchJobsbyPlanKey(
  planUrl: string,
  identifier: string,
  authToken: string,
) {
  const branchPlanUrl = `${planUrl}/rest/api/latest/search/jobs/${identifier}`;

  const headers = getHeaders(authToken);

  const response = await fetch(branchPlanUrl, {
    method: 'GET',
    headers,
  });

  const {
    searchResults,
  }: { searchResults: JobSearchResult[] } = await response.json();

  return searchResults.map(job => job.id);
}

/* This function stops a build based on the build / plan identifier.
 * However, there is a limitation in Bamboo https://jira.atlassian.com/browse/BAM-21065 where the API may not work.
 */
export async function stopBuild(
  planUrl: string,
  identifier: string,
  authToken: string,
) {
  const branchPlanUrl = `${planUrl}/rest/api/latest/queue/${identifier}?stage&executeAllStages`;

  const headers = getHeaders(authToken);

  return fetch(branchPlanUrl, {
    method: 'DELETE',
    headers,
  });
}

/* This function stops all running builds based on the job ids.
 * - Get all the running builds for a particular branch.
 * - Compute the current running build index.
 * - Stop the build by ProjectKey-PlanKey-branchId-jobKey-index.
 */
export async function stopAllRunningBuilds(
  planUrl: string,
  runningBuilds: string[],
  productBranchName: string,
  authToken: string,
  latestBuildIndex: number,
) {
  await Promise.all(
    runningBuilds.map(async runningJobKey => {
      const runningBuildToStop = `${runningJobKey}-${latestBuildIndex}`;
      await stopBuild(planUrl, runningBuildToStop, authToken);
    }),
  );
  console.info(
    `All the builds for the branch: ${productBranchName} are now stopped!`,
  );
}

/* This function put the build for a branch identified by `ProjectKey-PlanKey-branchId` in the queue.
 ** `POST` queue a build for a branch.
 ** `PUT` resume / re-run a build for a branch.
 */
export async function queueBuild(
  planUrl: string,
  branchName: string,
  authToken: string,
  method: 'POST' | 'PUT',
) {
  const { baseUrl, defaultIdentifier } = extractUrlIdentifier(planUrl);

  const identifier = await getBuildIdentifier(
    baseUrl,
    defaultIdentifier,
    branchName,
    authToken,
  );

  const branchPlanUrl = `${baseUrl}/rest/api/latest/queue/${identifier}?stage&executeAllStages`;

  const headers = getHeaders(authToken);

  // It happens sometimes that the branch is created after we try to queue the build.
  // Or it can happen that the plan branch is not yet enabled as not yet fully loaded in Bamboo.
  // To avoid this situation, we do a retry couple of times to check if the status for queueing the build is still 400.
  try {
    await retry(
      async () => {
        const response = await fetch(branchPlanUrl, {
          method,
          headers,
        });
        const buildQueue = await response.json();

        if (!buildQueue) {
          throw new Error('There is an issue with queueing the build!');
        }

        if (buildQueue['status-code'] === 400) {
          if (
            buildQueue['message'].includes(
              'you have reached the maximum number of concurrent builds allowed',
            )
          ) {
            console.info(
              'There is already a build running for this commit, we will stop it and it should be queued in the next retry!',
            );

            const isRunning = await isBuildRunning(
              planUrl,
              identifier,
              authToken,
            );

            if (isRunning) {
              const runningBuilds = await searchJobsbyPlanKey(
                planUrl,
                identifier,
                authToken,
              );

              const { latestBuildIndex } = await getLatestBuildStatus(
                planUrl,
                defaultIdentifier,
                branchName,
                authToken,
              );

              await stopAllRunningBuilds(
                planUrl,
                runningBuilds,
                branchName,
                authToken,
                latestBuildIndex,
              );
            } else {
              console.info(
                `The branch: ${branchName} does not have running builds, nothing to stop!`,
              );
              return;
            }
          }
          throw new Error(
            `Could not queue the build for now: ${buildQueue['status-code']} - ${buildQueue['message']}.`,
          );
        }
        return;
      },
      {
        // Number of retries is 10 by default.
        minTimeout: retryTimeout,
        factor: 2,
        onRetry: e => console.log(e),
      },
    );
  } catch (err) {
    console.error(
      `Even after several retries, it fails with: ${err}.\nIt is most likely that the Bamboo server is busy.\nYour build is possibly queued, check for the ${branchName} in Bamboo, if the build is not yet queued, the next git push to your atlassian-frontend branch will trigger it!.`,
    );
    process.exit(1);
  }
  console.log('The build is now queued!');
}

export async function triggerProductBuild(
  planUrl: string,
  branchName: string,
  authToken: string,
) {
  const existingBranchBuild = await branchBuildRequest(
    planUrl,
    branchName,
    authToken,
    'GET',
  );

  if (existingBranchBuild.status === 200) {
    console.log('Branch build already exists, no need to trigger');
    await queueBuild(planUrl, branchName, authToken, 'POST');
    return;
  }

  const newBranchBuild = await branchBuildRequest(
    planUrl,
    branchName,
    authToken,
    'PUT',
  );

  if (newBranchBuild.status !== 200) {
    const payload = await newBranchBuild.text();
    throw Error(
      `Could not create branch build in product - Status code: ${
        newBranchBuild.status
      } - ${JSON.stringify(payload)}`,
    );
  }

  await queueBuild(planUrl, branchName, authToken, 'POST');
  console.log(`A build is now triggered for ${branchName}.`);
  return newBranchBuild;
}
