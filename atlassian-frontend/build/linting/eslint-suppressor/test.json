[
  {
    "filePath": "/Users/mblaszczyk/dev/atlassian-frontend/packages/smart-experiences/container-picker/src/components/ContainerPicker.tsx",
    "messages": [
      {
        "ruleId": "import/no-extraneous-dependencies",
        "severity": 2,
        "message": "'memoize-one' should be listed in the project's dependencies. Run 'npm i -S memoize-one' to add it",
        "line": 2,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "endLine": 2,
        "endColumn": 38
      },
      {
        "ruleId": "import/no-extraneous-dependencies",
        "severity": 2,
        "message": "'lodash' should be listed in the project's dependencies. Run 'npm i -S lodash' to add it",
        "line": 3,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "endLine": 3,
        "endColumn": 40
      },
      {
        "ruleId": "import/no-extraneous-dependencies",
        "severity": 2,
        "message": "'react-select' should be listed in the project's dependencies. Run 'npm i -S react-select' to add it",
        "line": 4,
        "column": 1,
        "nodeType": "ImportDeclaration",
        "endLine": 4,
        "endColumn": 54
      }
    ],
    "errorCount": 3,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport memoizeOne from 'memoize-one';\nimport debounce from 'lodash/debounce';\nimport { FormatOptionLabelMeta } from 'react-select';\n\nimport Select from '@atlaskit/select';\nimport {\n  WithAnalyticsEventsProps,\n  withAnalyticsEvents,\n} from '@atlaskit/analytics-next';\n\nimport { client } from '../service';\nimport ContainerMenuItem from './DefaultContainerMenuItem';\nimport {\n  ContainerPickerProps,\n  ContainerPickerState as State,\n  ContainerOption,\n  ContainerPickerState,\n  ContainerOptionValue,\n  OptionToSelectableOptions,\n  SearchContext,\n  AtlasKitSelectChange,\n  Value,\n} from '../types';\nimport {\n  EventCreator,\n  createAndFireEventInElementsChannel,\n  Session,\n  startSession,\n  getSessionId,\n  focusEvent,\n  selectEvent,\n  cancelEvent,\n  searchedEvent,\n  requestContainersEvent,\n  successfulRequestContainersEvent,\n  failedRequestContainersEvent,\n} from '../analytics';\n\ntype Props = ContainerPickerProps & WithAnalyticsEventsProps;\n\nconst MAX_REQUEST_OPTIONS = 100;\n\nconst optionToSelectableOption = (\n  option: ContainerOptionValue,\n): ContainerOption => ({\n  label: option.name,\n  value: option,\n});\n\nconst optionToSelectableOptions: OptionToSelectableOptions = memoizeOne<\n  OptionToSelectableOptions\n>(((defaultValue: Value) => {\n  if (!defaultValue) {\n    return null;\n  }\n  if (Array.isArray(defaultValue)) {\n    return defaultValue.map(optionToSelectableOption);\n  }\n  return optionToSelectableOption(defaultValue);\n}) as OptionToSelectableOptions);\n\nclass ContainerPickerInternal extends React.Component<Props, State> {\n  state: State = {\n    error: false,\n    inputValue: '',\n    loading: false,\n    menuIsOpen: false,\n    options: [],\n  };\n\n  static defaultProps = {\n    isMulti: false,\n    maxOptions: 30,\n    principalId: 'Context',\n    maxRequestOptions: MAX_REQUEST_OPTIONS,\n  };\n\n  private session?: Session;\n\n  private journeyId?: string;\n\n  static getDerivedStateFromProps(nextProps: Partial<ContainerPickerProps>) {\n    const derivedState: Partial<ContainerPickerState> = {};\n    if (nextProps.value !== undefined) {\n      derivedState.value = optionToSelectableOptions(nextProps.value);\n    }\n\n    return derivedState;\n  }\n\n  componentDidUpdate(_: ContainerPickerProps, prevState: ContainerPickerState) {\n    const { menuIsOpen, options } = this.state;\n    // load options when the picker open\n    if (menuIsOpen && !prevState.menuIsOpen) {\n      if (!this.session) {\n        // session should have been created onFocus\n        this.startSession();\n      }\n    }\n\n    if (!menuIsOpen && prevState.menuIsOpen && this.session) {\n      this.fireEvent(cancelEvent, prevState);\n      this.session = startSession();\n      this.journeyId = this.session.id;\n      // this.session = undefined;\n    }\n\n    if (\n      menuIsOpen &&\n      ((!prevState.menuIsOpen && options.length > 0) ||\n        options.length !== prevState.options.length)\n    ) {\n      this.fireEvent(searchedEvent);\n    }\n  }\n\n  private fireEvent = (eventCreator: EventCreator, ...args: any[]) => {\n    const { createAnalyticsEvent } = this.props;\n    if (createAnalyticsEvent) {\n      createAndFireEventInElementsChannel(\n        eventCreator(\n          this.props,\n          this.state,\n          this.session,\n          this.journeyId,\n          ...args,\n        ),\n      )(createAnalyticsEvent);\n    }\n  };\n\n  private startSession = () => {\n    this.session = startSession();\n    this.journeyId = this.session.id;\n    this.fireEvent(focusEvent);\n  };\n\n  loadContainers = async (query: string) => {\n    const {\n      cloudId,\n      product,\n      baseUrl,\n      contextType,\n      maxRequestOptions,\n    } = this.props;\n    const sessionId = getSessionId(this.session);\n    const context: SearchContext = {\n      cloudId,\n      sessionId,\n      baseUrl,\n    };\n    const startTime = window.performance.now();\n    try {\n      this.fireEvent(requestContainersEvent);\n      const containers = await client(\n        product,\n        context,\n        contextType,\n        maxRequestOptions || MAX_REQUEST_OPTIONS,\n        query,\n      );\n      // prevent race condition\n      if (sessionId === getSessionId(this.session)) {\n        this.setState({ options: containers, loading: false });\n      }\n      const elapsedTimeMilli = window.performance.now() - startTime;\n      this.fireEvent(successfulRequestContainersEvent, { elapsedTimeMilli });\n    } catch (e) {\n      if (context.sessionId === getSessionId(this.session)) {\n        this.setState({ options: [], loading: false });\n      }\n      const elapsedTimeMilli = window.performance.now() - startTime;\n      this.fireEvent(failedRequestContainersEvent, { elapsedTimeMilli });\n    }\n  };\n\n  debouncedLoadContainers = debounce(\n    this.loadContainers,\n    this.props.debounceTime || 0,\n  );\n\n  private resetInputState = () => {\n    this.setState({\n      inputValue: '',\n    });\n  };\n\n  handleChange: AtlasKitSelectChange = (value, { action, option }) => {\n    this.resetInputState();\n    const { isMulti } = this.props;\n    if (action === 'select-option') {\n      this.fireEvent(selectEvent, isMulti ? option : value);\n      if (isMulti) {\n        this.session = startSession();\n        this.fireEvent(searchedEvent);\n      }\n    }\n    if (!this.props.value) {\n      this.setState({ value });\n    }\n  };\n\n  handleFocus = () => {\n    const { menuIsOpen, options } = this.state;\n    if (!menuIsOpen && !this.session) {\n      // && !this.session\n      this.startSession();\n    }\n    if (options.length === 0) {\n      this.setState({\n        loading: true,\n      });\n      this.debouncedLoadContainers('');\n    }\n    this.setState({ menuIsOpen: true });\n  };\n\n  handleBlur = () => {\n    this.resetInputState();\n    this.debouncedLoadContainers.cancel();\n    const options =\n      this.state.inputValue.length === 0 ? this.state.options : [];\n    this.setState({ loading: false, menuIsOpen: false, options });\n  };\n\n  onInputChange = (query: string) => {\n    if (query !== this.state.inputValue) {\n      this.setState({ loading: true, inputValue: query });\n      this.debouncedLoadContainers(query);\n    }\n  };\n\n  formatOptionLabel = (\n    container: ContainerOption,\n    context: FormatOptionLabelMeta<ContainerOption>,\n  ): React.ReactNode => {\n    if (this.props.formatOptionLabel) {\n      return this.props.formatOptionLabel(container, context);\n    }\n    return <ContainerMenuItem {...container} />;\n  };\n\n  getOptionValue = (option: ContainerOption): string => option.value.id;\n\n  getOptions = (): ContainerOption[] => {\n    const options = this.state.options || [];\n    const { maxOptions, isMulti } = this.props;\n    const { value } = this.state;\n    let filteredOptions = options;\n    // Filter out previously selected options\n    if (isMulti && Array.isArray(value)) {\n      const valueIds: string[] = value.map(item => item.value.id);\n      filteredOptions = options.filter(\n        option => valueIds.indexOf(option.value.id) === -1,\n      );\n    }\n    if (!isMulti && value) {\n      filteredOptions = options.filter(\n        option => option.value.id === (value as ContainerOption).value.id,\n      );\n    }\n    return filteredOptions.slice(0, maxOptions);\n  };\n\n  render() {\n    const { inputValue, menuIsOpen, value } = this.state;\n    const { isMulti, isLoading } = this.props;\n    return (\n      <Select\n        backspaceRemovesValue={isMulti}\n        blurInputOnSelect={!isMulti}\n        className=\"multi-select\"\n        classNamePrefix=\"react-select\"\n        closeMenuOnSelect={!isMulti}\n        enableAnimation={isMulti}\n        formatOptionLabel={this.formatOptionLabel}\n        getOptionValue={this.getOptionValue}\n        hideSelectedOptions\n        inputValue={inputValue}\n        isClearable\n        isLoading={isLoading || this.state.loading}\n        isMulti={isMulti}\n        isSearchable\n        isFocused={menuIsOpen}\n        menuIsOpen={menuIsOpen}\n        onInputChange={this.onInputChange}\n        onChange={this.handleChange}\n        onFocus={this.handleFocus}\n        onBlur={this.handleBlur}\n        onClose={this.handleBlur}\n        options={this.getOptions()}\n        placeholder=\"Choose a Container\"\n        value={value}\n      />\n    );\n  }\n}\n\nexport const ContainerPicker = withAnalyticsEvents()(ContainerPickerInternal);\n"
  }
]
