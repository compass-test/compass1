//==============================================================
/* tslint:disable */
/* eslint-disable */
/* prettier-ignore */
// @generated
// This file was automatically generated and should not be edited.
//==============================================================

import { DocumentNode } from 'graphql';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** DateTime type */
  DateTime: any;
  /** A URL Scala type */
  URL: any;
  /** A JSON scalar */
  JSON: any;
  /** AppStoredEntityFieldValue */
  AppStoredEntityFieldValue: any;
  /** CardTypeHierarchyLevelType */
  CardTypeHierarchyLevelType: any;
  /** Long type */
  Long: any;
  /** Supported colors in the Palette */
  CardPaletteColor: any;
  /** SoftwareBoardPermission */
  SoftwareBoardPermission: any;
  /** SoftwareBoardFeatureKey */
  SoftwareBoardFeatureKey: any;
  /** SprintScopeChangeEventType */
  SprintScopeChangeEventType: any;
  /** A date scalar that accepts string values that are in yyyy-mm-dd format */
  Date: any;
};

/**
 * An Applied Directive is an instances of a directive as applied to a schema
 * element. This type is NOT specified by the graphql specification presently.
 */
export type _AppliedDirective = {
  __typename?: '_AppliedDirective';
  args: Array<_DirectiveArgument>;
  name: Scalars['String'];
};

/**
 * Directive arguments can have names and values.  The values are in graphql SDL
 * syntax printed as a string. This type is NOT specified by the graphql
 * specification presently.
 */
export type _DirectiveArgument = {
  __typename?: '_DirectiveArgument';
  name: Scalars['String'];
  value: Scalars['String'];
};

/**
 * "
 * The lifecycle status of the account
 */
export enum AccountStatus {
  /** The account is an active account */
  ACTIVE = 'active',
  /** The account has been closed */
  CLOSED = 'closed',
  /** The account is no longer an active account */
  INACTIVE = 'inactive',
}

/**  --------------------------------------- API */
export type Activities = {
  __typename?: 'Activities';
  /**
   * get all activity
   * - filters - query filters for the activity stream
   * - first - show 1st <N> items of the response
   */
  all: ActivitiesConnection;
  /** get activity for the currently logged in user */
  myActivities?: Maybe<MyActivities>;
  /**
   * get "Worked on" activity
   * - filters - query filters for the activity stream
   * - first - show 1st <N> items of the response
   */
  workedOn: ActivitiesConnection;
};

/**  --------------------------------------- API */
export type ActivitiesAllArgs = {
  after?: Maybe<Scalars['String']>;
  filters?: Maybe<Array<ActivitiesFilter>>;
  first?: Maybe<Scalars['Int']>;
};

/**  --------------------------------------- API */
export type ActivitiesWorkedOnArgs = {
  after?: Maybe<Scalars['String']>;
  filters?: Maybe<Array<ActivitiesFilter>>;
  first?: Maybe<Scalars['Int']>;
};

export type ActivitiesArguments = {
  /** set of Atlassian account IDs */
  accountIds?: Maybe<Array<Scalars['ID']>>;
  /** set of Cloud IDs */
  cloudIds?: Maybe<Array<Scalars['ID']>>;
  /** set of Container IDs */
  containerIds?: Maybe<Array<Scalars['ID']>>;
  /** The creation time of the earliest events to be included in the result */
  earliestStart?: Maybe<Scalars['DateTime']>;
  /** set of Event Types */
  eventTypes?: Maybe<Array<ActivityEventType>>;
  /** The creation time of the latest events to be included in the result */
  latestStart?: Maybe<Scalars['DateTime']>;
  /** set of Object Types */
  objectTypes?: Maybe<Array<ActivitiesObjectType>>;
  /** set of products */
  products?: Maybe<Array<ActivityProduct>>;
  /** arbitrary transition filters */
  transitions?: Maybe<Array<ActivityTransition>>;
};

/** Extension of ActivitiesEvent, is a part of ActivitiesEventExtension union */
export type ActivitiesCommentedEvent = {
  __typename?: 'ActivitiesCommentedEvent';
  commentId: Scalars['ID'];
};

export type ActivitiesConnection = {
  __typename?: 'ActivitiesConnection';
  edges?: Maybe<Array<Maybe<ActivityEdge>>>;
  nodes: Array<ActivitiesItem>;
  pageInfo: ActivityPageInfo;
};

export type ActivitiesContainer = {
  __typename?: 'ActivitiesContainer';
  cloudId?: Maybe<Scalars['String']>;
  iconUrl?: Maybe<Scalars['URL']>;
  /** Base64 encoded ARI of container. */
  id: Scalars['ID'];
  /** Local (in product) object ID of the corresponding object. */
  localResourceId?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  product?: Maybe<ActivityProduct>;
  type?: Maybe<ActivitiesContainerType>;
  url?: Maybe<Scalars['URL']>;
};

export enum ActivitiesContainerType {
  PROJECT = 'PROJECT',
  SITE = 'SITE',
  SPACE = 'SPACE',
}

export type ActivitiesContributor = {
  __typename?: 'ActivitiesContributor';
  /**
   * count of contributions for sorting by frequency,
   * all event types that is being ingested, except VIEWED and VIEWED_CONTENT
   * is considered to be a contribution
   */
  count?: Maybe<Scalars['Int']>;
  lastAccessedDate?: Maybe<Scalars['DateTime']>;
  profile?: Maybe<User>;
};

export type ActivitiesEvent = Node & {
  __typename?: 'ActivitiesEvent';
  eventType?: Maybe<ActivityEventType>;
  extension?: Maybe<ActivitiesEventExtension>;
  /** Unique event ID */
  id: Scalars['ID'];
  timestamp?: Maybe<Scalars['DateTime']>;
  user?: Maybe<ActivitiesUser>;
};

export type ActivitiesEventExtension =
  | ActivitiesCommentedEvent
  | ActivitiesTransitionedEvent;

export type ActivitiesFilter = {
  arguments?: Maybe<ActivitiesArguments>;
  /** defines relationship in-between filter arguments (AND/OR) */
  type?: Maybe<ActivitiesFilterType>;
};

export enum ActivitiesFilterType {
  AND = 'AND',
  OR = 'OR',
}

export type ActivitiesItem = Node & {
  __typename?: 'ActivitiesItem';
  /** Base64 encoded ARI of the activity. */
  id: Scalars['ID'];
  object?: Maybe<ActivitiesObject>;
  timestamp?: Maybe<Scalars['DateTime']>;
};

/** Extension of ActivitiesObject, is a part of ActivitiesObjectExtension union */
export type ActivitiesJiraIssue = {
  __typename?: 'ActivitiesJiraIssue';
  issueKey?: Maybe<Scalars['String']>;
};

export type ActivitiesObject = Node & {
  __typename?: 'ActivitiesObject';
  cloudId?: Maybe<Scalars['String']>;
  /** Hierarchy of the containers, top container comes first */
  containers?: Maybe<Array<ActivitiesContainer>>;
  contributors?: Maybe<Array<ActivitiesContributor>>;
  events?: Maybe<Array<ActivitiesEvent>>;
  extension?: Maybe<ActivitiesObjectExtension>;
  iconUrl?: Maybe<Scalars['URL']>;
  /** Base64 encoded ARI of the object. */
  id: Scalars['ID'];
  /** Local (in product) object ID of the corresponding object. */
  localResourceId?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  parent?: Maybe<ActivitiesObjectParent>;
  product?: Maybe<ActivityProduct>;
  type?: Maybe<ActivityObjectType>;
  url?: Maybe<Scalars['URL']>;
};

export type ActivitiesObjectEventsArgs = {
  first?: Maybe<Scalars['Int']>;
};

export type ActivitiesObjectExtension = ActivitiesJiraIssue;

export type ActivitiesObjectParent = {
  __typename?: 'ActivitiesObjectParent';
  /** Base64 encoded ARI of the object. */
  id: Scalars['ID'];
  type?: Maybe<ActivityObjectType>;
};

export enum ActivitiesObjectType {
  BLOGPOST = 'BLOGPOST',
  ISSUE = 'ISSUE',
  PAGE = 'PAGE',
  PROJECT = 'PROJECT',
}

/** Extension of ActivitiesEvent, is a part of ActivitiesEventExtension union */
export type ActivitiesTransitionedEvent = {
  __typename?: 'ActivitiesTransitionedEvent';
  from?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

export type ActivitiesUser = {
  __typename?: 'ActivitiesUser';
  profile?: Maybe<User>;
};

export type ActivityEdge = {
  __typename?: 'ActivityEdge';
  cursor: Scalars['String'];
  node?: Maybe<ActivitiesItem>;
};

export enum ActivityEventType {
  ASSIGNED = 'ASSIGNED',
  COMMENTED = 'COMMENTED',
  CREATED = 'CREATED',
  EDITED = 'EDITED',
  LIKED = 'LIKED',
  PUBLISHED = 'PUBLISHED',
  TRANSITIONED = 'TRANSITIONED',
  UNASSIGNED = 'UNASSIGNED',
  UPDATED = 'UPDATED',
  VIEWED = 'VIEWED',
}

export enum ActivityObjectType {
  BLOGPOST = 'BLOGPOST',
  COMMENT = 'COMMENT',
  ISSUE = 'ISSUE',
  PAGE = 'PAGE',
  PROJECT = 'PROJECT',
  SITE = 'SITE',
  SPACE = 'SPACE',
  TASK = 'TASK',
}

export type ActivityPageInfo = {
  __typename?: 'ActivityPageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

export enum ActivityProduct {
  CONFLUENCE = 'CONFLUENCE',
  JIRA = 'JIRA',
  JIRA_BUSINESS = 'JIRA_BUSINESS',
  JIRA_OPS = 'JIRA_OPS',
  JIRA_SERVICE_DESK = 'JIRA_SERVICE_DESK',
  JIRA_SOFTWARE = 'JIRA_SOFTWARE',
  TOWNSQUARE = 'TOWNSQUARE',
}

/**
 * Represents arbitrary transition,
 * e.g. in case of TRANSITIONED event type it could be `from: "inprogress" to: "done"`.
 */
export type ActivityTransition = {
  from?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** Accepts input for adding labels to a component. */
export type AddCompassComponentLabelsInput = {
  /** The ID of the component to add the labels to. */
  componentId: Scalars['ID'];
  /** The collection of labels to add to the component. */
  labelNames: Array<Scalars['String']>;
};

/** The payload returned after adding labels to a component. */
export type AddCompassComponentLabelsPayload = Payload & {
  __typename?: 'AddCompassComponentLabelsPayload';
  /** The collection of labels that were added to the component. */
  addedLabels?: Maybe<Array<CompassComponentLabel>>;
  /** The details of the component that was mutated. */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type AddPolarisColumnInput = {
  /**
   * The column to insert this column before.  If not specified,
   * the new column is added to the right of all columns.
   */
  before?: Maybe<Scalars['ID']>;
  /** The id of the field to add */
  field: Scalars['ID'];
  /** The format to use for the rendering the field's data */
  format?: Maybe<Scalars['String']>;
  /**
   * An override for the column heading; if not specified,
   * the field label should be used.
   */
  heading?: Maybe<Scalars['String']>;
  /** The width to configure on the column */
  width?: Maybe<Scalars['Int']>;
};

/** Only used for inside the schema to mark the context for generic types */
export enum ApiContext {
  DEVOPS = 'DEVOPS',
}

/**
 * This enum is the names of API groupings within the total Atlassian API.
 *
 * This is used by our documentation tooling to group together types and fields into logical groups
 */
export enum ApiGroup {
  CAAS = 'CAAS',
  COMPASS = 'COMPASS',
  DEVOPS_CONTAINER_RELATIONSHIP = 'DEVOPS_CONTAINER_RELATIONSHIP',
  DEVOPS_SERVICE = 'DEVOPS_SERVICE',
  FORGE = 'FORGE',
  JIRA = 'JIRA',
  POLARIS = 'POLARIS',
  XEN_LOGS_API = 'XEN_LOGS_API',
}

export type App = {
  __typename?: 'App';
  avatarFileId?: Maybe<Scalars['String']>;
  contactLink?: Maybe<Scalars['String']>;
  createdBy?: Maybe<User>;
  description: Scalars['String'];
  distributionStatus: Scalars['String'];
  environmentByKey?: Maybe<AppEnvironment>;
  environments: Array<AppEnvironment>;
  id: Scalars['ID'];
  marketplaceApp?: Maybe<MarketplaceApp>;
  name: Scalars['String'];
  privacyPolicy?: Maybe<Scalars['String']>;
  storesPersonalData: Scalars['Boolean'];
  /**
   * A list of app tags.
   * This is a beta field and can be changes without a notice.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppTags` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  tags?: Maybe<Array<Scalars['String']>>;
  termsOfService?: Maybe<Scalars['String']>;
  vendorName?: Maybe<Scalars['String']>;
};

export type AppEnvironmentByKeyArgs = {
  key: Scalars['String'];
};

export type AppAuditConnection = {
  __typename?: 'AppAuditConnection';
  edges?: Maybe<Array<Maybe<AuditEventEdge>>>;
  /** nodes field allows easy access for the first N data items */
  nodes?: Maybe<Array<Maybe<AuditEvent>>>;
  /** pageInfo determines whether there are more entries to query. */
  pageInfo?: Maybe<AuditsPageInfo>;
};

export type AppConnection = {
  __typename?: 'AppConnection';
  edges?: Maybe<Array<Maybe<AppEdge>>>;
  nodes?: Maybe<Array<Maybe<App>>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

export type AppDeployment = {
  __typename?: 'AppDeployment';
  appId: Scalars['ID'];
  createdAt: Scalars['String'];
  createdBy?: Maybe<User>;
  environmentKey: Scalars['String'];
  errorDetails?: Maybe<ErrorDetails>;
  id: Scalars['ID'];
  stages?: Maybe<Array<AppDeploymentStage>>;
  status: AppDeploymentStatus;
};

export type AppDeploymentEvent = {
  createdAt: Scalars['String'];
  stepName: Scalars['String'];
};

export enum AppDeploymentEventLogLevel {
  ERROR = 'ERROR',
  INFO = 'INFO',
  WARNING = 'WARNING',
}

export type AppDeploymentLogEvent = AppDeploymentEvent & {
  __typename?: 'AppDeploymentLogEvent';
  createdAt: Scalars['String'];
  level?: Maybe<AppDeploymentEventLogLevel>;
  message?: Maybe<Scalars['String']>;
  stepName: Scalars['String'];
};

export type AppDeploymentSnapshotLogEvent = AppDeploymentEvent & {
  __typename?: 'AppDeploymentSnapshotLogEvent';
  createdAt: Scalars['String'];
  level?: Maybe<AppDeploymentEventLogLevel>;
  message?: Maybe<Scalars['String']>;
  stepName: Scalars['String'];
};

export type AppDeploymentStage = {
  __typename?: 'AppDeploymentStage';
  description: Scalars['String'];
  events?: Maybe<Array<AppDeploymentEvent>>;
  key: Scalars['String'];
  progress: AppDeploymentStageProgress;
};

export type AppDeploymentStageProgress = {
  __typename?: 'AppDeploymentStageProgress';
  doneSteps: Scalars['Int'];
  totalSteps: Scalars['Int'];
};

export enum AppDeploymentStatus {
  DONE = 'DONE',
  FAILED = 'FAILED',
  IN_PROGRESS = 'IN_PROGRESS',
}

export enum AppDeploymentStepStatus {
  DONE = 'DONE',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export type AppDeploymentTransitionEvent = AppDeploymentEvent & {
  __typename?: 'AppDeploymentTransitionEvent';
  createdAt: Scalars['String'];
  newStatus?: Maybe<AppDeploymentStepStatus>;
  stepName: Scalars['String'];
};

export type AppEdge = {
  __typename?: 'AppEdge';
  cursor: Scalars['String'];
  node?: Maybe<App>;
};

export type AppEnvironment = {
  __typename?: 'AppEnvironment';
  appId: Scalars['ID'];
  createdAt: Scalars['String'];
  createdBy?: Maybe<User>;
  /**
   * This field is currently in BETA - set X-ExperimentalApi-xls-last-deployments-v0 to call it.
   * A list of deployments for app environment
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: xls-last-deployments-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deployments?: Maybe<Array<AppDeployment>>;
  id: Scalars['ID'];
  /** A list of installations of the app */
  installations?: Maybe<Array<AppInstallation>>;
  key: Scalars['String'];
  /** Primary oauth client for the App to interact with Atlassian Authorisation server */
  oauthClient: AtlassianOAuthClient;
  /**
   * This field is **deprecated** and will be removed in the future
   * @deprecated This has been superseeded by having scopes per version
   */
  scopes?: Maybe<Array<Scalars['String']>>;
  type: AppEnvironmentType;
  variables?: Maybe<Array<AppEnvironmentVariable>>;
  /** The list of major versions for this environment in reverse chronological order (i.e. latest versions first) */
  versions?: Maybe<AppEnvironmentVersionConnection>;
};

export type AppEnvironmentVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Used to uniquely identify an environment, when being used as an input. */
export type AppEnvironmentInput = {
  appId: Scalars['ID'];
  key: Scalars['String'];
};

export enum AppEnvironmentType {
  DEVELOPMENT = 'DEVELOPMENT',
  PRODUCTION = 'PRODUCTION',
  STAGING = 'STAGING',
}

export type AppEnvironmentVariable = {
  __typename?: 'AppEnvironmentVariable';
  /** Whether or not to encrypt */
  encrypt: Scalars['Boolean'];
  /** The key of the environment variable */
  key: Scalars['String'];
  /** The value of the environment variable */
  value?: Maybe<Scalars['String']>;
};

/** The input needed to create or update an environment variable. */
export type AppEnvironmentVariableInput = {
  /** Whether or not to encrypt (default=false) */
  encrypt?: Maybe<Scalars['Boolean']>;
  /** The key of the environment variable */
  key: Scalars['String'];
  /** The value of the environment variable */
  value: Scalars['String'];
};

/**
 * Represents a major version of an AppEnvironment.
 * A major version is one that requires consent from end users before upgrading installations, typically a change in
 * the permissions an App requires.
 * Other changes do not trigger a new major version to be created and are instead applied to the latest major version
 */
export type AppEnvironmentVersion = {
  __typename?: 'AppEnvironmentVersion';
  id: Scalars['ID'];
  /** a flag which if true indicates this version is the latest major version for this environment */
  isLatest: Scalars['Boolean'];
  /** A set of migrationKeys for each product corresponding to the Connect App Key */
  migrationKeys?: Maybe<MigrationKeys>;
  /** The permissions that this app requires on installation. These must be consented to by the installer */
  permissions: Array<AppPermission>;
  /** A flag which indicates if this version requires a license */
  requiresLicense: Scalars['Boolean'];
  /** The semver for this version (e.g. 2.4.0) */
  version: Scalars['String'];
};

export type AppEnvironmentVersionConnection = {
  __typename?: 'AppEnvironmentVersionConnection';
  /** A paginated list of AppEnvironmentVersions */
  edges?: Maybe<Array<Maybe<AppEnvironmentVersionEdge>>>;
  /** nodes field allows easy access for the first N data items */
  nodes?: Maybe<Array<Maybe<AppEnvironmentVersion>>>;
  /** pageInfo determines whether there are more entries to query */
  pageInfo: PageInfo;
  /** totalCount is the number of records retrieved on a query */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AppEnvironmentVersionEdge = {
  __typename?: 'AppEnvironmentVersionEdge';
  cursor: Scalars['String'];
  node?: Maybe<AppEnvironmentVersion>;
};

export type AppHostService = {
  __typename?: 'AppHostService';
  description: Scalars['String'];
  name: Scalars['String'];
  scopes?: Maybe<Array<AppHostServiceScope>>;
  serviceId: Scalars['ID'];
};

export type AppHostServiceScope = {
  __typename?: 'AppHostServiceScope';
  description: Scalars['String'];
  key: Scalars['String'];
  name: Scalars['String'];
  service: AppHostService;
};

export type AppInstallation = {
  __typename?: 'AppInstallation';
  /** An object that refers to the installed app */
  app?: Maybe<App>;
  /** An object that refers to the installed app environment */
  appEnvironment?: Maybe<AppEnvironment>;
  /** An object that refers to the installed app environment version */
  appEnvironmentVersion?: Maybe<AppEnvironmentVersion>;
  /** Time when the app was installed */
  createdAt: Scalars['String'];
  /** An object that refers to the account that installed the app */
  createdBy?: Maybe<User>;
  /** A unique Id representing installation the app into a context in the environment */
  id: Scalars['ID'];
  /** A unique Id representing the context into which the app is being installed */
  installationContext: Scalars['ID'];
  license?: Maybe<AppInstallationLicense>;
  /** An object that refers to the version of the installation */
  version?: Maybe<AppVersion>;
};

export type AppInstallationConnection = {
  __typename?: 'AppInstallationConnection';
  edges?: Maybe<Array<Maybe<AppInstallationEdge>>>;
  nodes?: Maybe<Array<Maybe<AppInstallation>>>;
  pageInfo: PageInfo;
};

export type AppInstallationContext = {
  __typename?: 'AppInstallationContext';
  id: Scalars['ID'];
};

export type AppInstallationCreationTask = AppInstallationTask & {
  __typename?: 'AppInstallationCreationTask';
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  appVersionId?: Maybe<Scalars['ID']>;
  context: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

export type AppInstallationDeletionTask = AppInstallationTask & {
  __typename?: 'AppInstallationDeletionTask';
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  context: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

export type AppInstallationEdge = {
  __typename?: 'AppInstallationEdge';
  cursor: Scalars['String'];
  node?: Maybe<AppInstallation>;
};

/** Input payload for the app environment install mutation */
export type AppInstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID'];
  /** Whether the installation will be done asynchronously */
  async?: Maybe<Scalars['Boolean']>;
  /** The key of the app's environment to be used for installation */
  environmentKey: Scalars['String'];
  /** A unique Id representing the context into which the app is being installed */
  installationContext: Scalars['ID'];
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: Maybe<LicenseOverrideState>;
  /** A unique Id representing a specific version of an app */
  versionId?: Maybe<Scalars['ID']>;
};

export type AppInstallationLicense = {
  __typename?: 'AppInstallationLicense';
  active: Scalars['Boolean'];
  billingPeriod?: Maybe<Scalars['String']>;
  isEvaluation?: Maybe<Scalars['Boolean']>;
  subscriptionEndDate?: Maybe<Scalars['DateTime']>;
  supportEntitlementNumber?: Maybe<Scalars['String']>;
  trialEndDate?: Maybe<Scalars['DateTime']>;
  type?: Maybe<Scalars['String']>;
};

/** The response from the installation of an app environment */
export type AppInstallationResponse = Payload & {
  __typename?: 'AppInstallationResponse';
  errors?: Maybe<Array<MutationError>>;
  installationId?: Maybe<Scalars['ID']>;
  success: Scalars['Boolean'];
  taskId?: Maybe<Scalars['ID']>;
};

export type AppInstallationsFilter = {
  appId: Scalars['ID'];
  environmentType?: Maybe<AppEnvironmentType>;
};

export type AppInstallationSubscribeTask = AppInstallationTask & {
  __typename?: 'AppInstallationSubscribeTask';
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  context: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

export type AppInstallationTask = {
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

export type AppInstallationUnsubscribeTask = AppInstallationTask & {
  __typename?: 'AppInstallationUnsubscribeTask';
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  context: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

/** Input payload for the app environment upgrade mutation */
export type AppInstallationUpgradeInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID'];
  /** Whether the installation upgrade will be done asynchronously */
  async?: Maybe<Scalars['Boolean']>;
  /** The key of the app's environment to be used for installation upgrade */
  environmentKey: Scalars['String'];
  /** A unique Id representing the context into which the app is being upgraded */
  installationContext: Scalars['ID'];
  /** A unique Id representing a specific major version of the app */
  versionId?: Maybe<Scalars['ID']>;
};

/** The response from the installation upgrade of an app environment */
export type AppInstallationUpgradeResponse = Payload & {
  __typename?: 'AppInstallationUpgradeResponse';
  errors?: Maybe<Array<MutationError>>;
  installationId?: Maybe<Scalars['ID']>;
  success: Scalars['Boolean'];
  taskId?: Maybe<Scalars['ID']>;
};

export type AppInstallationUpgradeTask = AppInstallationTask & {
  __typename?: 'AppInstallationUpgradeTask';
  appEnvironmentId?: Maybe<Scalars['ID']>;
  appId: Scalars['ID'];
  appVersionId?: Maybe<Scalars['ID']>;
  context: Scalars['ID'];
  errors?: Maybe<Array<MutationError>>;
  id: Scalars['ID'];
  state: AppTaskState;
};

export type AppLog = FunctionInvocationMetadata &
  Node & {
    __typename?: 'AppLog';
    /**
     * Gets up to 200 earliest log lines for this invocation.
     * For getting more log lines use appLogLines field in Query type.
     */
    appLogLines?: Maybe<AppLogLines>;
    appVersion: Scalars['String'];
    function?: Maybe<FunctionDescription>;
    id: Scalars['ID'];
    installationContext?: Maybe<AppInstallationContext>;
    moduleType?: Maybe<Scalars['String']>;
    /**
     * The start time of the invocation
     *
     * RFC-3339 formatted timestamp.
     */
    startTime?: Maybe<Scalars['String']>;
    trigger?: Maybe<FunctionTrigger>;
  };

export type AppLogAppLogLinesArgs = {
  first?: Maybe<Scalars['Int']>;
};

/** Relay-style Connection to `AppLog` objects. */
export type AppLogConnection = {
  __typename?: 'AppLogConnection';
  edges?: Maybe<Array<Maybe<AppLogEdge>>>;
  nodes?: Maybe<Array<Maybe<AppLog>>>;
  pageInfo: PageInfo;
};

/** Relay-style Edge to an `AppLog` object. */
export type AppLogEdge = {
  __typename?: 'AppLogEdge';
  cursor: Scalars['String'];
  node: AppLog;
};

export type AppLogLine = {
  __typename?: 'AppLogLine';
  /**
   * Log level of log line.  Typically one of:
   * TRACE, DEBUG, INFO, WARN, ERROR, FATAL
   */
  level?: Maybe<Scalars['String']>;
  /** The free-form textual message from the log statement. */
  message?: Maybe<Scalars['String']>;
  /**
   * We really don't know what other fields may be in the logs.
   *
   * This field may be an array or an object.
   *
   * If it's an object, it will include only fields in `includeFields`,
   * unless `includeFields` is null, in which case it will include
   * all fields that are not in `excludeFields`.
   *
   * If it's an array it will include the entire array.
   */
  other?: Maybe<Scalars['JSON']>;
  /**
   * Time the log line was issued
   *
   * RFC-3339 formatted timestamp
   */
  timestamp: Scalars['String'];
};

/** Relay-style Connection to `AppLogLine` objects. */
export type AppLogLineConnection = {
  __typename?: 'AppLogLineConnection';
  edges?: Maybe<Array<Maybe<AppLogLineEdge>>>;
  /** Metadata about the function invocation (applies to all log lines of invocation) */
  metadata: FunctionInvocationMetadata;
  nodes?: Maybe<Array<Maybe<AppLogLine>>>;
  pageInfo: PageInfo;
};

/** Relay-style Edge to an `AppLogLine` object. */
export type AppLogLineEdge = {
  __typename?: 'AppLogLineEdge';
  cursor: Scalars['String'];
  node: AppLogLine;
};

/**
 * AppLogLines returned from AppLog query.
 *
 * Not quite a Relay-style Connection since you can't page from this query.
 */
export type AppLogLines = {
  __typename?: 'AppLogLines';
  edges?: Maybe<Array<Maybe<AppLogLineEdge>>>;
  nodes?: Maybe<Array<Maybe<AppLogLine>>>;
  pageInfo: PageInfo;
};

/** The payload returned from applying a scorecard to a component. */
export type ApplyCompassScorecardToComponentPayload = Payload & {
  __typename?: 'ApplyCompassScorecardToComponentPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type ApplyPolarisProjectTemplateInput = {
  ideaType: Scalars['ID'];
  project: Scalars['ID'];
  template: Scalars['ID'];
};

export type ApplyPolarisProjectTemplatePayload = Payload & {
  __typename?: 'ApplyPolarisProjectTemplatePayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type AppNetworkEgressPermission = {
  __typename?: 'AppNetworkEgressPermission';
  addresses?: Maybe<Array<Scalars['String']>>;
  type?: Maybe<AppNetworkPermissionType>;
};

export type AppNetworkEgressPermissionExtension = {
  __typename?: 'AppNetworkEgressPermissionExtension';
  addresses?: Maybe<Array<Scalars['String']>>;
  type?: Maybe<AppNetworkPermissionTypeExtension>;
};

export enum AppNetworkPermissionType {
  FETCH_BACKEND_SIDE = 'FETCH_BACKEND_SIDE',
  FETCH_CLIENT_SIDE = 'FETCH_CLIENT_SIDE',
  FONTS = 'FONTS',
  FRAMES = 'FRAMES',
  IMAGES = 'IMAGES',
  MEDIA = 'MEDIA',
  NAVIGATION = 'NAVIGATION',
  SCRIPTS = 'SCRIPTS',
  STYLES = 'STYLES',
}

export enum AppNetworkPermissionTypeExtension {
  FETCH_BACKEND_SIDE = 'FETCH_BACKEND_SIDE',
  FETCH_CLIENT_SIDE = 'FETCH_CLIENT_SIDE',
  FONTS = 'FONTS',
  FRAMES = 'FRAMES',
  IMAGES = 'IMAGES',
  MEDIA = 'MEDIA',
  NAVIGATION = 'NAVIGATION',
  SCRIPTS = 'SCRIPTS',
  STYLES = 'STYLES',
}

/** Permissions that relate to the App's interaction with supported APIs and supported network egress */
export type AppPermission = {
  __typename?: 'AppPermission';
  egress?: Maybe<Array<AppNetworkEgressPermission>>;
  scopes: Array<AppHostServiceScope>;
  securityPolicies?: Maybe<Array<AppSecurityPoliciesPermission>>;
};

export type AppSecurityPoliciesPermission = {
  __typename?: 'AppSecurityPoliciesPermission';
  policies?: Maybe<Array<Scalars['String']>>;
  type?: Maybe<AppSecurityPoliciesPermissionType>;
};

export type AppSecurityPoliciesPermissionExtension = {
  __typename?: 'AppSecurityPoliciesPermissionExtension';
  policies?: Maybe<Array<Scalars['String']>>;
  type?: Maybe<AppSecurityPoliciesPermissionTypeExtension>;
};

export enum AppSecurityPoliciesPermissionType {
  SCRIPTS = 'SCRIPTS',
  STYLES = 'STYLES',
}

export enum AppSecurityPoliciesPermissionTypeExtension {
  SCRIPTS = 'SCRIPTS',
  STYLES = 'STYLES',
}

export type AppServicesFilter = {
  name: Scalars['String'];
};

export type AppsFilter = {
  isPublishable?: Maybe<Scalars['Boolean']>;
  migrationKey?: Maybe<Scalars['String']>;
};

export type AppStorageMutation = {
  __typename?: 'AppStorageMutation';
  /**
   * Delete an untyped entity in a specific context given a key
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deleteAppStoredEntity?: Maybe<DeleteAppStoredEntityPayload>;
  /**
   * Set an untyped entity in a specific context given a key
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  setAppStoredEntity?: Maybe<SetAppStoredEntityPayload>;
};

export type AppStorageMutationDeleteAppStoredEntityArgs = {
  input: DeleteAppStoredEntityMutationInput;
};

export type AppStorageMutationSetAppStoredEntityArgs = {
  input: SetAppStoredEntityMutationInput;
};

export type AppStoredEntity = {
  __typename?: 'AppStoredEntity';
  /**
   * The identifier for this entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID'];
  /**
   * Entities may be up to 2000 bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value?: Maybe<Scalars['JSON']>;
};

export enum AppStoredEntityCondition {
  STARTS_WITH = 'STARTS_WITH',
}

export type AppStoredEntityConnection = {
  __typename?: 'AppStoredEntityConnection';
  /** The AppStoredEntityConnection is a paginated list of Entities from storage service */
  edges?: Maybe<Array<Maybe<AppStoredEntityEdge>>>;
  /** nodes field allows easy access for the first N data items */
  nodes?: Maybe<Array<Maybe<AppStoredEntity>>>;
  /** pageInfo determines whether there are more entries to query. */
  pageInfo?: Maybe<AppStoredEntityPageInfo>;
  /** totalCount is the number of records retrived on a query. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AppStoredEntityEdge = {
  __typename?: 'AppStoredEntityEdge';
  /**
   * Edge is a combination of node and cursor and follows the relay specs.
   *
   * Cursor returns the key of the last record that was queried and
   * should be used as input to after when querying for paginated entities
   */
  cursor: Scalars['String'];
  node?: Maybe<AppStoredEntity>;
};

/**
 * The identifier for this entity
 *
 * where condition to filter
 */
export type AppStoredEntityFilter = {
  condition: AppStoredEntityCondition;
  /** Condition filter to be provided when querying for Entities. */
  field: Scalars['String'];
  value: Scalars['AppStoredEntityFieldValue'];
};

export type AppStoredEntityPageInfo = {
  __typename?: 'AppStoredEntityPageInfo';
  /** The pageInfo is the place to allow code to navigate the paginated list. */
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

export type AppSubscribeInput = {
  appId: Scalars['ID'];
  envKey: Scalars['String'];
  installationContext: Scalars['ID'];
};

export type AppSubscribePayload = Payload & {
  __typename?: 'AppSubscribePayload';
  errors?: Maybe<Array<MutationError>>;
  installation?: Maybe<AppInstallation>;
  success: Scalars['Boolean'];
  taskId?: Maybe<Scalars['ID']>;
};

export enum AppTaskState {
  COMPLETE = 'COMPLETE',
  FAILED = 'FAILED',
  PENDING = 'PENDING',
  RUNNING = 'RUNNING',
}

export type AppTunnelDefinitions = {
  __typename?: 'AppTunnelDefinitions';
  customUI?: Maybe<Array<Maybe<CustomUiTunnelDefinition>>>;
  /** The URL to tunnel FaaS calls to */
  faasTunnelUrl?: Maybe<Scalars['URL']>;
};

/** Input payload for the app environment uninstall mutation */
export type AppUninstallationInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID'];
  /** Whether the installation will be done asynchronously */
  async?: Maybe<Scalars['Boolean']>;
  /** The key of the app's environment to be used for uninstallation */
  environmentKey: Scalars['String'];
  /** A unique Id representing the context into which the app is being uninstalled */
  installationContext?: Maybe<Scalars['ID']>;
  /** A unique Id representing the installationId" */
  installationId?: Maybe<Scalars['ID']>;
  /** Bypass licensing flow if licenseOverride is set */
  licenseOverride?: Maybe<LicenseOverrideState>;
};

/** The response from the uninstallation of an app environment */
export type AppUninstallationResponse = Payload & {
  __typename?: 'AppUninstallationResponse';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
  taskId?: Maybe<Scalars['ID']>;
};

export type AppUnsubscribeInput = {
  appId: Scalars['ID'];
  envKey: Scalars['String'];
  installationContext: Scalars['ID'];
};

export type AppUnsubscribePayload = Payload & {
  __typename?: 'AppUnsubscribePayload';
  errors?: Maybe<Array<MutationError>>;
  installation?: Maybe<AppInstallation>;
  success: Scalars['Boolean'];
  taskId?: Maybe<Scalars['ID']>;
};

/**
 * This does not represent a real person but rather the identity that backs an installed application
 *
 * See the documentation on the `User` for more details
 */
export type AppUser = User & {
  __typename?: 'AppUser';
  accountId: Scalars['ID'];
  accountStatus: AccountStatus;
  name: Scalars['String'];
  picture: Scalars['URL'];
};

export type AppVersion = {
  __typename?: 'AppVersion';
  isLatest: Scalars['Boolean'];
};

export type ArchivePolarisInsightsPayload = Payload & {
  __typename?: 'ArchivePolarisInsightsPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type ArjConfiguration = {
  __typename?: 'ArjConfiguration';
  epicLinkCustomFieldId?: Maybe<Scalars['String']>;
  parentCustomFieldId?: Maybe<Scalars['String']>;
};

export type ArjHierarchyConfigurationLevel = {
  __typename?: 'ArjHierarchyConfigurationLevel';
  issueTypes?: Maybe<Array<Scalars['String']>>;
  title: Scalars['String'];
};

export type AssignIssueParentInput = {
  boardId: Scalars['ID'];
  issueIds: Array<Scalars['ID']>;
  issueParentId: Scalars['ID'];
};

export type AssignIssueParentOutput = MutationResponse & {
  __typename?: 'AssignIssueParentOutput';
  boardScope?: Maybe<BoardScope>;
  clientMutationId?: Maybe<Scalars['ID']>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/**
 * This represents a real person that has an account in a wide range of Atlassian products
 *
 * See the documentation on the `User` and `LocalizationContext` for more details
 */
export type AtlassianAccountUser = LocalizationContext &
  User & {
    __typename?: 'AtlassianAccountUser';
    accountId: Scalars['ID'];
    accountStatus: AccountStatus;
    email?: Maybe<Scalars['String']>;
    locale?: Maybe<Scalars['String']>;
    name: Scalars['String'];
    picture: Scalars['URL'];
    zoneinfo?: Maybe<Scalars['String']>;
  };

export type AtlassianOAuthClient = {
  __typename?: 'AtlassianOAuthClient';
  /** Callback url where the users are redirected once the authentication is complete */
  callbacks?: Maybe<Array<Scalars['String']>>;
  /** Identifier of the client for authentication */
  clientID: Scalars['ID'];
  /** Rotating refresh token status for the auth client */
  refreshToken?: Maybe<RefreshToken>;
};

/** Hosting type where Atlassian product instance is installed. */
export enum AtlassianProductHostingType {
  CLOUD = 'CLOUD',
  DATA_CENTER = 'DATA_CENTER',
  SERVER = 'SERVER',
}

/** Accepts input to attach a data manager to a component. */
export type AttachCompassComponentDataManagerInput = {
  /** The ID of the component to attach a data manager to. */
  componentId: Scalars['ID'];
  /** An URL of the external source of the component's data. */
  externalSourceURL?: Maybe<Scalars['URL']>;
};

/** The payload returned from attaching a data manager to a component. */
export type AttachCompassComponentDataManagerPayload = Payload & {
  __typename?: 'AttachCompassComponentDataManagerPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type AttachEventSourceInput = {
  /** The ID of the component to attach the event source to. */
  componentId: Scalars['ID'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID'];
};

export type AttachEventSourcePayload = Payload & {
  __typename?: 'AttachEventSourcePayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type AuditEvent = {
  __typename?: 'AuditEvent';
  /** The attributes of an audit event */
  attributes: AuditEventAttributes;
  /** Audit Event Id */
  id: Scalars['ID'];
  /** Message with content and format to be displayed */
  message?: Maybe<AuditMessageObject>;
};

export type AuditEventAttributes = {
  __typename?: 'AuditEventAttributes';
  /** The action for audit log event */
  action: Scalars['String'];
  /** The Actor who created the event */
  actor?: Maybe<User>;
  /** The Container EventObjects for this event */
  container: Array<Maybe<ContainerEventObject>>;
  /** The Context EventObjects for this event */
  context: Array<Maybe<ContextEventObject>>;
  /** The time when the event occurred */
  time: Scalars['String'];
};

export type AuditEventEdge = {
  __typename?: 'AuditEventEdge';
  cursor: Scalars['String'];
  node?: Maybe<AuditEvent>;
};

export type AuditMessageObject = {
  __typename?: 'AuditMessageObject';
  content?: Maybe<Scalars['String']>;
  format?: Maybe<Scalars['String']>;
};

export type AuditsPageInfo = {
  __typename?: 'AuditsPageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

/** This type contains information about the currently logged in user */
export type AuthenticationContext = {
  __typename?: 'AuthenticationContext';
  /** Information about the currently logged in user. */
  user?: Maybe<User>;
};

export type AuthToken = {
  __typename?: 'AuthToken';
  token: Scalars['String'];
  ttl: Scalars['Int'];
};

/** Payload to invoke an AUX Effect */
export type AuxEffectsInvocationPayload = {
  /** Configuration arguments for the instance of the AUX extension */
  config?: Maybe<Scalars['JSON']>;
  /** Environment information about where the effects are dispatched from */
  context: Scalars['JSON'];
  /** The effects to action inside the function */
  effects: Array<Scalars['JSON']>;
  /** The current state of the AUX extension */
  state: Scalars['JSON'];
};

/** A response to an aux invocation */
export type AuxEffectsResult = {
  __typename?: 'AuxEffectsResult';
  /**
   * The list of effects in response to an aux effects invocation.
   *
   * Render effects should return valid rendering effects to the invoker,
   * to allow the front-end to render the required content. These are kept as
   * generic JSON blobs since consumers of this API are responsible for defining
   * what these effects look like.
   */
  effects: Array<Scalars['JSON']>;
};

export type AvailableEstimations = {
  __typename?: 'AvailableEstimations';
  /** Name of the estimation. */
  name: Scalars['String'];
  /** Unique identifier of the estimation. Temporary naming until we remove "statistic" from Jira. */
  statisticFieldId: Scalars['String'];
};

/** The input for a Avatar for a Third Party Repository */
export type AvatarInput = {
  /** The description of the avatar. */
  description?: Maybe<Scalars['String']>;
  /** The URL of the avatar. */
  webUrl?: Maybe<Scalars['String']>;
};

export type Backlog = {
  __typename?: 'Backlog';
  /** List of the assignees of all cards currently displayed on the backlog */
  assignees?: Maybe<Array<Maybe<User>>>;
  /**
   * Temporarily needed to support legacy write API_.  the issue list key to use when creating issue's on the board.
   * Required when creating issues on a board with backlogs
   */
  boardIssueListKey?: Maybe<Scalars['String']>;
  /** List of card types which can be created directly on the backlog or sprints */
  cardTypes: Array<Maybe<CardType>>;
  cards: Array<Maybe<SoftwareCard>>;
  /** connect add-ons information */
  extension?: Maybe<BacklogExtension>;
  /** Labels for filtering and adding to cards */
  labels: Array<Maybe<Scalars['String']>>;
  /** Whether or not to show the 'migrate this column to your backlog' prompt (set when first enabling backlogs) */
  requestColumnMigration: Scalars['Boolean'];
};

export type BacklogCardsArgs = {
  cardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

export type BacklogExtension = {
  __typename?: 'BacklogExtension';
  /** list of operations that add-on can perform */
  operations?: Maybe<Array<Maybe<SoftwareOperation>>>;
};

/** Bitbucket Permission Enum */
export enum BitbucketPermission {
  /** Bitbucket admin permission */
  ADMIN = 'ADMIN',
}

export type BitbucketQuery = {
  __typename?: 'BitbucketQuery';
  /** Look up the Bitbucket repository by ARI. */
  bitbucketRepository?: Maybe<BitbucketRepository>;
  /** Look up the Bitbucket workspace by ARI. */
  bitbucketWorkspace?: Maybe<BitbucketWorkspace>;
};

export type BitbucketQueryBitbucketRepositoryArgs = {
  id: Scalars['ID'];
};

export type BitbucketQueryBitbucketWorkspaceArgs = {
  id: Scalars['ID'];
};

export type BitbucketRepository = Node & {
  __typename?: 'BitbucketRepository';
  /** The Bitbucket avatar. */
  avatar?: Maybe<BitbucketRepositoryAvatar>;
  /**
   * The connection entity for DevOps Service relationships for this Bitbucket repository, according to the specified
   * pagination, filtering and sorting.
   */
  devOpsServiceRelationships?: Maybe<
    DevOpsServiceAndRepositoryRelationshipConnection
  >;
  /** The ARI of the Bitbucket repository. */
  id: Scalars['ID'];
  /**
   * The connection entity for Jira project relationships for this Bitbucket repository, according to the specified
   * pagination, filtering and sorting.
   */
  jiraProjectRelationships?: Maybe<
    JiraProjectAndRepositoryRelationshipConnection
  >;
  /** Name of Bitbucket repository. */
  name: Scalars['String'];
  /** URI for accessing Bitbucket repository. */
  webUrl: Scalars['URL'];
  /** Bitbucket workspace the repository is part of. */
  workspace?: Maybe<BitbucketWorkspace>;
};

export type BitbucketRepositoryDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  sort?: Maybe<DevOpsServiceAndRepositoryRelationshipSort>;
};

export type BitbucketRepositoryJiraProjectRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  filter?: Maybe<JiraProjectAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  sort?: Maybe<JiraProjectAndRepositoryRelationshipSort>;
};

export type BitbucketRepositoryAvatar = {
  __typename?: 'BitbucketRepositoryAvatar';
  /** URI for retrieving Bitbucket avatar. */
  url: Scalars['URL'];
};

export type BitbucketRepositoryConnection = {
  __typename?: 'BitbucketRepositoryConnection';
  edges?: Maybe<Array<Maybe<BitbucketRepositoryEdge>>>;
  nodes?: Maybe<Array<Maybe<BitbucketRepository>>>;
  pageInfo: PageInfo;
};

export type BitbucketRepositoryEdge = {
  __typename?: 'BitbucketRepositoryEdge';
  cursor: Scalars['String'];
  node?: Maybe<BitbucketRepository>;
};

export type BitbucketRepositoryIdConnection = {
  __typename?: 'BitbucketRepositoryIdConnection';
  edges?: Maybe<Array<Maybe<BitbucketRepositoryIdEdge>>>;
  pageInfo: PageInfo;
};

export type BitbucketRepositoryIdEdge = {
  __typename?: 'BitbucketRepositoryIdEdge';
  cursor: Scalars['String'];
  node?: Maybe<BitbucketRepository>;
};

export type BitbucketWorkspace = Node & {
  __typename?: 'BitbucketWorkspace';
  /** The ARI of the Bitbucket workspace. */
  id: Scalars['ID'];
  /** Name of the Bitbucket workspace. */
  name: Scalars['String'];
  /**
   * List of Bitbucket Repositories belong to the Bitbucket Workspace
   * The returned repositories are filtered based on user permission and role-value specified by permissionFilter argument.
   * If no permissionFilter specified, the list contains all repositories that user can access.
   */
  repositories?: Maybe<BitbucketRepositoryConnection>;
};

export type BitbucketWorkspaceRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  permissionFilter?: Maybe<BitbucketPermission>;
};

export type BoardCardMoveInput = {
  /** the ID of a board */
  boardId?: Maybe<Scalars['ID']>;
  /** The IDs of cards to move */
  cardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** Card information on where card should be positioned */
  rank?: Maybe<CardRank>;
  /** The swimlane position, which might set additional fields */
  swimlaneId?: Maybe<Scalars['ID']>;
  /** The ID of the transition */
  transition?: Maybe<Scalars['ID']>;
};

export type BoardEditConfig = {
  __typename?: 'BoardEditConfig';
  /** Configuration for showing inline card create */
  inlineCardCreate?: Maybe<InlineCardCreateConfig>;
  /** Configuration for showing inline column mutations */
  inlineColumnEdit?: Maybe<InlineColumnEditConfig>;
};

export type BoardFeature = {
  __typename?: 'BoardFeature';
  category: Scalars['String'];
  key?: Maybe<Scalars['SoftwareBoardFeatureKey']>;
  prerequisites?: Maybe<Array<Maybe<BoardFeature>>>;
  status?: Maybe<BoardFeatureStatus>;
  toggle?: Maybe<BoardFeatureToggleStatus>;
};

/** Relay connection definition for a list of board features */
export type BoardFeatureConnection = {
  __typename?: 'BoardFeatureConnection';
  edges?: Maybe<Array<Maybe<BoardFeatureEdge>>>;
  pageInfo?: Maybe<PageInfo>;
};

/** Relay edge definition for a board feature */
export type BoardFeatureEdge = {
  __typename?: 'BoardFeatureEdge';
  /** The cursor position of this edge. Used for pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The feature group of the edge */
  node?: Maybe<BoardFeatureView>;
  /** The order of this edge */
  order?: Maybe<Scalars['Int']>;
};

export type BoardFeatureGroup = Node & {
  __typename?: 'BoardFeatureGroup';
  /** The board features in this group */
  features?: Maybe<BoardFeatureConnection>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

/** Relay connection definition for a list of board feature groups */
export type BoardFeatureGroupConnection = {
  __typename?: 'BoardFeatureGroupConnection';
  /** The list of edges of this connection */
  edges?: Maybe<Array<Maybe<BoardFeatureGroupEdge>>>;
  /** Page detail for pagination */
  pageInfo?: Maybe<PageInfo>;
};

/** Relay edge definition for a board feature group */
export type BoardFeatureGroupEdge = {
  __typename?: 'BoardFeatureGroupEdge';
  /** The cursor position of this edge. Used for pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The board feature group of the edge */
  node?: Maybe<BoardFeatureGroup>;
  /** The order of this edge */
  order?: Maybe<Scalars['Int']>;
};

export enum BoardFeatureStatus {
  COMING_SOON = 'COMING_SOON',
  DISABLED = 'DISABLED',
  ENABLED = 'ENABLED',
}

export enum BoardFeatureToggleStatus {
  DISABLED = 'DISABLED',
  ENABLED = 'ENABLED',
}

export type BoardFeatureView = Node & {
  __typename?: 'BoardFeatureView';
  canEnable?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  isEnabled?: Maybe<Scalars['Boolean']>;
  title?: Maybe<Scalars['String']>;
};

/** Root node for queries about simple / agility / nextgen boards. */
export type BoardScope = {
  __typename?: 'BoardScope';
  /** Null if there's no backlog */
  backlog?: Maybe<Backlog>;
  board?: Maybe<SoftwareBoard>;
  /** Card parents (AKA Epics) for filtering and adding to cards */
  cardParents: Array<Maybe<CardParent>>;
  /** Cards in the board scope with given card IDs */
  cards: Array<Maybe<SoftwareCard>>;
  /** Information about the user making this request. */
  currentUser: CurrentUser;
  /**
   * Custom filters for this board scope
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: customFilters` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  customFilters?: Maybe<Array<Maybe<CustomFilter>>>;
  /** Estimation type currently configured for the board. */
  estimation?: Maybe<EstimationConfig>;
  /**
   * List of all feature groups on the board. This is similar to the list of
   * features, but support groupings for the frontend to render
   */
  featureGroups?: Maybe<BoardFeatureGroupConnection>;
  /** List of all features on the board, and their state. */
  features: Array<Maybe<BoardFeature>>;
  /**
   * Return filtered card Ids on applying custom filters
   * This mutation is currently in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: filteredCardIds` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  filteredCardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** The project location for this board scope */
  projectLocation: SoftwareProject;
  /** List of reports on this board.  null if reports are not enabled on this board. */
  reports?: Maybe<SoftwareReports>;
  /** Request sprint by Id. */
  sprint?: Maybe<Sprint>;
  /** Null if sprints are disabled (empty if there are no sprints) */
  sprints?: Maybe<Array<Maybe<Sprint>>>;
  /** Current user's swimlane-strategy, NONE if SWAG was unable to retrieve it */
  userSwimlaneStrategy?: Maybe<SwimlaneStrategy>;
};

/** Root node for queries about simple / agility / nextgen boards. */
export type BoardScopeCardsArgs = {
  cardIds: Array<Maybe<Scalars['ID']>>;
};

/** Root node for queries about simple / agility / nextgen boards. */
export type BoardScopeFilteredCardIdsArgs = {
  customFilterIds: Array<Maybe<Scalars['ID']>>;
  issueIds: Array<Maybe<Scalars['ID']>>;
};

/** Root node for queries about simple / agility / nextgen boards. */
export type BoardScopeSprintArgs = {
  sprintId: Scalars['ID'];
};

/** Root node for queries about simple / agility / nextgen boards. */
export type BoardScopeSprintsArgs = {
  state?: Maybe<Array<Maybe<SprintState>>>;
};

export enum BuiltinPolarisIdeaField {
  /**  Jira Product Discovery fields */
  ARCHIVED = 'ARCHIVED',
  ARCHIVED_BY = 'ARCHIVED_BY',
  ARCHIVED_ON = 'ARCHIVED_ON',
  /**  Jira fields */
  ASSIGNEE = 'ASSIGNEE',
  CREATED = 'CREATED',
  CREATOR = 'CREATOR',
  DELIVERY_PROGRESS = 'DELIVERY_PROGRESS',
  DELIVERY_STATUS = 'DELIVERY_STATUS',
  DESCRIPTION = 'DESCRIPTION',
  ISSUE_COMMENTS = 'ISSUE_COMMENTS',
  ISSUE_ID = 'ISSUE_ID',
  ISSUE_TYPE = 'ISSUE_TYPE',
  KEY = 'KEY',
  LABELS = 'LABELS',
  LINKED_ISSUES = 'LINKED_ISSUES',
  NUM_DATA_POINTS = 'NUM_DATA_POINTS',
  REPORTER = 'REPORTER',
  STATUS = 'STATUS',
  SUMMARY = 'SUMMARY',
  UPDATED = 'UPDATED',
  VOTES = 'VOTES',
}

/** Burndown chart focuses on remaining scope over time */
export type BurndownChart = {
  __typename?: 'BurndownChart';
  /** Burndown charts are graphing the remaining over time */
  chart: BurndownChartData;
  /** Filters for the report */
  filters: SprintReportsFilters;
};

/** Burndown chart focuses on remaining scope over time */
export type BurndownChartChartArgs = {
  estimation?: Maybe<SprintReportsEstimationStatisticType>;
  sprintId?: Maybe<Scalars['ID']>;
};

export type BurndownChartData = {
  __typename?: 'BurndownChartData';
  /** the set end time of the sprint, not when the sprint completed */
  endTime?: Maybe<Scalars['DateTime']>;
  /**
   * data for a sprint scope change
   * each point are assumed to be scope change during a sprint
   */
  scopeChangeEvents: Array<Maybe<SprintScopeChangeData>>;
  /**
   * data for sprint end event
   * can be null if sprint has not been completed yet
   */
  sprintEndEvent?: Maybe<SprintEndData>;
  /** data for sprint start event */
  sprintStartEvent: SprintStartData;
  /** the start time of the sprint */
  startTime?: Maybe<Scalars['DateTime']>;
  /** data for the table */
  table?: Maybe<BurndownChartDataTable>;
  /** the current user's timezone */
  timeZone?: Maybe<Scalars['String']>;
};

export type BurndownChartDataTable = {
  __typename?: 'BurndownChartDataTable';
  completedIssues: Array<Maybe<BurndownChartDataTableIssueRow>>;
  completedIssuesOutsideOfSprint: Array<Maybe<BurndownChartDataTableIssueRow>>;
  incompleteIssues: Array<Maybe<BurndownChartDataTableIssueRow>>;
  issuesRemovedFromSprint: Array<Maybe<BurndownChartDataTableIssueRow>>;
  scopeChanges: Array<Maybe<BurndownChartDataTableScopeChangeRow>>;
};

export type BurndownChartDataTableIssueRow = {
  __typename?: 'BurndownChartDataTableIssueRow';
  assignee?: Maybe<User>;
  cardParent?: Maybe<CardParent>;
  cardStatus?: Maybe<CardStatus>;
  cardType?: Maybe<CardType>;
  estimate?: Maybe<Scalars['Float']>;
  issueKey: Scalars['String'];
  issueSummary: Scalars['String'];
};

export type BurndownChartDataTableScopeChangeRow = {
  __typename?: 'BurndownChartDataTableScopeChangeRow';
  cardParent?: Maybe<CardParent>;
  cardType?: Maybe<CardType>;
  sprintScopeChange: SprintScopeChangeData;
  timestamp: Scalars['DateTime'];
};

export type CardCoverMedia = {
  __typename?: 'CardCoverMedia';
  attachmentId?: Maybe<Scalars['Long']>;
  attachmentMediaApiId?: Maybe<Scalars['ID']>;
  clientId?: Maybe<Scalars['String']>;
  /** endpoint to retrieve the media from */
  endpointUrl?: Maybe<Scalars['String']>;
  /** true if this card has media, but it's explicity been hidden by the user */
  hiddenByUser: Scalars['Boolean'];
  token?: Maybe<Scalars['String']>;
};

export enum CardHierarchyLevelEnumType {
  BASE = 'BASE',
  CHILD = 'CHILD',
  PARENT = 'PARENT',
}

export type CardMediaConfig = {
  __typename?: 'CardMediaConfig';
  /** Whether or not to show card media on this board */
  enabled: Scalars['Boolean'];
};

export type CardParent = {
  __typename?: 'CardParent';
  /** Card type */
  cardType: CardType;
  /** Some info about its children */
  childrenInfo?: Maybe<SoftwareCardChildrenInfo>;
  /** The color for this card */
  color?: Maybe<Scalars['CardPaletteColor']>;
  /** The due date set on the issue parent */
  dueDate?: Maybe<Scalars['String']>;
  /** Card id */
  id: Scalars['ID'];
  /** Card key */
  key: Scalars['String'];
  /** The start date set on the issue parent */
  startDate?: Maybe<Scalars['String']>;
  /** Card status */
  status?: Maybe<CardStatus>;
  /** Card summary */
  summary: Scalars['String'];
};

export type CardParentCreateInput = {
  boardId: Scalars['ID'];
  newIssueParents: Array<NewCardParent>;
};

export type CardParentCreateOutput = MutationResponse & {
  __typename?: 'CardParentCreateOutput';
  clientMutationId?: Maybe<Scalars['ID']>;
  message: Scalars['String'];
  newCardParents?: Maybe<Array<Maybe<CardParent>>>;
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export type CardParentRankInput = {
  boardId: Scalars['ID'];
  issueParentIds: Array<Scalars['ID']>;
  rankAfterIssueParentId?: Maybe<Scalars['Long']>;
  rankBeforeIssueParentId?: Maybe<Scalars['Long']>;
};

export type CardPriority = {
  __typename?: 'CardPriority';
  iconUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type CardRank = {
  /** The card that is after this card */
  afterCardId?: Maybe<Scalars['ID']>;
  /** The card that is before this card */
  beforeCardId?: Maybe<Scalars['ID']>;
};

export type CardStatus = {
  __typename?: 'CardStatus';
  /**
   * Which status category this statue belongs to.  Values:  "undefined" | "new"
   * (ie todo) | "indeterminate" (aka "in progress") | "done"
   */
  category?: Maybe<Scalars['String']>;
  /** Card status id */
  id?: Maybe<Scalars['ID']>;
  /** Card status name */
  name?: Maybe<Scalars['String']>;
};

export type CardType = {
  __typename?: 'CardType';
  /** The type of hierarchy level that card type belongs to */
  hierarchyLevelType?: Maybe<Scalars['CardTypeHierarchyLevelType']>;
  /** URL to the icon to show for this card type */
  iconUrl?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  /** The configuration for creating cards with this type inline. */
  inlineCardCreate?: Maybe<InlineCardCreateConfig>;
  name?: Maybe<Scalars['String']>;
};

/**
 * Report pagination
 * -----------------
 */
export type CfdChartConnection = {
  __typename?: 'CFDChartConnection';
  edges: Array<Maybe<CfdChartEdge>>;
  pageInfo: PageInfo;
};

/**
 * Report data
 * -----------------
 */
export type CfdChartData = {
  __typename?: 'CFDChartData';
  changes: Array<Maybe<CfdIssueColumnChangeEntry>>;
  columnCounts: Array<Maybe<CfdColumnCount>>;
  timestamp: Scalars['DateTime'];
};

export type CfdChartEdge = {
  __typename?: 'CFDChartEdge';
  cursor: Scalars['String'];
  node: CfdChartData;
};

export type CfdColumn = {
  __typename?: 'CFDColumn';
  name: Scalars['String'];
};

export type CfdColumnCount = {
  __typename?: 'CFDColumnCount';
  columnIndex: Scalars['Int'];
  count: Scalars['Int'];
};

/**
 * Report filters
 * --------------
 */
export type CfdFilters = {
  __typename?: 'CFDFilters';
  columns: Array<Maybe<CfdColumn>>;
};

export type CfdIssueColumnChangeEntry = {
  __typename?: 'CFDIssueColumnChangeEntry';
  columnFrom?: Maybe<Scalars['Int']>;
  columnTo?: Maybe<Scalars['Int']>;
  key?: Maybe<Scalars['ID']>;
  point?: Maybe<TimeSeriesPoint>;
  statusTo?: Maybe<Scalars['ID']>;
  /** in ISO 8601 format */
  timestamp: Scalars['String'];
};

/** Children metadata for cards */
export type ChildCardsMetadata = {
  __typename?: 'ChildCardsMetadata';
  complete?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['Int']>;
};

/** Level of access to an Atlassian product that a cloud app can request */
export type CloudAppScope = {
  __typename?: 'CloudAppScope';
  /** Description of the level of access to an Atlassian product that an app can request */
  capability: Scalars['String'];
  /** Unique id of the scope */
  id: Scalars['ID'];
  /** Name of the scope */
  name: Scalars['String'];
};

export type CodeInJira = {
  __typename?: 'CodeInJira';
  /** Site specific configuration required to build the 'Code in Jira' page */
  siteConfiguration?: Maybe<CodeInJiraSiteConfiguration>;
  /** User specific configuration required to build the 'Code in Jira' page */
  userConfiguration?: Maybe<CodeInJiraUserConfiguration>;
};

export type CodeInJiraBitbucketWorkspace = {
  __typename?: 'CodeInJiraBitbucketWorkspace';
  /** Workspace name (eg. Fusion) */
  name?: Maybe<Scalars['String']>;
  /**
   * URL slug (eg. fusion). Used to differentiate multiple workspaces
   * to the user when the names are same
   */
  slug?: Maybe<Scalars['String']>;
  /** Unique ID of the Bitbucket workspace in UUID format */
  uuid: Scalars['ID'];
};

export type CodeInJiraSiteConfiguration = {
  __typename?: 'CodeInJiraSiteConfiguration';
  /**
   * A list of providers that are already connected to the site
   * Eg. Bitbucket, Github, Gitlab etc.
   */
  connectedVcsProviders?: Maybe<Array<Maybe<CodeInJiraVcsProvider>>>;
};

export type CodeInJiraUserConfiguration = {
  __typename?: 'CodeInJiraUserConfiguration';
  /**
   * A list of Bitbucket workspaces that the current user has admin access too
   * The user can connect Jira to one these Workspaces
   */
  ownedBitbucketWorkspaces?: Maybe<Array<Maybe<CodeInJiraBitbucketWorkspace>>>;
};

/**
 * A Version Control System object
 * Eg. Bitbucket, GitHub, GitLab
 */
export type CodeInJiraVcsProvider = {
  __typename?: 'CodeInJiraVcsProvider';
  baseUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  providerId?: Maybe<Scalars['String']>;
  providerNamespace?: Maybe<Scalars['String']>;
};

/** A column on the board */
export type Column = {
  __typename?: 'Column';
  /** The cards contained in the column */
  cards: Array<Maybe<SoftwareCard>>;
  /** The statuses mapped to this column */
  columnStatus: Array<ColumnStatus>;
  /** Column's id */
  id?: Maybe<Scalars['ID']>;
  /** Whether this column is the done column.  Each board has exactly one done column. */
  isDone: Scalars['Boolean'];
  /** Whether this column is the inital column.  Each board has exactly one initial column. */
  isInitial: Scalars['Boolean'];
  /** Number of cards allowed in this column before displaying a warning,  null if no limit */
  maxCardCount?: Maybe<Scalars['Int']>;
  /** Column's name */
  name?: Maybe<Scalars['String']>;
};

/** Represents a column inside a swimlane.  Each swimlane gets a ColumnInSwimlane for each column. */
export type ColumnInSwimlane = {
  __typename?: 'ColumnInSwimlane';
  /** The cards contained in this column in the given swimlane */
  cards: Array<Maybe<SoftwareCard>>;
  /** The details of the column */
  columnDetails?: Maybe<Column>;
};

/** Represents a column inside a swimlane.  Each swimlane gets a ColumnInSwimlane for each column. */
export type ColumnInSwimlaneCardsArgs = {
  cardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

/** A status associated with a column, along with its transitions */
export type ColumnStatus = {
  __typename?: 'ColumnStatus';
  /**
   * Possible card transitions with a certain card type into this status
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: SoftwareCardTypeTransitions` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  cardTypeTransitions?: Maybe<Array<SoftwareCardTypeTransition>>;
  /** The status */
  status: CardStatus;
  /** Possible transitions into this status */
  transitions: Array<SoftwareCardTransition>;
};

/** Accepts input for acknowledging an announcement. */
export type CompassAcknowledgeAnnouncementInput = {
  /** The ID of the announcement being acknowledged. */
  announcementId: Scalars['ID'];
  /** The ID of the component that is acknowledging the announcement. */
  componentId: Scalars['ID'];
};

/** The payload returned after acknowledging an announcement. */
export type CompassAcknowledgeAnnouncementPayload = Payload & {
  __typename?: 'CompassAcknowledgeAnnouncementPayload';
  /** The announcement acknowledgement. */
  acknowledgement?: Maybe<CompassAnnouncementAcknowledgement>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** An announcement communicates news or updates relating to a component. */
export type CompassAnnouncement = {
  __typename?: 'CompassAnnouncement';
  /** The list of acknowledgements that are required for this announcement. */
  acknowledgements?: Maybe<Array<CompassAnnouncementAcknowledgement>>;
  /**
   * The component that posted the announcement.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  component?: Maybe<CompassComponent>;
  /** The description of the announcement. */
  description?: Maybe<Scalars['String']>;
  /** The ID of the announcement. */
  id: Scalars['ID'];
  /** The date on which the updates in the announcement will take effect. */
  targetDate?: Maybe<Scalars['DateTime']>;
  /** The title of the announcement. */
  title?: Maybe<Scalars['String']>;
};

/** Tracks whether or not a component has acknowledged an announcement. */
export type CompassAnnouncementAcknowledgement = {
  __typename?: 'CompassAnnouncementAcknowledgement';
  /**
   * The component that needs to acknowledge.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  component?: Maybe<CompassComponent>;
  /** Whether the component has acknowledged the announcement or not. */
  hasAcknowledged?: Maybe<Scalars['Boolean']>;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApi = {
  __typename?: 'CompassCatalogMutationApi';
  /**
   * Acknowledges an announcement on behalf of a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  acknowledgeAnnouncement?: Maybe<CompassAcknowledgeAnnouncementPayload>;
  /**
   * Adds a collection of labels to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  addComponentLabels?: Maybe<AddCompassComponentLabelsPayload>;
  /**
   * Applies a scorecard to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  applyScorecardToComponent?: Maybe<ApplyCompassScorecardToComponentPayload>;
  /**
   * Attach a data manager to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  attachComponentDataManager?: Maybe<AttachCompassComponentDataManagerPayload>;
  /**
   * Attaches an event source to a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  attachEventSource?: Maybe<AttachEventSourcePayload>;
  /**
   * Creates an announcement for a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createAnnouncement?: Maybe<CompassCreateAnnouncementPayload>;
  /**
   * Creates a new component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createComponent?: Maybe<CreateCompassComponentPayload>;
  /**
   * Creates an external alias for a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createComponentExternalAlias?: Maybe<
    CreateCompassComponentExternalAliasPayload
  >;
  /**
   * Creates a link for a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createComponentLink?: Maybe<CreateCompassComponentLinkPayload>;
  /**
   * Creates a deployment event.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:event:compass__
   */
  createDeploymentEvent?: Maybe<CreateDeploymentEventsPayload>;
  /**
   * Creates an event source.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createEventSource?: Maybe<CreateEventSourcePayload>;
  /**
   * Creates a new relationship between two components.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createRelationship?: Maybe<CreateCompassRelationshipPayload>;
  /**
   * Creates a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  createScorecard?: Maybe<CreateCompassScorecardPayload>;
  /**
   * Adds criteria to a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  createScorecardCriterias?: Maybe<CreateCompassScorecardCriteriasPayload>;
  /**
   * Creates a starred relationship between a user and a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  createStarredComponent?: Maybe<CreateCompassStarredComponentPayload>;
  /**
   * Creates a checkin for a team.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createTeamCheckin?: Maybe<CompassCreateTeamCheckinPayload>;
  /**
   * Deletes an existing announcement from a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteAnnouncement?: Maybe<CompassDeleteAnnouncementPayload>;
  /**
   * Deletes an existing component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteComponent?: Maybe<DeleteCompassComponentPayload>;
  /**
   * Deletes an existing external alias from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteComponentExternalAlias?: Maybe<
    DeleteCompassComponentExternalAliasPayload
  >;
  /**
   * Deletes an existing link from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteComponentLink?: Maybe<DeleteCompassComponentLinkPayload>;
  /**
   * Deletes an event source.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deleteEventSource?: Maybe<DeleteEventSourcePayload>;
  /**
   * Deletes an existing relationship between two components.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteRelationship?: Maybe<DeleteCompassRelationshipPayload>;
  /**
   * Deletes a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  deleteScorecard?: Maybe<DeleteCompassScorecardPayload>;
  /**
   * Deletes criteria from a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  deleteScorecardCriterias?: Maybe<DeleteCompassScorecardCriteriasPayload>;
  /**
   * Deletes a starred relationship between a user and a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  deleteStarredComponent?: Maybe<DeleteCompassStarredComponentPayload>;
  /**
   * Deletes a checkin from a team.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deleteTeamCheckin?: Maybe<CompassDeleteTeamCheckinPayload>;
  /**
   * Detach a data manager from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  detachComponentDataManager?: Maybe<DetachCompassComponentDataManagerPayload>;
  /**
   * Detaches an event source from a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  detachEventSource?: Maybe<DetachEventSourcePayload>;
  /**
   * Removes a collection of existing labels from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  removeComponentLabels?: Maybe<RemoveCompassComponentLabelsPayload>;
  /**
   * Removes a scorecard from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  removeScorecardFromComponent?: Maybe<
    RemoveCompassScorecardFromComponentPayload
  >;
  /**
   * Clean external aliases and data managers pertaining to an externalSource
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  unlinkExternalSource?: Maybe<UnlinkExternalSourcePayload>;
  /**
   * Updates an announcement from a component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  updateAnnouncement?: Maybe<CompassUpdateAnnouncementPayload>;
  /**
   * Updates an existing component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  updateComponent?: Maybe<UpdateCompassComponentPayload>;
  /**
   * Update a data manager of a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  updateComponentDataManagerMetadata?: Maybe<
    UpdateCompassComponentDataManagerMetadataPayload
  >;
  /**
   * Updates a link from a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:component:compass__
   */
  updateComponentLink?: Maybe<UpdateCompassComponentLinkPayload>;
  /**
   * Updates a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  updateScorecard?: Maybe<UpdateCompassScorecardPayload>;
  /**
   * Updates criteria on a scorecard.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __write:scorecard:compass__
   */
  updateScorecardCriterias?: Maybe<UpdateCompassScorecardCriteriasPayload>;
  /**
   * Updates a checkin for a team.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updateTeamCheckin?: Maybe<CompassUpdateTeamCheckinPayload>;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiAcknowledgeAnnouncementArgs = {
  input: CompassAcknowledgeAnnouncementInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiAddComponentLabelsArgs = {
  input: AddCompassComponentLabelsInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiApplyScorecardToComponentArgs = {
  componentId: Scalars['ID'];
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiAttachComponentDataManagerArgs = {
  input: AttachCompassComponentDataManagerInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiAttachEventSourceArgs = {
  input: AttachEventSourceInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateAnnouncementArgs = {
  input: CompassCreateAnnouncementInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateComponentArgs = {
  cloudId: Scalars['ID'];
  input: CreateCompassComponentInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateComponentExternalAliasArgs = {
  input: CreateCompassComponentExternalAliasInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateComponentLinkArgs = {
  input: CreateCompassComponentLinkInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateDeploymentEventArgs = {
  input: CreateDeploymentEventInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateEventSourceArgs = {
  input: CreateEventSourceInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateRelationshipArgs = {
  input: CreateCompassRelationshipInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateScorecardArgs = {
  cloudId: Scalars['ID'];
  input: CreateCompassScorecardInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateScorecardCriteriasArgs = {
  input: CreateCompassScorecardCriteriasInput;
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateStarredComponentArgs = {
  cloudId: Scalars['ID'];
  input: CreateCompassStarredComponentInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiCreateTeamCheckinArgs = {
  input: CompassCreateTeamCheckinInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteAnnouncementArgs = {
  input: CompassDeleteAnnouncementInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteComponentArgs = {
  input: DeleteCompassComponentInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteComponentExternalAliasArgs = {
  input: DeleteCompassComponentExternalAliasInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteComponentLinkArgs = {
  input: DeleteCompassComponentLinkInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteEventSourceArgs = {
  input: DeleteEventSourceInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteRelationshipArgs = {
  input: DeleteCompassRelationshipInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteScorecardArgs = {
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteScorecardCriteriasArgs = {
  input: DeleteCompassScorecardCriteriasInput;
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteStarredComponentArgs = {
  cloudId: Scalars['ID'];
  input: DeleteCompassStarredComponentInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDeleteTeamCheckinArgs = {
  input: CompassDeleteTeamCheckinInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDetachComponentDataManagerArgs = {
  input: DetachCompassComponentDataManagerInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiDetachEventSourceArgs = {
  input: DetachEventSourceInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiRemoveComponentLabelsArgs = {
  input: RemoveCompassComponentLabelsInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiRemoveScorecardFromComponentArgs = {
  componentId: Scalars['ID'];
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUnlinkExternalSourceArgs = {
  input: UnlinkExternalSourceInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateAnnouncementArgs = {
  input: CompassUpdateAnnouncementInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateComponentArgs = {
  input: UpdateCompassComponentInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateComponentDataManagerMetadataArgs = {
  input: UpdateCompassComponentDataManagerMetadataInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateComponentLinkArgs = {
  input: UpdateCompassComponentLinkInput;
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateScorecardArgs = {
  input: UpdateCompassScorecardInput;
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateScorecardCriteriasArgs = {
  input: UpdateCompassScorecardCriteriasInput;
  scorecardId: Scalars['ID'];
};

/** The top level wrapper for the Compass Mutations API. */
export type CompassCatalogMutationApiUpdateTeamCheckinArgs = {
  input: CompassUpdateTeamCheckinInput;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApi = {
  __typename?: 'CompassCatalogQueryApi';
  /**
   * Retrieves a single component by its internal ID.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  component?: Maybe<CompassComponentResult>;
  /**
   * Retrieves a single component by its external alias.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentByExternalAlias?: Maybe<CompassComponentResult>;
  /** Retrieves field definitions by component type. */
  fieldDefinitionsByComponentType?: Maybe<CompassFieldDefinitionsResult>;
  /**
   * Retrieves a scorecard by its unique identifier (ID).
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecard?: Maybe<CompassScorecardResult>;
  /**
   * Retrieves available scorecards.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecards?: Maybe<CompassScorecardsQueryResult>;
  /**
   * Searches for all component labels within Compass.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  searchComponentLabels?: Maybe<CompassComponentLabelsQueryResult>;
  /**
   * Searches for Compass components.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  searchComponents?: Maybe<CompassComponentQueryResult>;
  /**
   * Retrieve all starred components based on the user id.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  starredComponents?: Maybe<CompassStarredComponentQueryResult>;
  /**
   * A collection of checkins posted by a team; sorted by most recent.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  teamCheckins?: Maybe<Array<CompassTeamCheckin>>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiComponentArgs = {
  id: Scalars['ID'];
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiComponentByExternalAliasArgs = {
  cloudId: Scalars['ID'];
  externalID: Scalars['ID'];
  externalSource?: Maybe<Scalars['ID']>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiFieldDefinitionsByComponentTypeArgs = {
  cloudId: Scalars['ID'];
  input: CompassComponentType;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiScorecardArgs = {
  id: Scalars['ID'];
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiScorecardsArgs = {
  cloudId: Scalars['ID'];
  query?: Maybe<CompassScorecardsQuery>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiSearchComponentLabelsArgs = {
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentLabelsQuery>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiSearchComponentsArgs = {
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentQuery>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiStarredComponentsArgs = {
  cloudId: Scalars['ID'];
  query?: Maybe<CompassStarredComponentQuery>;
};

/** Top level wrapper for Compass Query API */
export type CompassCatalogQueryApiTeamCheckinsArgs = {
  input: CompassTeamCheckinsInput;
};

/** Metadata about who created or updated the object and when. */
export type CompassChangeMetadata = {
  __typename?: 'CompassChangeMetadata';
  /** The date and time when the object was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** The user who created the object. */
  createdBy?: Maybe<User>;
  /** The date and time when the object was last updated. */
  lastUserModificationAt?: Maybe<Scalars['DateTime']>;
  /** The user who last updated the object. */
  lastUserModificationBy?: Maybe<User>;
};

/** A component represents a software development artifact tracked in Compass. */
export type CompassComponent = Node & {
  __typename?: 'CompassComponent';
  _isDeleted?: Maybe<Scalars['Boolean']>;
  _isOptimistic?: Maybe<Scalars['Boolean']>;
  /**
   * A collection of announcements posted by the component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  announcements?: Maybe<Array<CompassAnnouncement>>;
  /**
   * A collection of scorecards applicable to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  applicableScorecards?: Maybe<Array<CompassScorecard>>;
  /** Metadata about who created the component and when. */
  changeMetadata: CompassChangeMetadata;
  /** The external integration that manages data for this component. */
  dataManager?: Maybe<CompassComponentDataManager>;
  /** The description of the component. */
  description?: Maybe<Scalars['String']>;
  /**
   * The event sources associated to the component.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  eventSources?: Maybe<Array<EventSource>>;
  /**
   * The events associated to the component.
   * Note that the 'X-ExperimentalApi: compass-prototype' HTTP header below is
   * required in addition to the 'X-ExperimentalApi: compass-beta' HTTP header. Set
   * both the headers for this field.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-prototype` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:event:compass__
   */
  events?: Maybe<CompassEventsQueryResult>;
  /** A collection of aliases that represent the component in external systems. */
  externalAliases?: Maybe<Array<CompassExternalAlias>>;
  /** A collection of fields for storing data about the component. */
  fields?: Maybe<Array<CompassField>>;
  /** The unique identifier (ID) of the component. */
  id: Scalars['ID'];
  /** A collection of labels that provide additional contextual information about the component. */
  labels?: Maybe<Array<CompassComponentLabel>>;
  /** A collection of links to other entities on the internet. */
  links?: Maybe<Array<CompassLink>>;
  /** The name of the component. */
  name: Scalars['String'];
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: Maybe<Scalars['ID']>;
  /** A collection of relationships between the component and other entities in Compass. */
  relationships?: Maybe<CompassRelationshipConnectionResult>;
  /** Returns the calculated total score for a given scorecard applied to this component. */
  scorecardScore?: Maybe<CompassScorecardScore>;
  /**
   * A collection of scorecard scores applied to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecardScores?: Maybe<Array<CompassScorecardScore>>;
  /**
   * A collection of scorecards applied to a component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecards?: Maybe<Array<CompassScorecard>>;
  /** The type of component. */
  type: CompassComponentType;
};

/** A component represents a software development artifact tracked in Compass. */
export type CompassComponentEventsArgs = {
  query?: Maybe<CompassEventsQuery>;
};

/** A component represents a software development artifact tracked in Compass. */
export type CompassComponentRelationshipsArgs = {
  query?: Maybe<CompassRelationshipQuery>;
};

/** A component represents a software development artifact tracked in Compass. */
export type CompassComponentScorecardScoreArgs = {
  query?: Maybe<CompassComponentScorecardScoreQuery>;
};

/** An external integration that manages data for a particular component. */
export type CompassComponentDataManager = {
  __typename?: 'CompassComponentDataManager';
  /** The unique identifier (ID) of the ecosystem app acting as a component data manager. */
  ecosystemAppId: Scalars['ID'];
  /** An URL of the external source. */
  externalSourceURL?: Maybe<Scalars['URL']>;
  /** Details about the last sync event to this component. */
  lastSyncEvent?: Maybe<ComponentSyncEvent>;
};

/** A label provides additional contextual information about a component. */
export type CompassComponentLabel = {
  __typename?: 'CompassComponentLabel';
  /** The name of the label. */
  name?: Maybe<Scalars['String']>;
};

export type CompassComponentLabelsQueryResult =
  | CompassSearchComponentLabelsConnection
  | QueryError;

export type CompassComponentQueryResult =
  | CompassSearchComponentConnection
  | QueryError;

export type CompassComponentResult = CompassComponent | QueryError;

/** Scorecard score on a component for a scorecard. */
export type CompassComponentScorecardScoreQuery = {
  /** The unique identifier (ID) of the scorecard. */
  scorecardId: Scalars['ID'];
};

/** Identifies the type of component. */
export enum CompassComponentType {
  /** A standalone software artifact that is directly consumable by an end-user. */
  APPLICATION = 'APPLICATION',
  /** A standalone software artifact that provides some functionality for other software via embedding. */
  LIBRARY = 'LIBRARY',
  /** A software artifact that does not fit into the pre-defined categories. */
  OTHER = 'OTHER',
  /** A software artifact that provides some functionality for other software over the network. */
  SERVICE = 'SERVICE',
}

/** Accepts input for creating a component announcement. */
export type CompassCreateAnnouncementInput = {
  /** The ID of the component to create an announcement for. */
  componentId: Scalars['ID'];
  /** The description of the announcement. */
  description?: Maybe<Scalars['String']>;
  /** The date on which the changes in the announcement will take effect. */
  targetDate: Scalars['DateTime'];
  /** The title of the announcement. */
  title: Scalars['String'];
};

/** The payload returned after creating a component announcement. */
export type CompassCreateAnnouncementPayload = Payload & {
  __typename?: 'CompassCreateAnnouncementPayload';
  /** The created announcement. */
  createdAnnouncement?: Maybe<CompassAnnouncement>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for creating a checkin. */
export type CompassCreateTeamCheckinInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID'];
  /** The mood of the checkin. */
  mood: Scalars['Int'];
  /** The response to the question 1 of the team checkin. */
  response1?: Maybe<Scalars['String']>;
  /** The response to the question 2 of the team checkin. */
  response2?: Maybe<Scalars['String']>;
  /** The response to the question 3 of the team checkin. */
  response3?: Maybe<Scalars['String']>;
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID'];
};

/** The payload returned after creating a component announcement. */
export type CompassCreateTeamCheckinPayload = Payload & {
  __typename?: 'CompassCreateTeamCheckinPayload';
  /** Details of the created team checkin. */
  createdTeamCheckin?: Maybe<CompassTeamCheckin>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for deleting a component announcement. */
export type CompassDeleteAnnouncementInput = {
  /** The cloud ID of the site to delete an announcement from. */
  cloudId: Scalars['ID'];
  /** The ID of the announcement to delete. */
  id: Scalars['ID'];
};

/** The payload returned after deleting a component announcement. */
export type CompassDeleteAnnouncementPayload = Payload & {
  __typename?: 'CompassDeleteAnnouncementPayload';
  /** The ID of the announcement that was deleted. */
  deletedAnnouncementId?: Maybe<Scalars['ID']>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for deleting a team checkin. */
export type CompassDeleteTeamCheckinInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID'];
  /** The ID of the team checkin to delete. */
  id: Scalars['ID'];
};

/** The payload returned after deleting a team checkin. */
export type CompassDeleteTeamCheckinPayload = Payload & {
  __typename?: 'CompassDeleteTeamCheckinPayload';
  /** ID of the checkin that was deleted. */
  deletedTeamCheckinId?: Maybe<Scalars['ID']>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type CompassDeploymentEvent = CompassEvent & {
  __typename?: 'CompassDeploymentEvent';
  /** The sequence number for the deployment. */
  deploymentSequenceNumber?: Maybe<Scalars['Long']>;
  /** The description of the deployment event. */
  description?: Maybe<Scalars['String']>;
  /** The name of the deployment event. */
  displayName: Scalars['String'];
  /** The environment where the deployment event has occurred. */
  environment?: Maybe<CompassDeploymentEventEnvironment>;
  /** The type of the event. */
  eventType: CompassEventType;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime'];
  /** The deployment event pipeline. */
  pipeline?: Maybe<CompassDeploymentEventPipeline>;
  /** The state of the deployment. */
  state?: Maybe<CompassDeploymentEventState>;
  /** The sequence number specifying the order of updates of the deployment event. */
  updateSequenceNumber?: Maybe<Scalars['Long']>;
  /** The URL of the deployment event. */
  url?: Maybe<Scalars['URL']>;
};

export type CompassDeploymentEventEnvironment = {
  __typename?: 'CompassDeploymentEventEnvironment';
  /** The type of environment, where the component deployment event has occurred. */
  category?: Maybe<CompassDeploymentEventEnvironmentCategory>;
  /** The display name of the environment, where the component deployment event has occurred. */
  displayName?: Maybe<Scalars['String']>;
  /** The ID of the environment, where the deployment event has occurred. */
  environmentId?: Maybe<Scalars['String']>;
};

export enum CompassDeploymentEventEnvironmentCategory {
  DEVELOPMENT = 'DEVELOPMENT',
  PRODUCTION = 'PRODUCTION',
  STAGING = 'STAGING',
  TESTING = 'TESTING',
  UNMAPPED = 'UNMAPPED',
}

export type CompassDeploymentEventEnvironmentInput = {
  /** The type of environment, where the component deployment event has occurred. */
  category: CompassDeploymentEventEnvironmentCategory;
  /** The display name of the environment, where the component deployment event has occurred. */
  displayName: Scalars['String'];
  /** The ID of the environment, where the deployment event has occurred. */
  environmentId: Scalars['String'];
};

export type CompassDeploymentEventPipeline = {
  __typename?: 'CompassDeploymentEventPipeline';
  /** The name of the deployment event pipeline. */
  displayName?: Maybe<Scalars['String']>;
  /** The ID of the deployment event pipeline. */
  pipelineId?: Maybe<Scalars['String']>;
  /** The URL linking to the deployment event pipeline. */
  url?: Maybe<Scalars['String']>;
};

export type CompassDeploymentEventPipelineInput = {
  /** The name of the deployment event pipeline. */
  displayName: Scalars['String'];
  /** The ID of the deployment event pipeline. */
  pipelineId: Scalars['String'];
  /** The URL linking to the deployment event pipeline. */
  url: Scalars['String'];
};

/**  Compass Deployment Event */
export enum CompassDeploymentEventState {
  CANCELLED = 'CANCELLED',
  FAILED = 'FAILED',
  IN_PROGRESS = 'IN_PROGRESS',
  PENDING = 'PENDING',
  ROLLED_BACK = 'ROLLED_BACK',
  SUCCESSFUL = 'SUCCESSFUL',
  UNKNOWN = 'UNKNOWN',
}

export type CompassEnumField = CompassField & {
  __typename?: 'CompassEnumField';
  /** The definition of the field. */
  definition?: Maybe<CompassFieldDefinition>;
  /** The value of the field. */
  value?: Maybe<Array<Scalars['String']>>;
};

export type CompassEnumFieldDefinitionOptions = {
  __typename?: 'CompassEnumFieldDefinitionOptions';
  /** The default option for field definition. If null, the field is not required. */
  default?: Maybe<Array<Scalars['String']>>;
  /** Possible values of the field definition. */
  values?: Maybe<Array<Scalars['String']>>;
};

export type CompassEnumFieldValueInput = {
  value?: Maybe<Array<Scalars['String']>>;
};

export type CompassEvent = {
  /** The description of the event. */
  description?: Maybe<Scalars['String']>;
  /** The name of the event. */
  displayName: Scalars['String'];
  /** The type of the event. */
  eventType: CompassEventType;
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime'];
  /** The URL of the event. */
  url?: Maybe<Scalars['URL']>;
};

export type CompassEventConnection = {
  __typename?: 'CompassEventConnection';
  edges?: Maybe<Array<Maybe<CompassEventEdge>>>;
  nodes?: Maybe<Array<CompassEvent>>;
  pageInfo: PageInfo;
};

export type CompassEventEdge = {
  __typename?: 'CompassEventEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassEvent>;
};

export type CompassEventsQuery = {
  /** Returns the events after the specified cursor position. */
  after?: Maybe<Scalars['String']>;
  /** The list of event types. */
  eventTypes?: Maybe<Array<CompassEventType>>;
  /** The first N number of events to return in the query. */
  first?: Maybe<Scalars['Int']>;
  /** Returns the events after that match the CompassEventTimeParameters. */
  timeParameters?: Maybe<CompassEventTimeParameters>;
};

export type CompassEventsQueryResult = CompassEventConnection | QueryError;

export type CompassEventTimeParameters = {
  /** The time to end querying for event data. */
  endAt?: Maybe<Scalars['DateTime']>;
  /** The time to begin querying for event data. */
  startFrom?: Maybe<Scalars['DateTime']>;
};

export enum CompassEventType {
  DEPLOYMENT = 'DEPLOYMENT',
}

/** An alias of the component in an external system. */
export type CompassExternalAlias = {
  __typename?: 'CompassExternalAlias';
  /** The ID of the component in an external system. */
  externalAliasId: Scalars['ID'];
  /** The external system hosting the component. */
  externalSource?: Maybe<Scalars['ID']>;
};

export type CompassExternalAliasInput = {
  /** The ID of the component in the external source */
  externalId: Scalars['ID'];
  /** The external system hosting the component */
  externalSource?: Maybe<Scalars['ID']>;
};

/** A field represents data about a component. */
export type CompassField = {
  /** The definition of the field. */
  definition?: Maybe<CompassFieldDefinition>;
};

/** The schema of a field. */
export type CompassFieldDefinition = {
  __typename?: 'CompassFieldDefinition';
  /** The description of the field. */
  description: Scalars['String'];
  /** The unique identifier (ID) of the field definition. */
  id: Scalars['ID'];
  /** The name of the field. */
  name: Scalars['String'];
  /** The options for the field definition. */
  options: CompassFieldDefinitionOptions;
  /** The type of field. */
  type: CompassFieldType;
};

export type CompassFieldDefinitionOptions = CompassEnumFieldDefinitionOptions;

export type CompassFieldDefinitions = {
  __typename?: 'CompassFieldDefinitions';
  definitions: Array<CompassFieldDefinition>;
};

export type CompassFieldDefinitionsResult =
  | CompassFieldDefinitions
  | QueryError;

/** Specifies the type of value for a field. */
export enum CompassFieldType {
  DATE = 'DATE',
  ENUM = 'ENUM',
  NUMBER = 'NUMBER',
  TEXT = 'TEXT',
}

export type CompassFieldValueInput = {
  enum?: Maybe<CompassEnumFieldValueInput>;
};

/** The configuration for a scorecard criterion representing the presence of a description. */
export type CompassHasDescriptionScorecardCriteria = CompassScorecardCriteria & {
  __typename?: 'CompassHasDescriptionScorecardCriteria';
  id: Scalars['ID'];
  /** Returns the calculated score for a given component */
  scorecardCriteriaScore?: Maybe<CompassScorecardCriteriaScore>;
  weight: Scalars['Int'];
};

/** The configuration for a scorecard criterion representing the presence of a description. */
export type CompassHasDescriptionScorecardCriteriaScorecardCriteriaScoreArgs = {
  query?: Maybe<CompassScorecardCriteriaScoreQuery>;
};

/** The configuration for a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type CompassHasFieldScorecardCriteria = CompassScorecardCriteria & {
  __typename?: 'CompassHasFieldScorecardCriteria';
  /** The target of a relationship, for example, 'Owner' if 'Has Owner'. */
  fieldDefinition: CompassFieldDefinition;
  /** The ID of the scorecard criterion. */
  id: Scalars['ID'];
  /** Returns the calculated score for a component. */
  scorecardCriteriaScore?: Maybe<CompassScorecardCriteriaScore>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/** The configuration for a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type CompassHasFieldScorecardCriteriaScorecardCriteriaScoreArgs = {
  query?: Maybe<CompassScorecardCriteriaScoreQuery>;
};

/**
 * The configuration for a scorecard criterion representing the presence of a link,
 * for example, 'Has Repository', or 'Has Documentation'.
 */
export type CompassHasLinkScorecardCriteria = CompassScorecardCriteria & {
  __typename?: 'CompassHasLinkScorecardCriteria';
  /** The ID of the scorecard criterion. */
  id: Scalars['ID'];
  /** The type of link, for example 'Repository' if 'Has Repository'. */
  linkType: CompassLinkType;
  /** Returns the calculated score for a component. */
  scorecardCriteriaScore?: Maybe<CompassScorecardCriteriaScore>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/**
 * The configuration for a scorecard criterion representing the presence of a link,
 * for example, 'Has Repository', or 'Has Documentation'.
 */
export type CompassHasLinkScorecardCriteriaScorecardCriteriaScoreArgs = {
  query?: Maybe<CompassScorecardCriteriaScoreQuery>;
};

/** Configuration for a scorecard criteria representing the presence of an owner */
export type CompassHasOwnerScorecardCriteria = CompassScorecardCriteria & {
  __typename?: 'CompassHasOwnerScorecardCriteria';
  /** The ID of the scorecard criterion. */
  id: Scalars['ID'];
  /** Returns the calculated score for a component. */
  scorecardCriteriaScore?: Maybe<CompassScorecardCriteriaScore>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/** Configuration for a scorecard criteria representing the presence of an owner */
export type CompassHasOwnerScorecardCriteriaScorecardCriteriaScoreArgs = {
  query?: Maybe<CompassScorecardCriteriaScoreQuery>;
};

/** A link to an entity or resource on the internet. */
export type CompassLink = {
  __typename?: 'CompassLink';
  _isDeleted?: Maybe<Scalars['Boolean']>;
  /** The unique identifier (ID) of the link. */
  id: Scalars['ID'];
  /** An user-provided name of the link. */
  name?: Maybe<Scalars['String']>;
  /** The type of link. */
  type: CompassLinkType;
  /** An URL to the entity or resource on the internet. */
  url: Scalars['URL'];
};

/** The types used to identify the intent of the link. */
export enum CompassLinkType {
  /** Chat Channels for contacting the owners/support of the component */
  CHAT_CHANNEL = 'CHAT_CHANNEL',
  /** A link to the dashboard of the component. */
  DASHBOARD = 'DASHBOARD',
  /** A link to the documentation of the component. */
  DOCUMENT = 'DOCUMENT',
  /** A link to the on-call schedule of the component. */
  ON_CALL = 'ON_CALL',
  /** Other link for a Component. */
  OTHER_LINK = 'OTHER_LINK',
  /** A link to the Jira or third-party project of the component. */
  PROJECT = 'PROJECT',
  /** A link to the source code repository of the component. */
  REPOSITORY = 'REPOSITORY',
}

/** Field Filters. */
export type CompassQueryFieldFilter = {
  filter?: Maybe<CompassQueryFilter>;
  name: Scalars['String'];
};

export type CompassQueryFilter = {
  eq?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Maybe<Scalars['String']>>>;
  lt?: Maybe<Scalars['String']>;
  neq?: Maybe<Scalars['String']>;
};

export type CompassQuerySort = {
  name?: Maybe<Scalars['String']>;
  /**  name of field to sort results by */
  order?: Maybe<CompassQuerySortOrder>;
};

export enum CompassQuerySortOrder {
  ASC = 'ASC',
  DESC = 'DESC',
}

/** A relationship between two components. */
export type CompassRelationship = {
  __typename?: 'CompassRelationship';
  _isDeleted?: Maybe<Scalars['Boolean']>;
  changeMetadata?: Maybe<CompassChangeMetadata>;
  /**
   * The ending node of the relationship.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  endNode?: Maybe<CompassComponent>;
  /**
   * The starting node of the relationship.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  startNode?: Maybe<CompassComponent>;
  /** The type of relationship. */
  type: CompassRelationshipType;
};

export type CompassRelationshipConnection = {
  __typename?: 'CompassRelationshipConnection';
  edges?: Maybe<Array<CompassRelationshipEdge>>;
  nodes?: Maybe<Array<CompassRelationship>>;
  pageInfo: PageInfo;
};

export type CompassRelationshipConnectionResult =
  | CompassRelationshipConnection
  | QueryError;

/** Defines the possible relationship directions between components. */
export enum CompassRelationshipDirection {
  /** Going from the other component to this component. */
  INWARD = 'INWARD',
  /** Going from this component to the other component. */
  OUTWARD = 'OUTWARD',
}

export type CompassRelationshipEdge = {
  __typename?: 'CompassRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassRelationship>;
};

/** Accepts input for finding component relationships. */
export type CompassRelationshipQuery = {
  /** The relationships to be returned after the specified cursor position. */
  after?: Maybe<Scalars['String']>;
  /** The direction of relationships to be searched for. */
  direction?: CompassRelationshipDirection;
  /** The filters for the relationships to be searched for. */
  filters?: Maybe<CompassRelationshipQueryFilters>;
  /** The number of relationships to return in the query. */
  first?: Maybe<Scalars['Int']>;
};

export type CompassRelationshipQueryFilters = {
  /** OR'd set of relationship types. */
  types?: Maybe<Array<CompassRelationshipType>>;
};

/** Defines the relationship types. A relationship must be one of these types. */
export enum CompassRelationshipType {
  DEPENDS_ON = 'DEPENDS_ON',
}

/** The configuration for a scorecard that can be used by components. */
export type CompassScorecard = Node & {
  __typename?: 'CompassScorecard';
  _isDeleted?: Maybe<Scalars['Boolean']>;
  _isOptimistic?: Maybe<Scalars['Boolean']>;
  /** Returns a list of components to which this scorecard is applied. */
  appliedToComponents?: Maybe<CompassScorecardAppliedToComponentsQueryResult>;
  /** Contains change metadata for the scorecard. */
  changeMetadata: CompassChangeMetadata;
  /** The type of component to which this scorecard is restricted. */
  componentType: CompassComponentType;
  /** The criteria used for calculating the score. */
  criterias?: Maybe<Array<CompassScorecardCriteria>>;
  /** The description of the scorecard. */
  description?: Maybe<Scalars['String']>;
  /** The unique identifier (ID) of the scorecard. */
  id: Scalars['ID'];
  /** Determines how the scorecard will be applied by default. */
  importance: CompassScorecardImportance;
  /** The name of the scorecard. */
  name: Scalars['String'];
  /** The unique identifier (ID) of the scorecard's owner. */
  owner?: Maybe<User>;
  /** Returns the calculated total score for a given component. */
  scorecardScore?: Maybe<CompassScorecardScore>;
};

/** The configuration for a scorecard that can be used by components. */
export type CompassScorecardAppliedToComponentsArgs = {
  query?: Maybe<CompassScorecardAppliedToComponentsQuery>;
};

/** The configuration for a scorecard that can be used by components. */
export type CompassScorecardScorecardScoreArgs = {
  query?: Maybe<CompassScorecardScoreQuery>;
};

export type CompassScorecardAppliedToComponentsConnection = {
  __typename?: 'CompassScorecardAppliedToComponentsConnection';
  edges?: Maybe<Array<CompassScorecardAppliedToComponentsEdge>>;
  nodes?: Maybe<Array<CompassComponent>>;
  pageInfo: PageInfo;
};

export type CompassScorecardAppliedToComponentsEdge = {
  __typename?: 'CompassScorecardAppliedToComponentsEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassComponent>;
};

/** Accepts input to find components a scorecard is applied to and their scores */
export type CompassScorecardAppliedToComponentsQuery = {
  /** Returns the components after the specified cursor position. */
  after?: Maybe<Scalars['String']>;
  /** The first N number of components to return in the query. */
  first?: Maybe<Scalars['Int']>;
};

export type CompassScorecardAppliedToComponentsQueryResult =
  | CompassScorecardAppliedToComponentsConnection
  | QueryError;

export type CompassScorecardConnection = {
  __typename?: 'CompassScorecardConnection';
  edges?: Maybe<Array<CompassScorecardEdge>>;
  nodes?: Maybe<Array<CompassScorecard>>;
  pageInfo: PageInfo;
};

/** The configuration for a scorecard criterion that can be shared across components. */
export type CompassScorecardCriteria = {
  /** The ID of the scorecard criterion. */
  id: Scalars['ID'];
  /** Returns the calculated score for a component. */
  scorecardCriteriaScore?: Maybe<CompassScorecardCriteriaScore>;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/** The configuration for a scorecard criterion that can be shared across components. */
export type CompassScorecardCriteriaScorecardCriteriaScoreArgs = {
  query?: Maybe<CompassScorecardCriteriaScoreQuery>;
};

/** Contains the calculated score for each scorecard criteria that is associated with a specific component. */
export type CompassScorecardCriteriaScore = {
  __typename?: 'CompassScorecardCriteriaScore';
  /** The maximum score value for the criterion. The value is used in calculating the aggregate score as a percentage. */
  maxScore: Scalars['Int'];
  /** The calculated score value for the criterion. */
  score: Scalars['Int'];
  /** The associated scorecard criterion. */
  scorecardCriteria: CompassScorecardCriteria;
};

export type CompassScorecardCriteriaScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID'];
};

export type CompassScorecardEdge = {
  __typename?: 'CompassScorecardEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassScorecard>;
};

/** The types used to identify the importance of the scorecard. */
export enum CompassScorecardImportance {
  /** Recommended to the component's owner when they select a scorecard to apply to their component. */
  RECOMMENDED = 'RECOMMENDED',
  /** Automatically applied to all components of the specified type or types and cannot be removed. */
  REQUIRED = 'REQUIRED',
  /** Custom scorecard, focused on specific use cases within teams or departments. */
  USER_DEFINED = 'USER_DEFINED',
}

export type CompassScorecardResult = CompassScorecard | QueryError;

/** Contains the calculated score for a component. Each component has one calculated score per scorecard. */
export type CompassScorecardScore = {
  __typename?: 'CompassScorecardScore';
  /** Returns the scores for individual criterion. */
  criteriaScores?: Maybe<Array<CompassScorecardCriteriaScore>>;
  /** The maximum possible total score value. */
  maxTotalScore: Scalars['Int'];
  /** The associated scorecard. */
  scorecard: CompassScorecard;
  /** The total calculated score value. */
  totalScore: Scalars['Int'];
};

/** Scorecard score on a scorecard for a component. */
export type CompassScorecardScoreQuery = {
  /** The unique identifier (ID) of the component. */
  componentId: Scalars['ID'];
};

/** Accepts input to find available scorecards. */
export type CompassScorecardsQuery = {
  /** Returns the scorecards after the specified cursor position. */
  after?: Maybe<Scalars['String']>;
  /** The first N number of scorecards to return in the query. */
  first?: Maybe<Scalars['Int']>;
};

export type CompassScorecardsQueryResult =
  | CompassScorecardConnection
  | QueryError;

export type CompassSearchComponentConnection = {
  __typename?: 'CompassSearchComponentConnection';
  edges?: Maybe<Array<CompassSearchComponentEdge>>;
  nodes?: Maybe<Array<CompassSearchComponentResult>>;
  pageInfo: PageInfo;
};

export type CompassSearchComponentEdge = {
  __typename?: 'CompassSearchComponentEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassSearchComponentResult>;
};

export type CompassSearchComponentLabelsConnection = {
  __typename?: 'CompassSearchComponentLabelsConnection';
  edges?: Maybe<Array<CompassSearchComponentLabelsEdge>>;
  nodes?: Maybe<Array<CompassComponentLabel>>;
  pageInfo: PageInfo;
};

export type CompassSearchComponentLabelsEdge = {
  __typename?: 'CompassSearchComponentLabelsEdge';
  cursor: Scalars['String'];
  node?: Maybe<CompassComponentLabel>;
};

/** The query to find component labels within Compass. */
export type CompassSearchComponentLabelsQuery = {
  /** Returns results after the specified cursor. */
  after?: Maybe<Scalars['String']>;
  /** Number of results to return in the query. The default is 25. */
  first?: Maybe<Scalars['Int']>;
  /** Text query to search against. */
  query?: Maybe<Scalars['String']>;
  /** Sorting parameters for the results to be searched for. The default is by ranked results. */
  sort?: Maybe<Array<Maybe<CompassQuerySort>>>;
};

/** The query to find components. */
export type CompassSearchComponentQuery = {
  /** Returns results after the specified cursor. */
  after?: Maybe<Scalars['String']>;
  /** Filters on component fields to be searched against. */
  fieldFilters?: Maybe<Array<Maybe<CompassQueryFieldFilter>>>;
  /** Number of results to return in the query. The default is 25. */
  first?: Maybe<Scalars['Int']>;
  /** Text query to search against. */
  query?: Maybe<Scalars['String']>;
  /** Sorting parameters for the results to be searched for. The default is by ranked results. */
  sort?: Maybe<Array<Maybe<CompassQuerySort>>>;
};

export type CompassSearchComponentResult = {
  __typename?: 'CompassSearchComponentResult';
  /**
   * The Compass component.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  component?: Maybe<CompassComponent>;
  /** Link to the component. Search UI can use this link to direct the user to the component page on click. */
  link: Scalars['URL'];
};

export type CompassStarredComponentConnection = {
  __typename?: 'CompassStarredComponentConnection';
  edges?: Maybe<Array<CompassStarredComponentEdge>>;
  nodes?: Maybe<Array<CompassComponent>>;
  pageInfo: PageInfo;
};

export type CompassStarredComponentEdge = {
  __typename?: 'CompassStarredComponentEdge';
  cursor: Scalars['String'];
  /**
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  node?: Maybe<CompassComponent>;
};

/** The query fields for finding starred components. */
export type CompassStarredComponentQuery = {
  /** Returns starred components after the specified cursor. */
  after?: Maybe<Scalars['String']>;
  /** First N number of starred components to return in the query. The default is 25. */
  first?: Maybe<Scalars['Int']>;
};

export type CompassStarredComponentQueryResult =
  | CompassStarredComponentConnection
  | QueryError;

/** A team checkin communicates checkin for a team. */
export type CompassTeamCheckin = {
  __typename?: 'CompassTeamCheckin';
  _isDeleted?: Maybe<Scalars['Boolean']>;
  _isOptimistic?: Maybe<Scalars['Boolean']>;
  /** Contains change metadata for the team checkin. */
  changeMetadata: CompassChangeMetadata;
  /** The ID of the team checkin. */
  id: Scalars['ID'];
  /** The mood of the team checkin. */
  mood?: Maybe<Scalars['Int']>;
  /** The response to the question 1 of the team checkin. */
  response1?: Maybe<Scalars['String']>;
  /** The response to the question 2 of the team checkin. */
  response2?: Maybe<Scalars['String']>;
  /** The response to the question 3 of the team checkin. */
  response3?: Maybe<Scalars['String']>;
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId?: Maybe<Scalars['ID']>;
};

/** Accepts input for deleting a team checkin. */
export type CompassTeamCheckinsInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID'];
  /** The unique identifier (ID) of the team that did the checkin. */
  teamId: Scalars['ID'];
};

/** Accepts input for updating a component announcement. */
export type CompassUpdateAnnouncementInput = {
  /** Whether the existing acknowledgements should be reset or not. */
  clearAcknowledgements?: Maybe<Scalars['Boolean']>;
  /** The cloud ID of the site to update an announcement on. */
  cloudId: Scalars['ID'];
  /** The description of the announcement. */
  description?: Maybe<Scalars['String']>;
  /** The ID of the announcement being updated. */
  id: Scalars['ID'];
  /** The date on which the changes in the announcement will take effect. */
  targetDate?: Maybe<Scalars['DateTime']>;
  /** The title of the announcement. */
  title?: Maybe<Scalars['String']>;
};

/** The payload returned after updating a component announcement. */
export type CompassUpdateAnnouncementPayload = Payload & {
  __typename?: 'CompassUpdateAnnouncementPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
  /** The updated announcement. */
  updatedAnnouncement?: Maybe<CompassAnnouncement>;
};

/** Accepts input for updating a team checkin. */
export type CompassUpdateTeamCheckinInput = {
  /** The cloud ID of the site to update a checkin on. */
  cloudId: Scalars['ID'];
  /** The ID of the team checkin being updated. */
  id: Scalars['ID'];
  /** The mood of the team checkin. */
  mood: Scalars['Int'];
  /** The response to the question 1 of the team checkin. */
  response1?: Maybe<Scalars['String']>;
  /** The response to the question 2 of the team checkin. */
  response2?: Maybe<Scalars['String']>;
  /** The response to the question 3 of the team checkin. */
  response3?: Maybe<Scalars['String']>;
};

/** The payload returned after updating a team checkin. */
export type CompassUpdateTeamCheckinPayload = Payload & {
  __typename?: 'CompassUpdateTeamCheckinPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
  /** Details of the updated checkin. */
  updatedTeamCheckin?: Maybe<CompassTeamCheckin>;
};

/** All Atlassian Cloud Products an app version is compatible with */
export type CompatibleAtlassianCloudProduct = CompatibleAtlassianProduct & {
  __typename?: 'CompatibleAtlassianCloudProduct';
  /** Atlassian product */
  atlassianProduct?: Maybe<MarketplaceSupportedAtlassianProduct>;
  /**
   * Unique id for this Atlassian product in Marketplace system
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.id`
   */
  id: Scalars['ID'];
  /**
   * Name of Atlassian product
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.name`
   */
  name: Scalars['String'];
};

/** All Atlassian DataCenter Products an app version is compatible with */
export type CompatibleAtlassianDataCenterProduct = CompatibleAtlassianProduct & {
  __typename?: 'CompatibleAtlassianDataCenterProduct';
  /** Atlassian product */
  atlassianProduct?: Maybe<MarketplaceSupportedAtlassianProduct>;
  /**
   * Unique id for this Atlassian product in Marketplace system
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.id`
   */
  id: Scalars['ID'];
  /** Maximum version number of Atlassian Product */
  maximumVersion: Scalars['String'];
  /** Minimum version number of Atlassian Product */
  minimumVersion: Scalars['String'];
  /**
   * Name of Atlassian product
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.name`
   */
  name: Scalars['String'];
};

/** All Atlassian Products an app version is compatible with */
export type CompatibleAtlassianProduct = {
  /** Atlassian product */
  atlassianProduct?: Maybe<MarketplaceSupportedAtlassianProduct>;
  /**
   * Unique id for this Atlassian product in Marketplace system
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.id`
   */
  id: Scalars['ID'];
  /**
   * Name of Atlassian product
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.name`
   */
  name: Scalars['String'];
};

/** All Atlassian Server Products an app version is compatible with */
export type CompatibleAtlassianServerProduct = CompatibleAtlassianProduct & {
  __typename?: 'CompatibleAtlassianServerProduct';
  /** Atlassian product */
  atlassianProduct?: Maybe<MarketplaceSupportedAtlassianProduct>;
  /**
   * Unique id for this Atlassian product in Marketplace system
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.id`
   */
  id: Scalars['ID'];
  /** Maximum version number of Atlassian Product */
  maximumVersion: Scalars['String'];
  /** Minimum version number of Atlassian Product */
  minimumVersion: Scalars['String'];
  /**
   * Name of Atlassian product
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `atlassianProduct.name`
   */
  name: Scalars['String'];
};

/** Complete sprint */
export type CompleteSprintInput = {
  boardId: Scalars['ID'];
  incompleteCardsDestination: SoftwareCardsDestination;
  sprintId: Scalars['ID'];
};

export type CompleteSprintResponse = MutationResponse & {
  __typename?: 'CompleteSprintResponse';
  boardScope?: Maybe<BoardScope>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Event data corresponding to a dataManager updating a component. */
export type ComponentSyncEvent = {
  __typename?: 'ComponentSyncEvent';
  /** Error messages explaining why the last sync event may have failed. */
  lastSyncErrors?: Maybe<Array<Scalars['String']>>;
  /** Status of the last sync event. */
  status: ComponentSyncEventStatus;
  /** Timestamp when the last sync event occurred. */
  time: Scalars['DateTime'];
};

/** Details on the result of the last component sync. */
export type ComponentSyncEventInput = {
  /** Error messages explaining why last sync event failed. */
  lastSyncErrors?: Maybe<Array<Scalars['String']>>;
  /** Status of the last sync event. */
  status: ComponentSyncEventStatus;
};

/** Status types of a data manager sync event. */
export enum ComponentSyncEventStatus {
  /** A Compass internal server issue prevented the sync from occurring. */
  SERVER_ERROR = 'SERVER_ERROR',
  /** The component updates were successfully synced to Compass. */
  SUCCESS = 'SUCCESS',
  /** An issue with the calling app or user input prevented the component from syncing to Compass. */
  USER_ERROR = 'USER_ERROR',
}

export type ConfigurePolarisRefreshInput = {
  autoRefreshTimeSeconds?: Maybe<Scalars['Int']>;
  clearError?: Maybe<Scalars['Boolean']>;
  /**  either an issue, an insight, or a snippet */
  disable?: Maybe<Scalars['Boolean']>;
  project: Scalars['ID'];
  setError?: Maybe<PolarisRefreshError>;
  subject?: Maybe<Scalars['ID']>;
  timeToLiveSeconds?: Maybe<Scalars['Int']>;
};

export type ConfigurePolarisRefreshPayload = Payload & {
  __typename?: 'ConfigurePolarisRefreshPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<Scalars['Int']>;
  success: Scalars['Boolean'];
};

/** Level of access to an Atlassian product that an app can request */
export type ConnectAppScope = {
  __typename?: 'ConnectAppScope';
  /** Name of Atlassian product to which this scope applies */
  atlassianProductName: Scalars['String'];
  /** Description of the level of access to an Atlassian product that an app can request */
  capability: Scalars['String'];
  /** Unique id of the scope */
  id: Scalars['ID'];
  /** Name of the scope */
  name: Scalars['String'];
  /**
   * Unique id of the scope (Deprecated field: Use field `id`)
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `id`
   */
  scopeId: Scalars['ID'];
};

export type ContainerEventObject = {
  __typename?: 'ContainerEventObject';
  attributes: Scalars['JSON'];
  id: Scalars['ID'];
  type: Scalars['String'];
};

export type ContextEventObject = {
  __typename?: 'ContextEventObject';
  attributes: Scalars['JSON'];
  id: Scalars['ID'];
  type: Scalars['String'];
};

export type CopyPolarisInsightsContainerInput = {
  /** The container ARI which contains insights */
  container?: Maybe<Scalars['ID']>;
  /** The project ARI which contains container */
  project: Scalars['ID'];
};

export type CopyPolarisInsightsInput = {
  /** Destination container to copy insgihts */
  destination: CopyPolarisInsightsContainerInput;
  /** Insight ARI's list that should be copied. Leave it empty to copy all insights from source to destination */
  insights?: Maybe<Array<Scalars['String']>>;
  /** Source container to copy insgihts */
  source: CopyPolarisInsightsContainerInput;
};

export type CopyPolarisInsightsPayload = Payload & {
  __typename?: 'CopyPolarisInsightsPayload';
  copiedInsights?: Maybe<Array<PolarisInsight>>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type CreateAppDeploymentInput = {
  appId: Scalars['ID'];
  artifactUrl: Scalars['URL'];
  environmentKey: Scalars['String'];
  hostedResourceUploadId?: Maybe<Scalars['ID']>;
};

/** Response from creating a deployment */
export type CreateAppDeploymentResponse = Payload & {
  __typename?: 'CreateAppDeploymentResponse';
  /** Details about the created deployment */
  deployment?: Maybe<AppDeployment>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type CreateAppDeploymentUrlInput = {
  appId: Scalars['ID'];
};

/** Response from creating an app deployment url */
export type CreateAppDeploymentUrlResponse = Payload & {
  __typename?: 'CreateAppDeploymentUrlResponse';
  deploymentUrl?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type CreateAppInput = {
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Response from creating an app */
export type CreateAppResponse = Payload & {
  __typename?: 'CreateAppResponse';
  /** Details about the created app */
  app?: Maybe<App>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** A response to a tunnel creation request */
export type CreateAppTunnelResponse = Payload & {
  __typename?: 'CreateAppTunnelResponse';
  errors?: Maybe<Array<MutationError>>;
  /**
   * The actual expiry time (in milliseconds) of the created forge tunnel. Once the
   * tunnel expires, Forge apps will display the deployed version even
   * if the local development server is still active.
   */
  expiry?: Maybe<Scalars['String']>;
  /**
   * The recommended keep-alive time (in milliseconds) by which the forge CLI (or
   * other clients) should re-establish the forge tunnel.
   * This is guaranteed to be less than the expiry of the forge tunnel.
   */
  keepAlive?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

/**
 * Establish tunnels for a specific environment of an app.
 *
 * This will redirect all function calls to the provided faas url. This URL must implement the same
 * invocation contract that is used elsewhere in Xen.
 *
 * This will also be used to redirect Custom UI product rendering to the custom ui urls. We separate
 * them by extension key.
 */
export type CreateAppTunnelsInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID'];
  /** The environment key */
  environmentKey: Scalars['String'];
  /** Should existing tunnels be overwritten */
  force?: Maybe<Scalars['Boolean']>;
  /** The tunnel definitions */
  tunnelDefinitions: TunnelDefinitionsInput;
};

/**
 * ## Mutations
 * ## Column Mutations ###
 */
export type CreateColumnInput = {
  boardId: Scalars['ID'];
  columnName: Scalars['String'];
};

export type CreateColumnOutput = MutationResponse & {
  __typename?: 'CreateColumnOutput';
  columns?: Maybe<Array<Column>>;
  message: Scalars['String'];
  newColumn?: Maybe<Column>;
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Accepts input to create an external alias of a component. */
export type CreateCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the alias. */
  componentId: Scalars['ID'];
  /** An alias of the component identifier in external sources. */
  externalAlias: CompassExternalAliasInput;
};

/** The payload returned from creating an external alias of a component. */
export type CreateCompassComponentExternalAliasPayload = Payload & {
  __typename?: 'CreateCompassComponentExternalAliasPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** Created Compass External Alias */
  createdCompassExternalAlias?: Maybe<CompassExternalAlias>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for creating a new component. */
export type CreateCompassComponentInput = {
  /** The description of the component. */
  description?: Maybe<Scalars['String']>;
  /** A collection of fields for storing data about the component. */
  fields?: Maybe<Array<CreateCompassFieldInput>>;
  /** The name of the component. */
  name: Scalars['String'];
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: Maybe<Scalars['ID']>;
  /** The type of the component. */
  type: CompassComponentType;
};

/** Accepts input to add links for a component. */
export type CreateCompassComponentLinkInput = {
  /** The ID of the component to add the link. */
  componentId: Scalars['ID'];
  /** The link to be added for the component. */
  link: CreateCompassLinkInput;
};

/** The payload returned after adding a link for a component. */
export type CreateCompassComponentLinkPayload = Payload & {
  __typename?: 'CreateCompassComponentLinkPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** The newly created component link. */
  createdComponentLink?: Maybe<CompassLink>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** The payload returned from creating a new component. */
export type CreateCompassComponentPayload = Payload & {
  __typename?: 'CreateCompassComponentPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input to create a field. */
export type CreateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

/** Accepts input to a create a scorecard criterion representing the presence of a description. */
export type CreateCompassHasDescriptionScorecardCriteriaInput = {
  weight: Scalars['Int'];
};

/** Accepts input to create a scorecard criterion representing the presence of a field, for example, 'Has Tier'. */
export type CreateCompassHasFieldScorecardCriteriaInput = {
  /** The ID for the field definition that is the target of a relationship. */
  fieldDefinitionId: Scalars['ID'];
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/**
 * Accepts input to create a scorecard criterion representing the presence of a
 * link, for example, 'Has Repository' or 'Has Documentation'.
 */
export type CreateCompassHasLinkScorecardCriteriaInput = {
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType: CompassLinkType;
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

export type CreateCompassHasOwnerScorecardCriteriaInput = {
  /** The weight that will be used in determining the aggregate score. */
  weight: Scalars['Int'];
};

/** Accepts details of the link to add to a component. */
export type CreateCompassLinkInput = {
  /** The name of the link. */
  name?: Maybe<Scalars['String']>;
  /** The type of the link. */
  type: CompassLinkType;
  /** The URL of the link. */
  url: Scalars['URL'];
};

/** Accepts input for creating a new relationship. */
export type CreateCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID'];
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID'];
  /** The type of the relationship. */
  type: CompassRelationshipType;
};

/** The payload returned from creating a new relationship. */
export type CreateCompassRelationshipPayload = Payload & {
  __typename?: 'CreateCompassRelationshipPayload';
  /** The newly created relationship between two components. */
  createdCompassRelationship?: Maybe<CompassRelationship>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input to create a scorecard criterion. */
export type CreateCompassScorecardCriteriaInput = {
  hasDescription?: Maybe<CreateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: Maybe<CreateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: Maybe<CreateCompassHasLinkScorecardCriteriaInput>;
  hasOwner?: Maybe<CreateCompassHasOwnerScorecardCriteriaInput>;
};

/** Accepts input to create a scorecard criterion. */
export type CreateCompassScorecardCriteriasInput = {
  criterias: Array<CreateCompassScorecardCriteriaInput>;
};

/** The payload returned from creating a scorecard criterion. */
export type CreateCompassScorecardCriteriasPayload = Payload & {
  __typename?: 'CreateCompassScorecardCriteriasPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /**
   * The scorecard that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecard?: Maybe<CompassScorecard>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/**  MUTATION INPUTS/PAYLOAD TYPES */
export type CreateCompassScorecardInput = {
  componentType: CompassComponentType;
  criterias?: Maybe<Array<CreateCompassScorecardCriteriaInput>>;
  description?: Maybe<Scalars['String']>;
  importance: CompassScorecardImportance;
  name: Scalars['String'];
  ownerId?: Maybe<Scalars['ID']>;
};

/** The payload returned from creating a scorecard criterion. */
export type CreateCompassScorecardPayload = Payload & {
  __typename?: 'CreateCompassScorecardPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /**
   * The scorecard that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecardDetails?: Maybe<CompassScorecard>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for creating a starred component. */
export type CreateCompassStarredComponentInput = {
  /** The ID of the component to be starred. */
  id: Scalars['ID'];
};

/** The payload returned from creating a starred component. */
export type CreateCompassStarredComponentPayload = Payload & {
  __typename?: 'CreateCompassStarredComponentPayload';
  /** A list of starred components. */
  components?: Maybe<CompassStarredComponentConnection>;
  /** A list of errors that occurred during mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the relationship is created successfully. */
  success: Scalars['Boolean'];
};

/** CustomFilters Mutation */
export type CreateCustomFilterInput = {
  boardId: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  jql: Scalars['String'];
  name: Scalars['String'];
};

export type CreateDeploymentEventInput = {
  /** The cloud ID of the site to create a deployment event for. */
  cloudId: Scalars['ID'];
  /** The sequence number for the deployment. */
  deploymentSequenceNumber: Scalars['Long'];
  /** The description of the deployment event. */
  description: Scalars['String'];
  /** The name of the deployment event. */
  displayName: Scalars['String'];
  /** The environment where the deployment event has occurred. */
  environment: CompassDeploymentEventEnvironmentInput;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID'];
  /** The last time this event was updated. */
  lastUpdated: Scalars['DateTime'];
  /** The deployment event pipeline. */
  pipeline: CompassDeploymentEventPipelineInput;
  /** The state of the deployment. */
  state: CompassDeploymentEventState;
  /** The sequence number specifying the order of updates of the deployment event. */
  updateSequenceNumber: Scalars['Long'];
  /** The URL of the deployment event. */
  url: Scalars['URL'];
};

export type CreateDeploymentEventsPayload = Payload & {
  __typename?: 'CreateDeploymentEventsPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** The request input for creating a relationship between a DevOps Service and an Jira Project. */
export type CreateDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The ID of the site of the service and the Jira project. */
  cloudId: Scalars['ID'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The Jira project ARI */
  jiraProjectId: Scalars['ID'];
  /** Optional properties of the relationship. */
  properties?: Maybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The type of the relationship. */
  relationshipType: DevOpsServiceAndJiraProjectRelationshipType;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID'];
};

/** #################### Mutation Payloads - Service and Jira Project Relationship ##################### */
export type CreateDevOpsServiceAndJiraProjectRelationshipPayload = Payload & {
  __typename?: 'CreateDevOpsServiceAndJiraProjectRelationshipPayload';
  /** The list of errors occurred during create relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The created relationship */
  serviceAndJiraProjectRelationship?: Maybe<
    DevOpsServiceAndJiraProjectRelationship
  >;
  /** The result of whether the relationship is created successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for creating a relationship between a DevOps Service and an Opsgenie Team */
export type CreateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /**
   * We can't infer this from the service ARI since the container association registry doesn't own the service ARI -
   * therefore we have to treat it as opaque.
   */
  cloudId: Scalars['ID'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /**
   * The ARI of the Opsgenie Team
   *
   * The Opsgenie team must exist on the same site as the service. If it doesn't, the create will fail
   * with a OPSGENIE_TEAM_ID_INVALID error.
   */
  opsgenieTeamId: Scalars['ID'];
  /** Optional properties of the relationship. */
  properties?: Maybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID'];
};

/** The response payload of creating a relationship between a DevOps Service and an Opsgenie Team */
export type CreateDevOpsServiceAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'CreateDevOpsServiceAndOpsgenieTeamRelationshipPayload';
  /** The list of errors occurred during update relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The created relationship */
  serviceAndOpsgenieTeamRelationship?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationship
  >;
  /** The result of whether the relationship is created successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for creating a relationship between a DevOps Service and a Repository */
export type CreateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The Bitbucket Repository ARI */
  bitbucketRepositoryId?: Maybe<Scalars['ID']>;
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** Optional properties of the relationship. */
  properties?: Maybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /** The ARI of the DevOps Service. */
  serviceId: Scalars['ID'];
  /** The Third Party Repository. It should be null when repositoryId is a Bitbucket Repository ARI */
  thirdPartyRepository?: Maybe<ThirdPartyRepositoryInput>;
};

/** #################### Mutation Payloads - DevOps Service and Repository Relationship ##################### */
export type CreateDevOpsServiceAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'CreateDevOpsServiceAndRepositoryRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  /** The created relationship */
  serviceAndRepositoryRelationship?: Maybe<
    DevOpsServiceAndRepositoryRelationship
  >;
  success: Scalars['Boolean'];
};

/** The request input for creating a new DevOps Service */
export type CreateDevOpsServiceInput = {
  cloudId: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  properties?: Maybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** Tier assigned to the DevOps Service */
  serviceTier: DevOpsServiceTierInput;
};

/** The response payload of creating a new DevOps Service */
export type CreateDevOpsServicePayload = Payload & {
  __typename?: 'CreateDevOpsServicePayload';
  /** The list of errors occurred during the DevOps Service creation */
  errors?: Maybe<Array<MutationError>>;
  /** The created DevOps Service */
  service?: Maybe<DevOpsService>;
  /** The result of whether a new DevOps Service is created successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for creating a new DevOps Service Relationship */
export type CreateDevOpsServiceRelationshipInput = {
  /** The description of the relationship */
  description?: Maybe<Scalars['String']>;
  /** The Service ARI of the end node of the relationship */
  endId: Scalars['ID'];
  /** The properties of the relationship */
  properties?: Maybe<Array<DevOpsServiceEntityPropertyInput>>;
  /** The Service ARI of the start node of the relationship */
  startId: Scalars['ID'];
  /** The inter-service relationship type */
  type: DevOpsServiceRelationshipType;
};

export type CreateDevOpsServiceRelationshipPayload = Payload & {
  __typename?: 'CreateDevOpsServiceRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  /** The created inter-service relationship */
  serviceRelationship?: Maybe<DevOpsServiceRelationship>;
  success: Scalars['Boolean'];
};

export type CreatedSprint = {
  __typename?: 'CreatedSprint';
  /** Can this sprint be update by the current user */
  canUpdateSprint?: Maybe<Scalars['Boolean']>;
  /** The number of days remaining */
  daysRemaining?: Maybe<Scalars['Int']>;
  /** The end date of the sprint, in ISO 8601 format */
  endDate?: Maybe<Scalars['DateTime']>;
  /** The ID of the sprint */
  id: Scalars['ID'];
  /** The sprint's name */
  name?: Maybe<Scalars['String']>;
  /** The state of the sprint, can be one of the following (FUTURE, ACTIVE, CLOSED) */
  sprintState?: Maybe<SprintState>;
  /** The start date of the sprint, in ISO 8601 format */
  startDate?: Maybe<Scalars['DateTime']>;
};

export type CreateEventSourceInput = {
  /** The type of the event to be created. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID'];
};

export type CreateEventSourcePayload = Payload & {
  __typename?: 'CreateEventSourcePayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** The source of event data. */
  eventSource?: Maybe<EventSource>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type CreateHostedResourceUploadUrlInput = {
  appId: Scalars['ID'];
  environmentKey: Scalars['String'];
  resourceKeys: Array<Scalars['String']>;
};

/** Response from creating a hosted resource upload url */
export type CreateHostedResourceUploadUrlPayload = Payload & {
  __typename?: 'CreateHostedResourceUploadUrlPayload';
  errors?: Maybe<Array<MutationError>>;
  preSignedUrls?: Maybe<Array<HostedResourcePreSignedUrl>>;
  success: Scalars['Boolean'];
  uploadId: Scalars['ID'];
};

/** #################### Mutation Input - Jira Project and Opsgenie Team Relationship ##################### */
export type CreateJiraProjectAndOpsgenieTeamRelationshipInput = {
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The ARI of the Jira project. */
  jiraProjectId: Scalars['ID'];
  /** The type of Jira. */
  jiraProjectType?: Maybe<DevOpsJiraProjectType>;
  /**
   * The Opsgenie team must exist on the same site as the service. If it doesn't, the create will fail
   * with a OPSGENIE_TEAM_ID_INVALID error.
   */
  opsgenieTeamId: Scalars['ID'];
  /** Optional properties of the relationship. */
  properties?: Maybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
};

/** #################### Mutation Payloads - Jira Project and Opsgenie Team Relationship ##################### */
export type CreateJiraProjectAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'CreateJiraProjectAndOpsgenieTeamRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  /** The created relationship */
  jiraProjectAndOpsgenieTeamRelationship?: Maybe<
    JiraProjectAndOpsgenieTeamRelationship
  >;
  success: Scalars['Boolean'];
};

/** The request input for creating a relationship between a Jira project and a repository */
export type CreateJiraProjectAndRepositoryRelationshipInput = {
  /**
   * The Bitbucket repository ARI.
   * This parameter should be null when the third party repository is not null, and vice versa.
   */
  bitbucketRepositoryId?: Maybe<Scalars['ID']>;
  /** An optional description of the relationship */
  description?: Maybe<Scalars['String']>;
  /** The project ARI */
  jiraProjectId: Scalars['ID'];
  /** Optional properties of the relationship */
  properties?: Maybe<Array<DevOpsContainerRelationshipEntityPropertyInput>>;
  /**
   * The third party repository details.
   * This parameter should be null when the Bitbucket repository ARI is not null, and vice versa.
   */
  thirdPartyRepository?: Maybe<ThirdPartyRepositoryInput>;
};

/** #################### Mutation Payloads - Jira Project and Repository Relationship ##################### */
export type CreateJiraProjectAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'CreateJiraProjectAndRepositoryRelationshipPayload';
  /** The list of errors occurred during relationship creation */
  errors?: Maybe<Array<MutationError>>;
  /** The created relationship */
  jiraProjectAndRepositoryRelationship?: Maybe<
    JiraProjectAndRepositoryRelationship
  >;
  /** The result of whether the relationship is created successfully or not */
  success: Scalars['Boolean'];
};

export type CreatePolarisAnonymousVisitorHashPayload = Payload & {
  __typename?: 'CreatePolarisAnonymousVisitorHashPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisAnonymousVisitorHash>;
  success: Scalars['Boolean'];
};

export type CreatePolarisCalculatedField = {
  formula: Scalars['JSON'];
  label: Scalars['String'];
  presentation?: Maybe<PolarisPresentationInput>;
  project: Scalars['ID'];
};

export type CreatePolarisCalculatedFieldPayload = Payload & {
  __typename?: 'CreatePolarisCalculatedFieldPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisIdeaField>;
  success: Scalars['Boolean'];
};

export type CreatePolarisCommentInput = {
  content?: Maybe<Scalars['JSON']>;
  kind?: Maybe<PolarisCommentKind>;
  subject?: Maybe<Scalars['ID']>;
};

export type CreatePolarisCommentPayload = Payload & {
  __typename?: 'CreatePolarisCommentPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisComment>;
  success: Scalars['Boolean'];
};

export type CreatePolarisDecorationInput = {
  field: Scalars['ID'];
  update: UpdatePolarisDecorationInput;
};

export type CreatePolarisDecorationPayload = Payload & {
  __typename?: 'CreatePolarisDecorationPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisDecoration>;
  success: Scalars['Boolean'];
};

export type CreatePolarisInsightFromPlayContributionInput = {
  /** The ARI of the play contribution */
  contribution: Scalars['ID'];
  /**
   * The ARI of the idea to add the insight to.  If null, then the insight
   * is added to the idea that the contribution is for.
   */
  subject?: Maybe<Scalars['ID']>;
};

export type CreatePolarisInsightInput = {
  /** The cloudID in which we are adding insight */
  cloudID: Scalars['String'];
  /**
   * DEPRECATED, DO NOT USE
   * Array of datas in JSON format. It will be validated with JSON schema of Polaris Insights Data format.
   */
  data?: Maybe<Array<Scalars['JSON']>>;
  /** Description in ADF format https://developer.atlassian.com/platform/atlassian-document-format/ */
  description?: Maybe<Scalars['JSON']>;
  /** The issueID in which we are adding insight, cloud be empty for adding insight on project level */
  issueID?: Maybe<Scalars['Int']>;
  /** The projectID in which we are adding insight */
  projectID: Scalars['Int'];
  /** Array of snippets */
  snippets?: Maybe<Array<CreatePolarisSnippetInput>>;
};

export type CreatePolarisInsightPayload = Payload & {
  __typename?: 'CreatePolarisInsightPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisInsight>;
  success: Scalars['Boolean'];
};

export type CreatePolarisPlayContribution = {
  /**  the issue (idea) to which this contribution is being made */
  amount?: Maybe<Scalars['Int']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: Maybe<Scalars['JSON']>;
  play: Scalars['ID'];
  /**  the play being contributed to */
  subject: Scalars['ID'];
};

export type CreatePolarisPlayContributionPayload = {
  __typename?: 'CreatePolarisPlayContributionPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisPlayContribution>;
  success: Scalars['Boolean'];
};

export type CreatePolarisPlayInput = {
  /**  the view from which the play is created */
  description?: Maybe<Scalars['JSON']>;
  fromView?: Maybe<Scalars['ID']>;
  kind: PolarisPlayKind;
  label: Scalars['String'];
  parameters?: Maybe<Scalars['JSON']>;
  project: Scalars['ID'];
  /**  the label for the play field, and the "short" name of the play */
  summary?: Maybe<Scalars['String']>;
};

export type CreatePolarisPlayPayload = {
  __typename?: 'CreatePolarisPlayPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisPlay>;
  success: Scalars['Boolean'];
};

export type CreatePolarisProjectInput = {
  key: Scalars['String'];
  name: Scalars['String'];
  tenant: Scalars['ID'];
};

export type CreatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: Maybe<Scalars['JSON']>;
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String'];
  /**
   * DEPRECATED, DO NOT USE
   * Snippet-level properties in JSON format.
   */
  properties?: Maybe<Scalars['JSON']>;
  /** Snippet url that is source of data */
  url?: Maybe<Scalars['String']>;
};

export type CreatePolarisStandardFieldInput = {
  fieldType: PolarisFieldType;
  ideaType: Scalars['ID'];
  name: Scalars['String'];
  presentation?: Maybe<PolarisPresentationInput>;
  project: Scalars['ID'];
};

/** #### Payload ##### */
export type CreatePolarisStandardFieldPayload = Payload & {
  __typename?: 'CreatePolarisStandardFieldPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisIdeaField>;
  success: Scalars['Boolean'];
};

export type CreatePolarisViewInput = {
  container: Scalars['ID'];
  /**  the type of viz to create */
  copyView?: Maybe<Scalars['ID']>;
  /**  view to copy configuration from */
  update?: Maybe<UpdatePolarisViewInput>;
  visualizationType?: Maybe<PolarisVisualizationType>;
};

export type CreatePolarisViewPayload = Payload & {
  __typename?: 'CreatePolarisViewPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisView>;
  success: Scalars['Boolean'];
};

export type CreatePolarisViewSetInput = {
  container: Scalars['ID'];
  name: Scalars['String'];
};

export type CreatePolarisViewSetPayload = Payload & {
  __typename?: 'CreatePolarisViewSetPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisViewSet>;
  success: Scalars['Boolean'];
};

/** Create sprint */
export type CreateSprintInput = {
  boardId: Scalars['ID'];
};

export type CreateSprintResponse = MutationResponse & {
  __typename?: 'CreateSprintResponse';
  message: Scalars['String'];
  sprint?: Maybe<CreatedSprint>;
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Response from creating an webtrigger url */
export type CreateWebTriggerUrlResponse = MutationResponse & {
  __typename?: 'CreateWebTriggerUrlResponse';
  /** Id of the webtrigger. Populated only if success is true. */
  id?: Maybe<Scalars['ID']>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
  /** Url of the webtrigger. Populated only if success is true. */
  url?: Maybe<Scalars['URL']>;
};

/** Node for querying the Cumulative Flow Diagram report */
export type CumulativeFlowDiagram = {
  __typename?: 'CumulativeFlowDiagram';
  chart: CfdChartConnection;
  filters: CfdFilters;
};

/** Node for querying the Cumulative Flow Diagram report */
export type CumulativeFlowDiagramChartArgs = {
  cursor?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type CurrentEstimation = {
  __typename?: 'CurrentEstimation';
  /** Custom field configured as the estimation type. Null when estimation feature is disabled. */
  customFieldId?: Maybe<Scalars['String']>;
  /** Name of the custom field. */
  name?: Maybe<Scalars['String']>;
};

/** Information about the current user. Different users will see different results. */
export type CurrentUser = {
  __typename?: 'CurrentUser';
  /** List of permissions the *user making the request* has for this board. */
  permissions: Array<Maybe<Scalars['SoftwareBoardPermission']>>;
};

/**
 * This represents a real person that has an free account within the Jira Service Desk product
 *
 * See the documentation on the `User` and `LocalizationContext` for more details
 */
export type CustomerUser = LocalizationContext &
  User & {
    __typename?: 'CustomerUser';
    accountId: Scalars['ID'];
    accountStatus: AccountStatus;
    email?: Maybe<Scalars['String']>;
    locale?: Maybe<Scalars['String']>;
    name: Scalars['String'];
    picture: Scalars['URL'];
    zoneinfo?: Maybe<Scalars['String']>;
  };

export type CustomFilter = {
  __typename?: 'CustomFilter';
  description?: Maybe<Scalars['String']>;
  filterQuery?: Maybe<FilterQuery>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type CustomFilterCreateOutput = MutationResponse & {
  __typename?: 'CustomFilterCreateOutput';
  customFilter?: Maybe<CustomFilter>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
  validationErrors: Array<CustomFiltersValidationError>;
};

export type CustomFiltersValidationError = {
  __typename?: 'CustomFiltersValidationError';
  errorMessage: Scalars['String'];
  fieldName: Scalars['String'];
};

export type CustomUiTunnelDefinition = {
  __typename?: 'CustomUITunnelDefinition';
  resourceKey?: Maybe<Scalars['String']>;
  tunnelUrl?: Maybe<Scalars['URL']>;
};

export type CustomUiTunnelDefinitionInput = {
  resourceKey?: Maybe<Scalars['String']>;
  tunnelUrl?: Maybe<Scalars['URL']>;
};

/** Time ranges of invocation date. */
export type DateSearchInput = {
  /**
   * The start time of the earliest invocation to include in the results.
   * If null, search results will only be limited by retention limits.
   *
   * RFC-3339 formatted timestamp.
   */
  earliestStart?: Maybe<Scalars['String']>;
  /**
   * The start time of the latest invocation to include in the results.
   * If null, will include most recent invocations.
   *
   * RFC-3339 formatted timestamp.
   */
  latestStart?: Maybe<Scalars['String']>;
};

export type DeleteAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The key of the environment variable to delete */
  key: Scalars['String'];
};

export type DeleteAppEnvironmentVariablePayload = Payload & {
  __typename?: 'DeleteAppEnvironmentVariablePayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeleteAppInput = {
  appId: Scalars['ID'];
};

/** Response from deleting an app */
export type DeleteAppResponse = Payload & {
  __typename?: 'DeleteAppResponse';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeleteAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID'];
  /** Specify whether the encrypted value should be deleted */
  encrypted?: Maybe<Scalars['Boolean']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID'];
};

/** Generic implementation of MutationResponse for responses that don't need any extra data */
export type DeleteAppStoredEntityPayload = Payload & {
  __typename?: 'DeleteAppStoredEntityPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeleteAppTunnelInput = {
  /** The app to setup a tunnel for */
  appId: Scalars['ID'];
  /** The environment key */
  environmentKey: Scalars['String'];
};

export type DeleteCardInput = {
  cardId: Scalars['ID'];
};

export type DeleteCardOutput = {
  __typename?: 'DeleteCardOutput';
  clientMutationId?: Maybe<Scalars['ID']>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export type DeleteColumnInput = {
  boardId: Scalars['ID'];
  columnId: Scalars['ID'];
};

export type DeleteColumnOutput = MutationResponse & {
  __typename?: 'DeleteColumnOutput';
  columns?: Maybe<Array<Column>>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Accepts input to delete an external alias. */
export type DeleteCompassComponentExternalAliasInput = {
  /** The ID of the component to which you add the external alias. */
  componentId: Scalars['ID'];
  /** The alias of the component identifier in external sources. */
  externalAlias: CompassExternalAliasInput;
};

/** The payload returned from deleting the external alias of a component. */
export type DeleteCompassComponentExternalAliasPayload = Payload & {
  __typename?: 'DeleteCompassComponentExternalAliasPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** Deleted Compass External Alias */
  deletedCompassExternalAlias?: Maybe<CompassExternalAlias>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for deleting an existing component. */
export type DeleteCompassComponentInput = {
  /** The ID of the component to be deleted. */
  id: Scalars['ID'];
};

/** Accepts input to delete a component link. */
export type DeleteCompassComponentLinkInput = {
  /** The ID for the component to delete a link. */
  componentId: Scalars['ID'];
  /** The component link to be deleted. */
  link: Scalars['ID'];
};

/** The payload retuned after deleting a component link. */
export type DeleteCompassComponentLinkPayload = Payload & {
  __typename?: 'DeleteCompassComponentLinkPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** The ID of the deleted component link. */
  deletedCompassLinkId?: Maybe<Scalars['ID']>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** The payload returned from deleting an existing component. */
export type DeleteCompassComponentPayload = Payload & {
  __typename?: 'DeleteCompassComponentPayload';
  _isOptimistic?: Maybe<Scalars['Boolean']>;
  /** The ID of the component that was deleted. */
  deletedComponentId?: Maybe<Scalars['ID']>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for deleting an existing relationship between two components. */
export type DeleteCompassRelationshipInput = {
  /** The unique identifier (ID) of the component at the ending node. */
  endNodeId: Scalars['ID'];
  /** The unique identifier (ID) of the component at the starting node. */
  startNodeId: Scalars['ID'];
  /** The type of the relationship. */
  type: CompassRelationshipType;
};

/** The payload returned from deleting an existing component. */
export type DeleteCompassRelationshipPayload = Payload & {
  __typename?: 'DeleteCompassRelationshipPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type DeleteCompassScorecardCriteriaInput = {
  /** ID of the scorecard criterion for deletion. The criteria is already applied to a scorecard. */
  id: Scalars['ID'];
};

export type DeleteCompassScorecardCriteriasInput = {
  criterias: Array<DeleteCompassScorecardCriteriaInput>;
};

/** The payload returned from deleting a scorecard criterion. */
export type DeleteCompassScorecardCriteriasPayload = Payload & {
  __typename?: 'DeleteCompassScorecardCriteriasPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /**
   * The scorecard that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecard?: Maybe<CompassScorecard>;
  /** Whether the mutation was successful or not */
  success: Scalars['Boolean'];
};

/** The payload returned from deleting a scorecard criterion. */
export type DeleteCompassScorecardPayload = Payload & {
  __typename?: 'DeleteCompassScorecardPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** The scorecard that was mutated. */
  scorecardId: Scalars['ID'];
  /** Whether the mutation was successful or not */
  success: Scalars['Boolean'];
};

/** Accepts input for deleting a starred component. */
export type DeleteCompassStarredComponentInput = {
  /** The ID of the component to be un-starred. */
  id: Scalars['ID'];
};

/** Payload returned from deleting a starred component. */
export type DeleteCompassStarredComponentPayload = Payload & {
  __typename?: 'DeleteCompassStarredComponentPayload';
  /** A list of starred components. */
  components?: Maybe<CompassStarredComponentConnection>;
  /** A list of errors that occurred during mutation */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the relationship is deleted successfully */
  success: Scalars['Boolean'];
};

export type DeleteCustomFilterInput = {
  boardId: Scalars['ID'];
  customFilterId: Scalars['String'];
};

/** The request input for deleting relationship properties */
export type DeleteDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the any of the relationship entity */
  id: Scalars['ID'];
  /** The properties with the given keys in the list will be removed from the relationship */
  keys: Array<Scalars['String']>;
};

/** The response payload of deleting DevOps Service Entity Properties */
export type DeleteDevOpsContainerRelationshipEntityPropertiesPayload = Payload & {
  __typename?: 'DeleteDevOpsContainerRelationshipEntityPropertiesPayload';
  /** The errors occurred during relationship properties delete */
  errors?: Maybe<Array<MutationError>>;
  /** The result of whether relationship properties have been successfully deleted or not */
  success: Scalars['Boolean'];
};

/** The request input for deleting a relationship between a DevOps Service and a Jira Project */
export type DeleteDevOpsServiceAndJiraProjectRelationshipInput = {
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID'];
};

export type DeleteDevOpsServiceAndJiraProjectRelationshipPayload = Payload & {
  __typename?: 'DeleteDevOpsServiceAndJiraProjectRelationshipPayload';
  /** The list of errors occurred during delete relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The result of whether the relationship is deleted successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for deleting a relationship between a DevOps Service and an Opsgenie Team */
export type DeleteDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  id: Scalars['ID'];
};

/** The response payload of deleting a relationship between a DevOps Service and an Opsgenie Team */
export type DeleteDevOpsServiceAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'DeleteDevOpsServiceAndOpsgenieTeamRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** The request input for deleting a relationship between a DevOps Service and a Repository */
export type DeleteDevOpsServiceAndRepositoryRelationshipInput = {
  /** The ARI of the relationship */
  id: Scalars['ID'];
};

export type DeleteDevOpsServiceAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'DeleteDevOpsServiceAndRepositoryRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** The request input for deleting DevOps Service Entity Properties */
export type DeleteDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID'];
  /** The properties with the given keys in the list will be removed from the DevOps Service */
  keys: Array<Scalars['String']>;
};

/** The response payload of deleting DevOps Service Entity Properties */
export type DeleteDevOpsServiceEntityPropertiesPayload = Payload & {
  __typename?: 'DeleteDevOpsServiceEntityPropertiesPayload';
  /** The errors occurred during DevOps Service Entity Properties delete */
  errors?: Maybe<Array<MutationError>>;
  /** The result of whether DevOps Service Entity Properties have been successfully deleted or not */
  success: Scalars['Boolean'];
};

/** The request input for deleting a DevOps Service */
export type DeleteDevOpsServiceInput = {
  id: Scalars['ID'];
};

/** The response payload of deleting a DevOps Service */
export type DeleteDevOpsServicePayload = Payload & {
  __typename?: 'DeleteDevOpsServicePayload';
  /** The list of errors occurred during DevOps Service deletion */
  errors?: Maybe<Array<MutationError>>;
  /** The result of whether the DevOps Service is deleted successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for deleting a DevOps Service Relationship */
export type DeleteDevOpsServiceRelationshipInput = {
  /** The ARI of the DevOps Service Relationship */
  id: Scalars['ID'];
};

export type DeleteDevOpsServiceRelationshipPayload = Payload & {
  __typename?: 'DeleteDevOpsServiceRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeleteEventSourceInput = {
  /** The type of event to be deleted. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID'];
};

export type DeleteEventSourcePayload = Payload & {
  __typename?: 'DeleteEventSourcePayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type DeleteJiraProjectAndOpsgenieTeamRelationshipInput = {
  id: Scalars['ID'];
};

export type DeleteJiraProjectAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'DeleteJiraProjectAndOpsgenieTeamRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** The request input for deleting a relationship between a Jira project and a repository */
export type DeleteJiraProjectAndRepositoryRelationshipInput = {
  /** The relationship ARI */
  id: Scalars['ID'];
};

export type DeleteJiraProjectAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'DeleteJiraProjectAndRepositoryRelationshipPayload';
  /** The list of errors occurred during relationship deletion */
  errors?: Maybe<Array<MutationError>>;
  /** The result of whether the relationship is deleted successfully or not */
  success: Scalars['Boolean'];
};

export type DeletePolarisAnonymousVisitorHashPayload = Payload & {
  __typename?: 'DeletePolarisAnonymousVisitorHashPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisDecorationInput = {
  backgroundColor?: Maybe<Scalars['Boolean']>;
  emoji?: Maybe<Scalars['Boolean']>;
  highlightContainer?: Maybe<Scalars['Boolean']>;
};

export type DeletePolarisDecorationPayload = Payload & {
  __typename?: 'DeletePolarisDecorationPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisFieldOptionInput = {
  field: Scalars['ID'];
  ideaType: Scalars['ID'];
  option: Scalars['ID'];
  project: Scalars['ID'];
};

export type DeletePolarisFieldOptionPayload = Payload & {
  __typename?: 'DeletePolarisFieldOptionPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisFieldPayload = Payload & {
  __typename?: 'DeletePolarisFieldPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisInsightPayload = Payload & {
  __typename?: 'DeletePolarisInsightPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisPlayContributionPayload = {
  __typename?: 'DeletePolarisPlayContributionPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisViewPayload = Payload & {
  __typename?: 'DeletePolarisViewPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type DeletePolarisViewSetPayload = Payload & {
  __typename?: 'DeletePolarisViewSetPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Delete sprint */
export type DeleteSprintInput = {
  boardId: Scalars['ID'];
  sprintId: Scalars['ID'];
};

export type DeleteUserGrantInput = {
  oauthClientId: Scalars['ID'];
};

export type DeleteUserGrantPayload = Payload & {
  __typename?: 'DeleteUserGrantPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Response from creating an webtrigger url */
export type DeleteWebTriggerUrlResponse = MutationResponse & {
  __typename?: 'DeleteWebTriggerUrlResponse';
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/**
 * This object models the Continuous Delivery (CD) Pipeline concept, an automated
 * process (usually comprised of multiple stages)
 * for getting software from version control right through to the production environment.
 */
export type DeploymentPipeline = {
  __typename?: 'DeploymentPipeline';
  /** The name of the pipeline to present to the user. */
  displayName?: Maybe<Scalars['String']>;
  /** A URL users can use to link to this deployment pipeline. */
  url?: Maybe<Scalars['String']>;
};

/** The state that a code deployment can be in (think of a deployment in Bitbucket Pipelines, CircleCI, etc). */
export enum DeploymentState {
  CANCELLED = 'CANCELLED',
  FAILED = 'FAILED',
  IN_PROGRESS = 'IN_PROGRESS',
  PENDING = 'PENDING',
  ROLLED_BACK = 'ROLLED_BACK',
  SUCCESSFUL = 'SUCCESSFUL',
  UNKNOWN = 'UNKNOWN',
}

/**
 * This object models a deployment in the Continuous Delivery (CD) Pipeline concept, an automated process (usually comprised of
 * multiple stages) for getting software from version control right through to the production environment.
 */
export type DeploymentSummary = Node & {
  __typename?: 'DeploymentSummary';
  /**
   * This is the identifier for the deployment.
   *
   * It must be unique for the specified pipeline and environment. It must be a monotonically
   * increasing number, as this is used to sequence the deployments.
   */
  deploymentSequenceNumber?: Maybe<Scalars['Long']>;
  /** A short description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** The human-readable name for the deployment. Will be shown in the UI. */
  displayName?: Maybe<Scalars['String']>;
  /** The environment that the deployment is present in. */
  environment?: Maybe<DevOpsEnvironment>;
  id: Scalars['ID'];
  /**
   * IDs of the issues that are included in the deployment.
   *
   * At least one of the commits in the deployment must be associated with an issue for it
   * to appear here (meaning the issue key is mentioned in the commit message).
   */
  issueIds?: Maybe<Array<Scalars['ID']>>;
  /** The last-updated timestamp to present to the user as a summary of the state of the deployment. */
  lastUpdated?: Maybe<Scalars['DateTime']>;
  /**
   * This object models the Continuous Delivery (CD) Pipeline concept, an automated process
   * (usually comprised of multiple stages) for getting software from version control right through
   * to the production environment.
   */
  pipeline?: Maybe<DeploymentPipeline>;
  /**
   * This is the DevOps provider for the deployment.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: DevOpsProvider` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  provider?: Maybe<DevOpsProvider>;
  /**
   * Services associated with the deployment.
   *
   * At least one of the commits in the deployment must be associated with a service ID for it
   * to appear here.
   */
  serviceAssociations?: Maybe<Array<Maybe<DevOpsService>>>;
  /** The state of the deployment. */
  state?: Maybe<DeploymentState>;
  /**
   * A number used to apply an order to the updates to the deployment, as identified by the
   * `deploymentSequenceNumber`, in the case of out-of-order receipt of update requests.
   *
   * It must be a monotonically increasing number. For example, epoch time could be one
   * way to generate the `updateSequenceNumber`.
   */
  updateSequenceNumber?: Maybe<Scalars['Long']>;
  /** A URL users can use to link to this deployment, in this environment. */
  url?: Maybe<Scalars['String']>;
};

/** Accepts input to detach a data manager from a component. */
export type DetachCompassComponentDataManagerInput = {
  /** The ID of the component to detach a data manager from. */
  componentId: Scalars['ID'];
};

/** The payload returned from detaching a data manager from a component. */
export type DetachCompassComponentDataManagerPayload = Payload & {
  __typename?: 'DetachCompassComponentDataManagerPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type DetachEventSourceInput = {
  /** The ID of the component to detach the event source from. */
  componentId: Scalars['ID'];
  /** The ID of the event source. */
  eventSourceId: Scalars['ID'];
};

export type DetachEventSourcePayload = Payload & {
  __typename?: 'DetachEventSourcePayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type DeveloperLogAccessResult = {
  __typename?: 'DeveloperLogAccessResult';
  /** Site ARI */
  contextId: Scalars['ID'];
  /** Indicates whether developer has access to logs */
  developerHasAccess: Scalars['Boolean'];
};

export type DevOpsAvatar = {
  __typename?: 'DevOpsAvatar';
  /** The description of the avatar. */
  description?: Maybe<Scalars['String']>;
  /** The URL of the avatar. */
  url?: Maybe<Scalars['URL']>;
};

export type DevOpsContainerRelationshipEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -.
   * * Be no greater than 80 characters long.
   * * Not begin with an underscore.
   */
  key: Scalars['String'];
  /**
   * * Can be no larger than 5KB for all properties for an entity.
   * * Can not be `null`.
   */
  value: Scalars['JSON'];
};

/**
 * An environment that a code change can be released to.
 *
 * The release may be via a code deployment or via a feature flag change.
 */
export type DevOpsEnvironment = {
  __typename?: 'DevOpsEnvironment';
  /** The type of the environment. */
  category?: Maybe<DevOpsEnvironmentCategory>;
  /** The name of the environment to present to the user. */
  displayName?: Maybe<Scalars['String']>;
};

/**
 * The types of environments that a code change can be released to.
 *
 * The release may be via a code deployment or via a feature flag change.
 */
export enum DevOpsEnvironmentCategory {
  DEVELOPMENT = 'DEVELOPMENT',
  PRODUCTION = 'PRODUCTION',
  STAGING = 'STAGING',
  TESTING = 'TESTING',
  UNMAPPED = 'UNMAPPED',
}

export enum DevOpsJiraProjectType {
  JIRA_CORE = 'JIRA_CORE',
  JIRA_SERVICEDESK = 'JIRA_SERVICEDESK',
  JIRA_SOFTWARE = 'JIRA_SOFTWARE',
}

export type DevOpsMetrics = {
  __typename?: 'DevOpsMetrics';
  cycleTime?: Maybe<DevOpsMetricsCycleTime>;
  deploymentFrequency?: Maybe<DevOpsMetricsDeploymentFrequency>;
  deploymentSize?: Maybe<DevOpsMetricsDeploymentSize>;
  perDeploymentMetrics?: Maybe<DevOpsMetricsPerDeploymentMetricsConnection>;
  perIssueMetrics?: Maybe<DevOpsMetricsPerIssueMetricsConnection>;
};

export type DevOpsMetricsCycleTimeArgs = {
  cycleTimePercentiles?: Maybe<Array<Scalars['Int']>>;
  filter: DevOpsMetricsFilterInput;
  isIncludeCycleTimeMean?: Maybe<Scalars['Boolean']>;
};

export type DevOpsMetricsDeploymentFrequencyArgs = {
  environmentCategory?: DevOpsEnvironmentCategory;
  filter: DevOpsMetricsFilterInput;
  rollupType?: DevOpsMetricsRollupType;
};

export type DevOpsMetricsDeploymentSizeArgs = {
  environmentCategory?: DevOpsEnvironmentCategory;
  filter: DevOpsMetricsFilterInput;
  rollupType?: DevOpsMetricsRollupType;
};

export type DevOpsMetricsPerDeploymentMetricsArgs = {
  after?: Maybe<Scalars['String']>;
  filter: DevOpsMetricsPerDeploymentMetricsFilter;
  first: Scalars['Int'];
};

export type DevOpsMetricsPerIssueMetricsArgs = {
  after?: Maybe<Scalars['String']>;
  filter: DevOpsMetricsPerIssueMetricsFilter;
  first: Scalars['Int'];
};

export type DevOpsMetricsCycleTime = {
  __typename?: 'DevOpsMetricsCycleTime';
  /** List of cycle time metrics for each requested roll up metric type. */
  cycleTimeMetrics?: Maybe<Array<Maybe<DevOpsMetricsCycleTimeMetrics>>>;
  /** Indicates whether user requesting metrics has permission to all contributing issues. */
  hasPermissionForAllContributingIssues?: Maybe<Scalars['Boolean']>;
  /** The development phase which the cycle time is calculated for. */
  phase?: Maybe<DevOpsMetricsCycleTimePhase>;
  /**
   * The size of time interval in which data points are rolled up in.
   * E.g. Count of data over 2 weeks with 1 day resolution means rollup is number of datapoints per day over 2 weeks.
   */
  resolution?: Maybe<DevOpsMetricsResolution>;
};

export type DevOpsMetricsCycleTimeData = {
  __typename?: 'DevOpsMetricsCycleTimeData';
  /**
   * Rolled up cycle time data (in seconds) between ('dateTime') and ('dateTime' +
   * 'resolution'). Roll up method specified by 'metric'.
   */
  cycleTimeSeconds?: Maybe<Scalars['Long']>;
  /** dataTime of data point. Each data point is separated by size of time resolution specified. */
  dateTime?: Maybe<Scalars['DateTime']>;
  /** Number of issues shipped between ('dateTime') and ('dateTime' + 'resolution'). */
  issuesShippedCount?: Maybe<Scalars['Int']>;
};

export type DevOpsMetricsCycleTimeMean = DevOpsMetricsCycleTimeMetrics & {
  __typename?: 'DevOpsMetricsCycleTimeMean';
  /** Mean of data points in 'data' array. Rounded to the nearest second. */
  aggregateData?: Maybe<Scalars['Long']>;
  data?: Maybe<Array<Maybe<DevOpsMetricsCycleTimeData>>>;
};

export type DevOpsMetricsCycleTimeMetrics = {
  /** Data aggregated according to the rollup type specified. Rounded to the nearest second. */
  aggregateData?: Maybe<Scalars['Long']>;
  /** The cycle time data points, computed using roll up of the type specified in 'metric'. Rolled up by specified resolution. */
  data?: Maybe<Array<Maybe<DevOpsMetricsCycleTimeData>>>;
};

export type DevOpsMetricsCycleTimePercentile = DevOpsMetricsCycleTimeMetrics & {
  __typename?: 'DevOpsMetricsCycleTimePercentile';
  /**
   * The percentile value across all cycle-times in the database between dateTimeFrom and dateTimeTo
   * (not across the datapoints in 'data' array). Rounded to the nearest second.
   */
  aggregateData?: Maybe<Scalars['Long']>;
  data?: Maybe<Array<Maybe<DevOpsMetricsCycleTimeData>>>;
  /** Percentile metric of returned values. Will be between 0 and 100. */
  percentile?: Maybe<Scalars['Int']>;
};

export enum DevOpsMetricsCycleTimePhase {
  /** Development phase from initial code commit to deployed code. */
  COMMIT_TO_DEPLOYMENT = 'COMMIT_TO_DEPLOYMENT',
  /** Development phase from initial code commit to opened pull request. */
  COMMIT_TO_PR = 'COMMIT_TO_PR',
}

export type DevOpsMetricsDeploymentFrequency = {
  __typename?: 'DevOpsMetricsDeploymentFrequency';
  /**
   * Deployment frequency aggregated according to the time resolution and rollup type specified.
   *
   * E.g. if the resolution were one week and the rollup type median, this value would be the median weekly
   * deployment count.
   */
  aggregateData?: Maybe<Scalars['Float']>;
  /** The deployment frequency data points rolled up by specified resolution. */
  data?: Maybe<Array<Maybe<DevOpsMetricsDeploymentFrequencyData>>>;
  /** Deployment environment type. */
  environmentType?: Maybe<DevOpsEnvironmentCategory>;
  /**
   * The size of time interval in which data points are rolled up in.
   * E.g. Count of data over 2 weeks with 1 day resolution means rollup is number of datapoints per day over 2 weeks.
   */
  resolution?: Maybe<DevOpsMetricsResolution>;
  /** Deployment state. Currently will only return for SUCCESSFUL, no State filter/input supported yet. */
  state?: Maybe<DeploymentState>;
};

/** #### Response ##### */
export type DevOpsMetricsDeploymentFrequencyData = {
  __typename?: 'DevOpsMetricsDeploymentFrequencyData';
  /** Number of deployments between ('dateTime') and ('dateTime' + 'resolution') */
  count?: Maybe<Scalars['Int']>;
  /** dataTime of data point. Each data point is separated by size of time resolution specified. */
  dateTime?: Maybe<Scalars['DateTime']>;
};

export type DevOpsMetricsDeploymentMetrics = {
  __typename?: 'DevOpsMetricsDeploymentMetrics';
  deployment?: Maybe<DeploymentSummary>;
  /**
   * Currently the only size metric supported is "number of issues per deployment".
   *
   * Note: The issues per deployment count will ignore Jira permissions, meaning
   * the user may not have permission to view all of the issues.
   * The list of `issueIds` contained in the `DeploymentSummary` will however respect Jira permissions.
   */
  deploymentSize?: Maybe<Scalars['Long']>;
};

export type DevOpsMetricsDeploymentMetricsEdge = {
  __typename?: 'DevOpsMetricsDeploymentMetricsEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsMetricsDeploymentMetrics>;
};

export type DevOpsMetricsDeploymentSize = {
  __typename?: 'DevOpsMetricsDeploymentSize';
  /**
   * Deployment size aggregated according to the rollup type specified.
   *
   * E.g. if the rollup type were median, this will be the median number of issues per deployment
   * over the whole time period.
   */
  aggregateData?: Maybe<Scalars['Float']>;
  /** The deployment size data points rolled up by specified resolution. */
  data?: Maybe<Array<Maybe<DevOpsMetricsDeploymentSizeData>>>;
};

export type DevOpsMetricsDeploymentSizeData = {
  __typename?: 'DevOpsMetricsDeploymentSizeData';
  /** dataTime of data point. Each data point is separated by size of time resolution specified. */
  dateTime?: Maybe<Scalars['DateTime']>;
  /** Aggregated number of issues per deployment between ('dateTime') and ('dateTime' + 'resolution') */
  deploymentSize?: Maybe<Scalars['Float']>;
};

/**
 * No results will be returned unless an association type is specified. Currently
 * only 'jiraProjectIds' association type is supported.
 */
export type DevOpsMetricsFilterInput = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: Maybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: Maybe<Array<Scalars['ID']>>;
  /**
   * The size of time interval in which to rollup data points in. Default is 1 day.
   * E.g. Count of data over 2 weeks with 1 day resolution means rollup is number of datapoints per day over 2 weeks.
   */
  resolution?: Maybe<DevOpsMetricsResolutionInput>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime'];
  /**
   * The Olson Timezone ID. E.g. 'Australia/Sydney'.
   * Specifies which timezone to aggregate data in so that daylight savings is
   * taken into account if it occurred between request time range.
   */
  timezoneId?: Maybe<Scalars['String']>;
};

export type DevOpsMetricsIssueFilters = {
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** Only issues of these types will be returned. */
  issueTypeIds?: Maybe<Array<Scalars['ID']>>;
};

export type DevOpsMetricsIssueMetrics = {
  __typename?: 'DevOpsMetricsIssueMetrics';
  commitsCount?: Maybe<Scalars['Int']>;
  /**  Issue ARI  */
  id: Scalars['ID'];
  /**  DateTime of the most recent successful deployment to production. */
  lastSuccessfulProductionDeployment?: Maybe<Scalars['DateTime']>;
  /**  Average of review times of all pull requests associated with the issueId. */
  meanReviewTimeSeconds?: Maybe<Scalars['Long']>;
  pullRequestsCount?: Maybe<Scalars['Int']>;
  /**  Development time from initial code commit to deployed code in production environment. */
  totalCycleTimeSeconds?: Maybe<Scalars['Long']>;
};

export type DevOpsMetricsIssueMetricsEdge = {
  __typename?: 'DevOpsMetricsIssueMetricsEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsMetricsIssueMetrics>;
};

export type DevOpsMetricsPerDeploymentMetricsConnection = {
  __typename?: 'DevOpsMetricsPerDeploymentMetricsConnection';
  edges?: Maybe<Array<Maybe<DevOpsMetricsDeploymentMetricsEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsMetricsDeploymentMetrics>>>;
  pageInfo: PageInfo;
};

/**
 * No results will be returned unless an association type is specified. Currently
 * only 'jiraProjectIds' association type is supported.
 */
export type DevOpsMetricsPerDeploymentMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime'];
  /** List of environment categories to filter for - only deployments in these categories will be returned. */
  environmentCategories?: Array<DevOpsEnvironmentCategory>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: Maybe<Array<Scalars['ID']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime'];
};

export type DevOpsMetricsPerIssueMetricsConnection = {
  __typename?: 'DevOpsMetricsPerIssueMetricsConnection';
  edges?: Maybe<Array<Maybe<DevOpsMetricsIssueMetricsEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsMetricsIssueMetrics>>>;
  pageInfo: PageInfo;
};

/**
 * No results will be returned unless an association type is specified. Currently
 * only 'jiraProjectIds' association type is supported.
 */
export type DevOpsMetricsPerIssueMetricsFilter = {
  /** The identifier that indicates which cloud instance this data is to be fetched for. */
  cloudId: Scalars['ID'];
  /** The end dateTime for overall time interval to return results for. The interval is exclusive of this value. */
  endAtExclusive: Scalars['DateTime'];
  /** Issue level filters. Currently, in order to apply this filter, jiraProjectIds must also be provided */
  issueFilters?: Maybe<DevOpsMetricsIssueFilters>;
  /** List of Jira projectIds in the given 'cloudId' to fetch metrics for. Max limit of 10. */
  jiraProjectIds?: Maybe<Array<Scalars['ID']>>;
  /** The start dateTime for overall time interval to return results for. The interval is inclusive of this value. */
  startFromInclusive: Scalars['DateTime'];
};

export type DevOpsMetricsResolution = {
  __typename?: 'DevOpsMetricsResolution';
  /** Unit for specified resolution value. */
  unit?: Maybe<DevOpsMetricsResolutionUnit>;
  /** Value for resolution specified. */
  value?: Maybe<Scalars['Int']>;
};

export type DevOpsMetricsResolutionInput = {
  /** Input unit for specified resolution value. */
  unit: DevOpsMetricsResolutionUnit;
  /** Input value for resolution specified. */
  value: Scalars['Int'];
};

/** Unit for specified resolution value. */
export enum DevOpsMetricsResolutionUnit {
  DAY = 'DAY',
  HOUR = 'HOUR',
  WEEK = 'WEEK',
}

export enum DevOpsMetricsRollupOption {
  MEAN = 'MEAN',
  PERCENTILE = 'PERCENTILE',
}

export type DevOpsMetricsRollupType = {
  /** Must only be specified if the rollup kind is PERCENTILE */
  percentile?: Maybe<Scalars['Int']>;
  type: DevOpsMetricsRollupOption;
};

/** A provider that a deployment has been done with. */
export type DevOpsProvider = {
  __typename?: 'DevOpsProvider';
  /** Links associated with the DevOpsProvider. Currently contains documentation, home and listDeploymentsTemplate URLs. */
  links?: Maybe<DevOpsProviderLinks>;
  /**
   * The logo to display for the Provider within the UI. This should be a 32x32 (or similar) favicon style image.
   * In the future this may be extended to support multi-resolution logos.
   */
  logo?: Maybe<Scalars['URL']>;
  /**
   * The display name to use for the Provider. May be rendered in the UI. Example: 'Github'.
   * In the future this may be extended to support an I18nString for localized names.
   */
  name?: Maybe<Scalars['String']>;
};

/** A type to group various URLs of Provider */
export type DevOpsProviderLinks = {
  __typename?: 'DevOpsProviderLinks';
  /** Documentation URL of the provider */
  documentation?: Maybe<Scalars['URL']>;
  /** Home URL of the provider */
  home?: Maybe<Scalars['URL']>;
  /** List deployments URL for the provider */
  listDeploymentsTemplate?: Maybe<Scalars['URL']>;
};

export enum DevOpsRelationshipCertainty {
  /** The relationship was created by a user. */
  EXPLICIT = 'EXPLICIT',
  /** The relationship was inferred by a system. */
  IMPLICIT = 'IMPLICIT',
}

export enum DevOpsRelationshipCertaintyFilter {
  /** Return all relationships. */
  ALL = 'ALL',
  /** Return only relationships created by a user. */
  EXPLICIT = 'EXPLICIT',
  /** Return only relationships inferred by a system. */
  IMPLICIT = 'IMPLICIT',
}

export enum DevOpsRepositoryHostingProviderFilter {
  ALL = 'ALL',
  BITBUCKET_CLOUD = 'BITBUCKET_CLOUD',
  THIRD_PARTY = 'THIRD_PARTY',
}

export type DevOpsService = Node & {
  __typename?: 'DevOpsService';
  /**
   * Bitbucket repositories that are available to be linked with via createDevOpsServiceAndRepositoryRelationship
   * If nameFilter is provided, only repositories with names containing this case-insensitive string will be returned.
   * For case of creating a new service (that has not been created), consumer can
   * use `bitbucketRepositoriesAvailableToLinkWithNewDevOpsService` query
   */
  bitbucketRepositoriesAvailableToLinkWith?: Maybe<
    BitbucketRepositoryIdConnection
  >;
  /** The cloud ID of the DevOps Service */
  cloudId: Scalars['String'];
  /** Relationship with a DevOps Service that contains this DevOps service */
  containedByDevOpsServiceRelationship?: Maybe<DevOpsServiceRelationship>;
  /** Relationships with DevOps Services that this DevOps Service contains */
  containsDevOpsServiceRelationships?: Maybe<
    DevOpsServiceRelationshipConnection
  >;
  /** The datetime when the DevOps Service was created */
  createdAt: Scalars['DateTime'];
  /** The user who created the DevOps Service */
  createdBy: Scalars['String'];
  /** Relationships with DevOps Services that are depend on this DevOps Service */
  dependedOnByDevOpsServiceRelationships?: Maybe<
    DevOpsServiceRelationshipConnection
  >;
  /** Relationships with DevOps Services that this DevOps Service depends on */
  dependsOnDevOpsServiceRelationships?: Maybe<
    DevOpsServiceRelationshipConnection
  >;
  /** The description of the DevOps Service */
  description?: Maybe<Scalars['String']>;
  /** The DevOps Service ARI */
  id: Scalars['ID'];
  /** Relationships with Jira projects associated to this DevOps Service. */
  jiraProjects?: Maybe<DevOpsServiceAndJiraProjectRelationshipConnection>;
  /** The most recent datetime when the DevOps Service was updated */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** The last user who updated the DevOps Service */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** The name of the DevOps Service */
  name: Scalars['String'];
  /** The relationship between this Service and an Opsgenie team */
  opsgenieTeamRelationship?: Maybe<DevOpsServiceAndOpsgenieTeamRelationship>;
  /** Opsgenie teams that are available to be linked with via createDevOpsServiceAndOpsgenieTeamRelationship */
  opsgenieTeamsAvailableToLinkWith?: Maybe<OpsgenieTeamConnection>;
  /** The organisation ID of the DevOps Service */
  organizationId: Scalars['String'];
  /** Look up JSON properties of the DevOps Service by keys */
  properties?: Maybe<Scalars['JSON']>;
  /** Relationships with VCS repositories associated to this DevOps Service */
  repositoryRelationships?: Maybe<
    DevOpsServiceAndRepositoryRelationshipConnection
  >;
  /**
   * The revision that must be provided when updating a DevOps Service to prevent
   * simultaneous updates from overwriting each other
   */
  revision: Scalars['ID'];
  /** Tier assigned to the DevOps Service */
  serviceTier?: Maybe<DevOpsServiceTier>;
  /** Services that are available to be linked with via createDevOpsServiceRelationship */
  servicesAvailableToLinkWith?: Maybe<DevOpsServiceConnection>;
};

export type DevOpsServiceBitbucketRepositoriesAvailableToLinkWithArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  nameFilter?: Maybe<Scalars['String']>;
};

export type DevOpsServiceContainsDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceDependedOnByDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceDependsOnDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceJiraProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndJiraProjectRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceOpsgenieTeamsAvailableToLinkWithArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type DevOpsServicePropertiesArgs = {
  keys: Array<Scalars['String']>;
};

export type DevOpsServiceRepositoryRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  sort?: Maybe<DevOpsServiceAndRepositoryRelationshipSort>;
};

export type DevOpsServiceServicesAvailableToLinkWithArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServicesFilterInput>;
  first?: Maybe<Scalars['Int']>;
};

/** A relationship between DevOps Service and Jira Project Team */
export type DevOpsServiceAndJiraProjectRelationship = Node & {
  __typename?: 'DevOpsServiceAndJiraProjectRelationship';
  /** When the relationship was created. */
  createdAt: Scalars['DateTime'];
  /** Who created the relationship. */
  createdBy: Scalars['String'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The details of DevOps Service in the relationship. */
  devOpsService?: Maybe<DevOpsService>;
  /** The ARI of this relationship. */
  id: Scalars['ID'];
  /** The Jira project related to the repository. */
  jiraProject?: Maybe<JiraProject>;
  /** When the relationship was updated last.  Only present for relationships that have been updated. */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** Who updated the relationship last. Only present for relationships that have been updated. */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** Look up JSON properties of the relationship by keys. */
  properties?: Maybe<Scalars['JSON']>;
  /** The type of the relationship. */
  relationshipType: DevOpsServiceAndJiraProjectRelationshipType;
  /**
   * The revision must be provided when updating a relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

/** A relationship between DevOps Service and Jira Project Team */
export type DevOpsServiceAndJiraProjectRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

export type DevOpsServiceAndJiraProjectRelationshipConnection = {
  __typename?: 'DevOpsServiceAndJiraProjectRelationshipConnection';
  edges?: Maybe<Array<Maybe<DevOpsServiceAndJiraProjectRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsServiceAndJiraProjectRelationship>>>;
  pageInfo: PageInfo;
};

export type DevOpsServiceAndJiraProjectRelationshipEdge = {
  __typename?: 'DevOpsServiceAndJiraProjectRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsServiceAndJiraProjectRelationship>;
};

export type DevOpsServiceAndJiraProjectRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: Maybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified relationship type */
  relationshipTypeIn?: Maybe<
    Array<DevOpsServiceAndJiraProjectRelationshipType>
  >;
};

export enum DevOpsServiceAndJiraProjectRelationshipType {
  /** A relationship created for the change management feature */
  CHANGE_MANAGEMENT = 'CHANGE_MANAGEMENT',
  /** A standard relationship */
  DEFAULT = 'DEFAULT',
}

/** A relationship between DevOps Service and Opsgenie Team */
export type DevOpsServiceAndOpsgenieTeamRelationship = Node & {
  __typename?: 'DevOpsServiceAndOpsgenieTeamRelationship';
  /** The datetime when the relationship was created */
  createdAt: Scalars['DateTime'];
  /** The user who created the relationship */
  createdBy: Scalars['String'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The details of DevOps Service in the relationship. */
  devOpsService?: Maybe<DevOpsService>;
  /** The ARI of this relationship. */
  id: Scalars['ID'];
  /** The most recent datetime when the relationship was updated */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** The last user who updated the relationship */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** The Opsgenie team details related to the service. */
  opsgenieTeam?: Maybe<OpsgenieTeam>;
  /**
   * The id (Opsgenie team ARI) of the Opsgenie team related to the service.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated use field opsgenieTeam to retrieve team details
   */
  opsgenieTeamId: Scalars['ID'];
  /** Look up JSON properties of the relationship by keys. */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * The revision must be provided when updating a relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

/** A relationship between DevOps Service and Opsgenie Team */
export type DevOpsServiceAndOpsgenieTeamRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

export type DevOpsServiceAndOpsgenieTeamRelationshipConnection = {
  __typename?: 'DevOpsServiceAndOpsgenieTeamRelationshipConnection';
  edges?: Maybe<Array<Maybe<DevOpsServiceAndOpsgenieTeamRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsServiceAndOpsgenieTeamRelationship>>>;
  pageInfo: PageInfo;
};

export type DevOpsServiceAndOpsgenieTeamRelationshipEdge = {
  __typename?: 'DevOpsServiceAndOpsgenieTeamRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsServiceAndOpsgenieTeamRelationship>;
};

/** A relationship between a DevOps Service and a Repository */
export type DevOpsServiceAndRepositoryRelationship = Node & {
  __typename?: 'DevOpsServiceAndRepositoryRelationship';
  /**
   * If the repository provider is Bitbucket, this will contain the Bitbucket repository details,
   * otherwise null.
   */
  bitbucketRepository?: Maybe<BitbucketRepository>;
  /** The time when the relationship was created */
  createdAt: Scalars['DateTime'];
  /** The user who created the relationship */
  createdBy: Scalars['String'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The details of DevOps Service in the relationship. */
  devOpsService?: Maybe<DevOpsService>;
  /** The ARI of this Relationship. */
  id: Scalars['ID'];
  /** The latest time when the relationship was updated */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** The latest user who updated the relationship */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** Look up JSON properties of the relationship by keys. */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * The revision must be provided when updating a relationship to prevent
   * multiple simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
  /** If the repository provider is a third party, this will contain the repository details, otherwise null. */
  thirdPartyRepository?: Maybe<DevOpsThirdPartyRepository>;
};

/** A relationship between a DevOps Service and a Repository */
export type DevOpsServiceAndRepositoryRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

export type DevOpsServiceAndRepositoryRelationshipConnection = {
  __typename?: 'DevOpsServiceAndRepositoryRelationshipConnection';
  edges?: Maybe<Array<Maybe<DevOpsServiceAndRepositoryRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsServiceAndRepositoryRelationship>>>;
  pageInfo: PageInfo;
};

export type DevOpsServiceAndRepositoryRelationshipEdge = {
  __typename?: 'DevOpsServiceAndRepositoryRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsServiceAndRepositoryRelationship>;
};

export type DevOpsServiceAndRepositoryRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: Maybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified repository hosting provider type */
  hostingProvider?: Maybe<DevOpsRepositoryHostingProviderFilter>;
  /**
   * Include only relationships with all of the specified property keys.
   * If this is omitted, no filtering by 'all property keys' is applied.
   */
  withAllPropertyKeys?: Maybe<Array<Scalars['String']>>;
};

export type DevOpsServiceAndRepositoryRelationshipSort = {
  /** The field to apply sorting on */
  by: DevOpsServiceAndRepositoryRelationshipSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

export enum DevOpsServiceAndRepositoryRelationshipSortBy {
  LAST_INFERRED_AT = 'LAST_INFERRED_AT',
}

/** The connection object for a collection of Services. */
export type DevOpsServiceConnection = {
  __typename?: 'DevOpsServiceConnection';
  edges?: Maybe<Array<Maybe<DevOpsServiceEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsService>>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceEdge = {
  __typename?: 'DevOpsServiceEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsService>;
};

/** The request input for DevOps Service Entity Property */
export type DevOpsServiceEntityPropertyInput = {
  /**
   * Keys must:
   * * Contain only the characters a-z, A-Z, 0-9, _ and -
   * * Be no greater than 80 characters long
   * * Not begin with an underscore
   */
  key: Scalars['String'];
  /**
   * * Can be no larger than 5KB for all properties for an entity
   * * Can not be `null`
   */
  value: Scalars['JSON'];
};

export type DevOpsServiceRelationship = Node & {
  __typename?: 'DevOpsServiceRelationship';
  /** The cloud ID of the DevOps Service Relationship */
  cloudId: Scalars['String'];
  /** The datetime when the DevOps Service Relationship was created */
  createdAt: Scalars['DateTime'];
  /** The user who created the DevOps Service Relationship */
  createdBy: Scalars['String'];
  /** The description of the DevOps Service Relationship */
  description?: Maybe<Scalars['String']>;
  /** The end service of the DevOps Service Relationship */
  endService?: Maybe<DevOpsService>;
  /** The DevOps Service Relationship ARI */
  id: Scalars['ID'];
  /** The most recent datetime when the DevOps Service Relationship was updated */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** The last user who updated the DevOps Service Relationship */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** The organization ID of the DevOps Service Relationship */
  organizationId: Scalars['String'];
  /** Look up JSON properties of the DevOps Service by keys */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * The revision that must be provided when updating a DevOps Service relationship to prevent
   * simultaneous updates from overwriting each other
   */
  revision: Scalars['ID'];
  /** The start service of the DevOps Service Relationship */
  startService?: Maybe<DevOpsService>;
  /** The inter-service relationship type of the DevOps Service Relationship */
  type: DevOpsServiceRelationshipType;
};

export type DevOpsServiceRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

/** The connection object for a collection of DevOps Service relationships. */
export type DevOpsServiceRelationshipConnection = {
  __typename?: 'DevOpsServiceRelationshipConnection';
  edges?: Maybe<Array<Maybe<DevOpsServiceRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<DevOpsServiceRelationship>>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

export type DevOpsServiceRelationshipEdge = {
  __typename?: 'DevOpsServiceRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<DevOpsServiceRelationship>;
};

/** #################### Enums ##################### */
export enum DevOpsServiceRelationshipType {
  CONTAINS = 'CONTAINS',
  DEPENDS_ON = 'DEPENDS_ON',
}

/** The filtering input for retrieving services. tierLevelIn must not be empty if provided. */
export type DevOpsServicesFilterInput = {
  /** Case insensitive string to filter service names with */
  nameContains?: Maybe<Scalars['String']>;
  /** Integer numbers to filter service tier levels with */
  tierLevelIn?: Maybe<Array<Scalars['Int']>>;
};

export type DevOpsServiceTier = {
  __typename?: 'DevOpsServiceTier';
  /** Description of the tier level and the standards that a DevOps Service at this tier should meet */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The level of the tier. Lower numbers are more important */
  level: Scalars['Int'];
  /** The name of the tier, if set by the user */
  name?: Maybe<Scalars['String']>;
  /** The translation key for the name. Only present when name is null */
  nameKey?: Maybe<Scalars['String']>;
};

export type DevOpsServiceTierInput = {
  level: Scalars['Int'];
};

/** #################### Supporting Types ##################### */
export type DevOpsThirdPartyRepository = {
  __typename?: 'DevOpsThirdPartyRepository';
  /** Avatar details for the third party repository. */
  avatar?: Maybe<DevOpsAvatar>;
  /** The ID of the third party repository. */
  id: Scalars['ID'];
  /** The name of the third party repository. */
  name?: Maybe<Scalars['String']>;
  /** The URL of the third party repository. */
  webUrl?: Maybe<Scalars['URL']>;
};

/** Dev status context */
export type DevStatus = {
  __typename?: 'DevStatus';
  activity: DevStatusActivity;
  count?: Maybe<Scalars['Int']>;
};

export enum DevStatusActivity {
  BRANCH_OPEN = 'BRANCH_OPEN',
  COMMIT = 'COMMIT',
  PR_DECLINED = 'PR_DECLINED',
  PR_MERGED = 'PR_MERGED',
  PR_OPEN = 'PR_OPEN',
}

export type DvcsBitbucketWorkspaceConnection = {
  __typename?: 'DvcsBitbucketWorkspaceConnection';
  edges?: Maybe<Array<Maybe<DvcsBitbucketWorkspaceEdge>>>;
  nodes?: Maybe<Array<Maybe<BitbucketWorkspace>>>;
  pageInfo: PageInfo;
};

export type DvcsBitbucketWorkspaceEdge = {
  __typename?: 'DvcsBitbucketWorkspaceEdge';
  cursor: Scalars['String'];
  /** The Bitbucket workspace. */
  node?: Maybe<BitbucketWorkspace>;
};

export type DvcsQuery = {
  __typename?: 'DvcsQuery';
  /**
   * Return the Bitbucket workspaces linked to this site.  User must
   * have access to Jira on this site.
   * *** This function will be deprecated in the near future. ***
   */
  bitbucketWorkspacesLinkedToSite?: Maybe<DvcsBitbucketWorkspaceConnection>;
};

export type DvcsQueryBitbucketWorkspacesLinkedToSiteArgs = {
  after?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
};

export type EcosystemMutation = {
  __typename?: 'EcosystemMutation';
  deleteUserGrant?: Maybe<DeleteUserGrantPayload>;
  /** Update an app environment and enrol to new scopes */
  updateAppHostServiceScopes?: Maybe<UpdateAppHostServiceScopesResponsePayload>;
};

export type EcosystemMutationDeleteUserGrantArgs = {
  input: DeleteUserGrantInput;
};

export type EcosystemMutationUpdateAppHostServiceScopesArgs = {
  input: UpdateAppHostServiceScopesInput;
};

export type EcosystemQuery = {
  __typename?: 'EcosystemQuery';
  userGrants?: Maybe<UserGrantConnection>;
};

export type EcosystemQueryUserGrantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Edit sprint */
export type EditSprintInput = {
  boardId: Scalars['ID'];
  endDate?: Maybe<Scalars['String']>;
  goal?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  sprintId: Scalars['ID'];
  startDate?: Maybe<Scalars['String']>;
};

/** View settings for epics on the roadmap */
export enum EpicView {
  /** All epics regardless of status */
  ALL = 'ALL',
  /** Epics with status complete */
  COMPLETED = 'COMPLETED',
  /** Epics with status incomplete */
  INCOMPLETE = 'INCOMPLETE',
}

/**
 * WARNING: This ErrorDetails is shared with "xen_lifecycle_service". This should not be,
 * but it was on oversight.
 */
export type ErrorDetails = {
  __typename?: 'ErrorDetails';
  /** Specific code used to make difference between errors to handle them differently */
  code: Scalars['String'];
  /** Addition error data */
  fields?: Maybe<Scalars['JSON']>;
  /** Copy of top-level message */
  message: Scalars['String'];
};

/** Estimate object which contains an estimate for a card when it exists */
export type Estimate = {
  __typename?: 'Estimate';
  originalEstimate?: Maybe<OriginalEstimate>;
  storyPoints?: Maybe<Scalars['Float']>;
};

export type EstimationConfig = {
  __typename?: 'EstimationConfig';
  /** All available estimation types that can be used in the project. */
  available: Array<AvailableEstimations>;
  /** Currently configured estimation. */
  current: CurrentEstimation;
};

export enum EventKnownAvIs {
  AVI_BITBUCKET_PR_CREATED = 'AVI_BITBUCKET_PR_CREATED',
  AVI_JIRA_ISSUE_CREATED = 'AVI_JIRA_ISSUE_CREATED',
  AVI_JIRA_ISSUE_UPDATED = 'AVI_JIRA_ISSUE_UPDATED',
}

export enum EventMatchingStrategies {
  BITBUCKET_BY_REPO = 'BITBUCKET_BY_REPO',
  JIRA_BY_ISSUE = 'JIRA_BY_ISSUE',
  /** This strategy will look ar Jira events and match on cloud id and project id */
  JIRA_BY_PROJECT = 'JIRA_BY_PROJECT',
}

/**  Compass Events */
export type EventSource = {
  __typename?: 'EventSource';
  /** The type of the event. */
  eventType: CompassEventType;
  /** The ID of the external event source. */
  externalEventSourceId: Scalars['ID'];
  /** The ID of the event source. */
  id: Scalars['ID'];
};

/** An arbitrary extension definition as defined by the Ecosystem */
export type Extension = {
  __typename?: 'Extension';
  appOwner?: Maybe<User>;
  appVersion?: Maybe<Scalars['String']>;
  consentUrl?: Maybe<Scalars['String']>;
  currentUserConsent?: Maybe<UserConsentExtension>;
  definitionId: Scalars['ID'];
  egress?: Maybe<Array<AppNetworkEgressPermissionExtension>>;
  environmentId: Scalars['ID'];
  environmentKey: Scalars['String'];
  environmentType: Scalars['String'];
  id: Scalars['ID'];
  installationId: Scalars['String'];
  key: Scalars['String'];
  license?: Maybe<AppInstallationLicense>;
  properties: Scalars['JSON'];
  requiresUserConsent?: Maybe<Scalars['Boolean']>;
  securityPolicies?: Maybe<Array<AppSecurityPoliciesPermissionExtension>>;
  type: Scalars['String'];
};

/** The context in which an extension exists */
export type ExtensionContext = {
  __typename?: 'ExtensionContext';
  appAuditLogs: AppAuditConnection;
  extensionsByType: Array<Extension>;
  id: Scalars['ID'];
  installations?: Maybe<AppInstallationConnection>;
};

/** The context in which an extension exists */
export type ExtensionContextAppAuditLogsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

/** The context in which an extension exists */
export type ExtensionContextExtensionsByTypeArgs = {
  type: Scalars['String'];
};

/** The context in which an extension exists */
export type ExtensionContextInstallationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filter?: Maybe<AppInstallationsFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Details about an extension.
 *
 * This information is used to look up the extension within CaaS so that the
 * correct function can be resolved.
 *
 * This will eventually be superseded by an Id.
 */
export type ExtensionDetailsInput = {
  /** The definition identifier as provided by CaaS */
  definitionId: Scalars['ID'];
  /** The extension key as provided by CaaS */
  extensionKey: Scalars['String'];
};

export type ExternalAuthCredentialsInput = {
  /** The oAuth Client Id */
  clientId?: Maybe<Scalars['ID']>;
  /** The shared secret */
  clientSecret?: Maybe<Scalars['String']>;
};

export type ExternalAuthProvider = {
  __typename?: 'ExternalAuthProvider';
  displayName: Scalars['String'];
  key: Scalars['String'];
  url: Scalars['URL'];
};

export type FilterQuery = {
  __typename?: 'FilterQuery';
  errors?: Maybe<Array<Maybe<Scalars['String']>>>;
  sanitisedJql: Scalars['String'];
};

export type FunctionDescription = {
  __typename?: 'FunctionDescription';
  key: Scalars['String'];
};

/** The data describing a function invocation. */
export type FunctionInvocationMetadata = {
  appVersion: Scalars['String'];
  /** Metadata about the function of the app that was called */
  function?: Maybe<FunctionDescription>;
  /** The invocation ID */
  id: Scalars['ID'];
  /** The context in which the app is installed */
  installationContext?: Maybe<AppInstallationContext>;
  /** Metadata about module type */
  moduleType?: Maybe<Scalars['String']>;
  /** Metadata about what caused the function to run */
  trigger?: Maybe<FunctionTrigger>;
};

export type FunctionTrigger = {
  __typename?: 'FunctionTrigger';
  key?: Maybe<Scalars['String']>;
  type?: Maybe<FunctionTriggerType>;
};

/** Which type of trigger */
export enum FunctionTriggerType {
  FRONTEND = 'FRONTEND',
  MANUAL = 'MANUAL',
  PRODUCT = 'PRODUCT',
  WEB = 'WEB',
}

/** Concrete version of MutationErrorExtension that does not include any extra fields */
export type GenericMutationErrorExtension = MutationErrorExtension & {
  __typename?: 'GenericMutationErrorExtension';
  errorType?: Maybe<Scalars['String']>;
  statusCode?: Maybe<Scalars['Int']>;
};

/** Generic implementation of MutationResponse for responses that don't need any extra data */
export type GenericMutationResponse = Payload & {
  __typename?: 'GenericMutationResponse';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Concrete version of QueryErrorExtension that does not include any extra fields */
export type GenericQueryErrorExtension = QueryErrorExtension & {
  __typename?: 'GenericQueryErrorExtension';
  errorType?: Maybe<Scalars['String']>;
  statusCode?: Maybe<Scalars['Int']>;
};

export enum GrantCheckProduct {
  COMPASS = 'COMPASS',
  CONFLUENCE = 'CONFLUENCE',
  JIRA = 'JIRA',
  JIRA_SERVICEDESK = 'JIRA_SERVICEDESK',
}

export type HostedResourcePreSignedUrl = {
  __typename?: 'HostedResourcePreSignedUrl';
  uploadFormData: Scalars['JSON'];
  uploadUrl: Scalars['String'];
};

export type Icon = {
  __typename?: 'Icon';
  url?: Maybe<Scalars['String']>;
};

export type InlineCardCreateConfig = {
  __typename?: 'InlineCardCreateConfig';
  /** Whether inline create is enabled */
  enabled: Scalars['Boolean'];
  /** Whether the global create should be used when creating */
  useGlobalCreate?: Maybe<Scalars['Boolean']>;
};

export type InlineColumnEditConfig = {
  __typename?: 'InlineColumnEditConfig';
  enabled: Scalars['Boolean'];
};

export type InstallationContextWithLogAccess = {
  __typename?: 'InstallationContextWithLogAccess';
  /** Installation context as an ARI */
  installationContext: Scalars['ID'];
  /** The tenant context for the cloud id. Only populated if context id is a valid cloud context. */
  tenantContext?: Maybe<TenantContext>;
};

/** The data returned from a function invocation */
export type InvocationResponsePayload = {
  __typename?: 'InvocationResponsePayload';
  /** The body of the function response */
  body: Scalars['JSON'];
};

/** Input payload for the invoke aux mutation */
export type InvokeAuxEffectsInput = {
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: Maybe<Scalars['String']>;
  /**
   * Information needed to look up an extension
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionDetails?: Maybe<ExtensionDetailsInput>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: Maybe<Scalars['ID']>;
  /** The payload to invoke an AUX Effect */
  payload: AuxEffectsInvocationPayload;
};

/** The response from an AUX effects invocation */
export type InvokeAuxEffectsResponse = MutationResponse &
  Payload & {
    __typename?: 'InvokeAuxEffectsResponse';
    errorDetails?: Maybe<ErrorDetails>;
    errors?: Maybe<Array<MutationError>>;
    message: Scalars['String'];
    result?: Maybe<AuxEffectsResult>;
    statusCode: Scalars['Int'];
    success: Scalars['Boolean'];
  };

/** Input payload for the invoke mutation */
export type InvokeExtensionInput = {
  /**
   * The list of applicable context Ids
   * Context Ids are used within the ecosystem platform to identify product
   * controlled areas into which apps can be installed. Host products should
   * determine how this list of contexts is constructed.
   *
   * *Important:* this should start with the most specific context as the
   * most specific extension will be the selected extension.
   */
  contextIds: Array<Scalars['ID']>;
  /** An identifier for an alternative entry point function to invoke */
  entryPoint?: Maybe<Scalars['String']>;
  /**
   * Information needed to look up an extension
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionDetails?: Maybe<ExtensionDetailsInput>;
  /**
   * An identifier for the extension to invoke
   *
   * Note: Either `extensionDetails` or `extensionId` must be provided
   */
  extensionId?: Maybe<Scalars['ID']>;
  /** The payload to send as part of the invocation */
  payload: Scalars['JSON'];
  /** An identifier for a schema to validate the response against */
  schema?: Maybe<Scalars['String']>;
};

export type InvokeExtensionPayloadErrorExtension = MutationErrorExtension & {
  __typename?: 'InvokeExtensionPayloadErrorExtension';
  errorType?: Maybe<Scalars['String']>;
  fields?: Maybe<InvokeExtensionPayloadErrorExtensionFields>;
  statusCode?: Maybe<Scalars['Int']>;
};

export type InvokeExtensionPayloadErrorExtensionFields = {
  __typename?: 'InvokeExtensionPayloadErrorExtensionFields';
  authInfoUrl?: Maybe<Scalars['String']>;
};

/** The response from a function invocation */
export type InvokeExtensionResponse = MutationResponse &
  Payload & {
    __typename?: 'InvokeExtensionResponse';
    errorDetails?: Maybe<ErrorDetails>;
    errors?: Maybe<Array<MutationError>>;
    /**
     * Details about the external auth for this service, if any exists.
     *
     * This is typically used for directing the user to a consent screen.
     */
    externalAuth?: Maybe<Array<Maybe<ExternalAuthProvider>>>;
    message: Scalars['String'];
    /** The invocation response */
    response?: Maybe<InvocationResponsePayload>;
    statusCode: Scalars['Int'];
    success: Scalars['Boolean'];
  };

export type InvokePolarisObjectInput = {
  /** Snippet action */
  action: Scalars['JSON'];
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: Maybe<Scalars['String']>;
  /** Snippet data */
  data: Scalars['JSON'];
  /** Issue ARI */
  issue: Scalars['ID'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String'];
  /** Project ARI */
  project: Scalars['ID'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String'];
};

export type InvokePolarisObjectPayload = Payload & {
  __typename?: 'InvokePolarisObjectPayload';
  errors?: Maybe<Array<MutationError>>;
  response?: Maybe<ResolvedPolarisObject>;
  success: Scalars['Boolean'];
};

/** Detailed information of a repository's branch */
export type IssueDevOpsBranchDetails = {
  __typename?: 'IssueDevOpsBranchDetails';
  createPullRequestUrl?: Maybe<Scalars['String']>;
  createReviewUrl?: Maybe<Scalars['String']>;
  lastCommit?: Maybe<IssueDevOpsHeadCommit>;
  name: Scalars['String'];
  pullRequests?: Maybe<Array<IssueDevOpsBranchPullRequestStatesSummary>>;
  reviews?: Maybe<Array<IssueDevOpsReview>>;
  url?: Maybe<Scalars['String']>;
};

/** Short description of a pull request associated with a branch */
export type IssueDevOpsBranchPullRequestStatesSummary = {
  __typename?: 'IssueDevOpsBranchPullRequestStatesSummary';
  /** Time of the last update in ISO 8601 format */
  lastUpdate?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  status?: Maybe<IssueDevOpsPullRequestStatus>;
  url?: Maybe<Scalars['String']>;
};

/** Detailed information about a build tied to a provider */
export type IssueDevOpsBuildDetail = {
  __typename?: 'IssueDevOpsBuildDetail';
  buildNumber?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  lastUpdated?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  references?: Maybe<Array<IssueDevOpsBuildReference>>;
  state?: Maybe<Scalars['String']>;
  testSummary?: Maybe<IssueDevOpsTestSummary>;
  url?: Maybe<Scalars['String']>;
};

/** A build pipeline provider */
export type IssueDevOpsBuildProvider = {
  __typename?: 'IssueDevOpsBuildProvider';
  avatarUrl?: Maybe<Scalars['String']>;
  builds?: Maybe<Array<IssueDevOpsBuildDetail>>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

/** Information that links a build to a version control system (commits, branches, etc.) */
export type IssueDevOpsBuildReference = {
  __typename?: 'IssueDevOpsBuildReference';
  name: Scalars['String'];
  uri?: Maybe<Scalars['String']>;
};

export enum IssueDevOpsCommitChangeType {
  ADDED = 'ADDED',
  COPIED = 'COPIED',
  DELETED = 'DELETED',
  MODIFY = 'MODIFY',
  MOVED = 'MOVED',
  UNKNOWN = 'UNKNOWN',
}

/** Detailed information of a commit in a repository */
export type IssueDevOpsCommitDetails = {
  __typename?: 'IssueDevOpsCommitDetails';
  author?: Maybe<IssueDevOpsPullRequestAuthor>;
  createReviewUrl?: Maybe<Scalars['String']>;
  displayId?: Maybe<Scalars['String']>;
  files?: Maybe<Array<IssueDevOpsCommitFile>>;
  id: Scalars['String'];
  isMerge?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  reviews?: Maybe<Array<IssueDevOpsReview>>;
  /** Time of the commit update in ISO 8601 format */
  timestamp?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['String']>;
};

/** Information of a file modified in a commit */
export type IssueDevOpsCommitFile = {
  __typename?: 'IssueDevOpsCommitFile';
  changeType?: Maybe<IssueDevOpsCommitChangeType>;
  linesAdded?: Maybe<Scalars['Int']>;
  linesRemoved?: Maybe<Scalars['Int']>;
  path: Scalars['String'];
  url?: Maybe<Scalars['String']>;
};

/** Detailed information of a deployment */
export type IssueDevOpsDeploymentDetails = {
  __typename?: 'IssueDevOpsDeploymentDetails';
  displayName?: Maybe<Scalars['String']>;
  environment?: Maybe<IssueDevOpsDeploymentEnvironment>;
  lastUpdated?: Maybe<Scalars['DateTime']>;
  pipelineDisplayName?: Maybe<Scalars['String']>;
  pipelineId: Scalars['String'];
  pipelineUrl?: Maybe<Scalars['String']>;
  state?: Maybe<IssueDevOpsDeploymentState>;
  url?: Maybe<Scalars['String']>;
};

export type IssueDevOpsDeploymentEnvironment = {
  __typename?: 'IssueDevOpsDeploymentEnvironment';
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  type?: Maybe<IssueDevOpsDeploymentEnvironmentType>;
};

export enum IssueDevOpsDeploymentEnvironmentType {
  DEVELOPMENT = 'DEVELOPMENT',
  PRODUCTION = 'PRODUCTION',
  STAGING = 'STAGING',
  TESTING = 'TESTING',
  UNMAPPED = 'UNMAPPED',
}

/**
 * This object witholds deployment providers essential information,
 * as well as its list of latest deployments per pipeline.
 * A provider without deployments related to the asked issueId will not be returned.
 */
export type IssueDevOpsDeploymentProviderDetails = {
  __typename?: 'IssueDevOpsDeploymentProviderDetails';
  /** A list of the latest deployments of each pipeline */
  deployments?: Maybe<Array<IssueDevOpsDeploymentDetails>>;
  homeUrl?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  logoUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export enum IssueDevOpsDeploymentState {
  CANCELLED = 'CANCELLED',
  FAILED = 'FAILED',
  IN_PROGRESS = 'IN_PROGRESS',
  PENDING = 'PENDING',
  ROLLED_BACK = 'ROLLED_BACK',
  SUCCESSFUL = 'SUCCESSFUL',
  UNKNOWN = 'UNKNOWN',
}

/** Aggregates all the instance types (bitbucket, stash, github) and its development information */
export type IssueDevOpsDetails = {
  __typename?: 'IssueDevOpsDetails';
  deploymentProviders?: Maybe<Array<IssueDevOpsDeploymentProviderDetails>>;
  embeddedMarketplace: IssueDevOpsEmbeddedMarketplace;
  featureFlagProviders?: Maybe<Array<IssueDevOpsFeatureFlagProvider>>;
  instanceTypes: Array<IssueDevOpsProviderInstance>;
  remoteLinksByType?: Maybe<IssueDevOpsRemoteLinksByType>;
};

/** Information related to the development process of an issue */
export type IssueDevOpsDevelopmentInformation = {
  __typename?: 'IssueDevOpsDevelopmentInformation';
  details?: Maybe<IssueDevOpsDetails>;
};

/** Information related to the development process of an issue */
export type IssueDevOpsDevelopmentInformationDetailsArgs = {
  instanceTypes?: Array<Scalars['String']>;
};

/**
 * A set of booleans that indicate if the embedded marketplace
 * should be shown if a user does not have installed providers
 */
export type IssueDevOpsEmbeddedMarketplace = {
  __typename?: 'IssueDevOpsEmbeddedMarketplace';
  shouldDisplayForBuilds: Scalars['Boolean'];
  shouldDisplayForDeployments: Scalars['Boolean'];
  shouldDisplayForFeatureFlags: Scalars['Boolean'];
};

export type IssueDevOpsFeatureFlag = {
  __typename?: 'IssueDevOpsFeatureFlag';
  details?: Maybe<Array<IssueDevOpsFeatureFlagDetails>>;
  displayName?: Maybe<Scalars['String']>;
  /** the identifier for the feature flag as provided */
  id: Scalars['String'];
  key?: Maybe<Scalars['String']>;
  /** Can be used to link to a provider record if required */
  providerId?: Maybe<Scalars['String']>;
  summary?: Maybe<IssueDevOpsFeatureFlagSummary>;
};

export type IssueDevOpsFeatureFlagDetails = {
  __typename?: 'IssueDevOpsFeatureFlagDetails';
  environment?: Maybe<IssueDevOpsFeatureFlagEnvironment>;
  lastUpdated?: Maybe<Scalars['String']>;
  status?: Maybe<IssueDevOpsFeatureFlagStatus>;
  url: Scalars['String'];
};

export type IssueDevOpsFeatureFlagEnvironment = {
  __typename?: 'IssueDevOpsFeatureFlagEnvironment';
  name: Scalars['String'];
  type?: Maybe<Scalars['String']>;
};

export type IssueDevOpsFeatureFlagProvider = {
  __typename?: 'IssueDevOpsFeatureFlagProvider';
  createFlagTemplateUrl?: Maybe<Scalars['String']>;
  featureFlags?: Maybe<Array<IssueDevOpsFeatureFlag>>;
  id: Scalars['String'];
  linkFlagTemplateUrl?: Maybe<Scalars['String']>;
};

export type IssueDevOpsFeatureFlagRollout = {
  __typename?: 'IssueDevOpsFeatureFlagRollout';
  percentage?: Maybe<Scalars['Float']>;
  rules?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
};

export type IssueDevOpsFeatureFlagStatus = {
  __typename?: 'IssueDevOpsFeatureFlagStatus';
  defaultValue?: Maybe<Scalars['String']>;
  enabled: Scalars['Boolean'];
  rollout?: Maybe<IssueDevOpsFeatureFlagRollout>;
};

export type IssueDevOpsFeatureFlagSummary = {
  __typename?: 'IssueDevOpsFeatureFlagSummary';
  lastUpdated?: Maybe<Scalars['String']>;
  status: IssueDevOpsFeatureFlagStatus;
  url?: Maybe<Scalars['String']>;
};

/** Latest commit on a branch */
export type IssueDevOpsHeadCommit = {
  __typename?: 'IssueDevOpsHeadCommit';
  displayId: Scalars['String'];
  /** Time of the commit in ISO 8601 format */
  timestamp?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['String']>;
};

/** Detailed information of an instance and its data (source data, build data, deployment data) */
export type IssueDevOpsProviderInstance = {
  __typename?: 'IssueDevOpsProviderInstance';
  baseUrl?: Maybe<Scalars['String']>;
  buildProviders?: Maybe<Array<IssueDevOpsBuildProvider>>;
  /**
   * There are common cases where a Pull Request is merged and its branch is deleted.
   * The downstream sources do not provide repository information on the PR, only branches information.
   * When the branch is deleted, it's not possible to create the bridge between PRs and Repository.
   * For this reason, any PR that couldn't be assigned to a repository will appear on this list.
   */
  danglingPullRequests?: Maybe<Array<IssueDevOpsPullRequestDetails>>;
  /**
   * An error message related to this instance passed down from DevStatus
   * These are not GraphQL errors. When an instance type is requested,
   * DevStatus may respond with a list instances and strings nested inside the 'errors' field, as follows:
   * `{ 'errors': [{'_instance': { ... }, error: 'unauthorized' }], detail: [ ... ] }`.
   * The status code for this response however is still 200
   * since only part of the instances requested may present these issues.
   * `devStatusErrorMessage` is deprecated. Use `devStatusErrorMessages`.
   */
  devStatusErrorMessage?: Maybe<Scalars['String']>;
  devStatusErrorMessages?: Maybe<Array<Scalars['String']>>;
  id: Scalars['String'];
  /** Indicates if it is possible to return more than a single instance per type. Only possible with FeCru */
  isSingleInstance?: Maybe<Scalars['Boolean']>;
  /** The name of the instance type */
  name?: Maybe<Scalars['String']>;
  repository?: Maybe<Array<IssueDevOpsRepositoryDetails>>;
  /** Raw type of the instance. e.g. bitbucket, stash, github */
  type?: Maybe<Scalars['String']>;
  /** The descriptive name of the instance type. e.g. Bitbucket Cloud */
  typeName?: Maybe<Scalars['String']>;
};

/** Description of a pull request or commit author */
export type IssueDevOpsPullRequestAuthor = {
  __typename?: 'IssueDevOpsPullRequestAuthor';
  /** The avatar URL of the author */
  avatarUrl?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Detailed information of a pull request */
export type IssueDevOpsPullRequestDetails = {
  __typename?: 'IssueDevOpsPullRequestDetails';
  author?: Maybe<IssueDevOpsPullRequestAuthor>;
  branchName?: Maybe<Scalars['String']>;
  branchUrl?: Maybe<Scalars['String']>;
  commentCount?: Maybe<Scalars['Int']>;
  id: Scalars['String'];
  /** Time of the last update in ISO 8601 format */
  lastUpdate?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  reviewers?: Maybe<Array<IssueDevOpsPullRequestReviewer>>;
  status?: Maybe<IssueDevOpsPullRequestStatus>;
  url?: Maybe<Scalars['String']>;
};

/** Description of a pull request reviewer */
export type IssueDevOpsPullRequestReviewer = {
  __typename?: 'IssueDevOpsPullRequestReviewer';
  /** The avatar URL of the reviewer */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Flag representing if the reviewer has already approved the PR */
  isApproved?: Maybe<Scalars['Boolean']>;
  name: Scalars['String'];
};

export enum IssueDevOpsPullRequestStatus {
  DECLINED = 'DECLINED',
  MERGED = 'MERGED',
  OPEN = 'OPEN',
}

export type IssueDevOpsRemoteLink = {
  __typename?: 'IssueDevOpsRemoteLink';
  actionIds?: Maybe<Array<Scalars['String']>>;
  attributeMap?: Maybe<Array<IssueDevOpsRemoteLinkAttributeTuple>>;
  description?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  providerId?: Maybe<Scalars['String']>;
  status?: Maybe<IssueDevOpsRemoteLinkStatus>;
  type?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

export type IssueDevOpsRemoteLinkAttributeTuple = {
  __typename?: 'IssueDevOpsRemoteLinkAttributeTuple';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type IssueDevOpsRemoteLinkLabel = {
  __typename?: 'IssueDevOpsRemoteLinkLabel';
  value: Scalars['String'];
};

export type IssueDevOpsRemoteLinkProvider = {
  __typename?: 'IssueDevOpsRemoteLinkProvider';
  actions?: Maybe<Array<IssueDevOpsRemoteLinkProviderAction>>;
  documentationUrl?: Maybe<Scalars['String']>;
  homeUrl?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  logoUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type IssueDevOpsRemoteLinkProviderAction = {
  __typename?: 'IssueDevOpsRemoteLinkProviderAction';
  id: Scalars['String'];
  label?: Maybe<IssueDevOpsRemoteLinkLabel>;
  templateUrl?: Maybe<Scalars['String']>;
};

export type IssueDevOpsRemoteLinksByType = {
  __typename?: 'IssueDevOpsRemoteLinksByType';
  providers: Array<IssueDevOpsRemoteLinkProvider>;
  types: Array<IssueDevOpsRemoteLinkType>;
};

export type IssueDevOpsRemoteLinkStatus = {
  __typename?: 'IssueDevOpsRemoteLinkStatus';
  appearance?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
};

export type IssueDevOpsRemoteLinkType = {
  __typename?: 'IssueDevOpsRemoteLinkType';
  remoteLinks?: Maybe<Array<IssueDevOpsRemoteLink>>;
  type: Scalars['String'];
};

/** Detailed information of a VCS repository */
export type IssueDevOpsRepositoryDetails = {
  __typename?: 'IssueDevOpsRepositoryDetails';
  /** The repository avatar URL */
  avatarUrl?: Maybe<Scalars['String']>;
  branches?: Maybe<Array<IssueDevOpsBranchDetails>>;
  commits?: Maybe<Array<IssueDevOpsCommitDetails>>;
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** A reference to the parent repository from where this has been forked for */
  parent?: Maybe<IssueDevOpsRepositoryParent>;
  pullRequests?: Maybe<Array<IssueDevOpsPullRequestDetails>>;
  url?: Maybe<Scalars['String']>;
};

/** Short description of the parent repository from which the fork was made */
export type IssueDevOpsRepositoryParent = {
  __typename?: 'IssueDevOpsRepositoryParent';
  name: Scalars['String'];
  url?: Maybe<Scalars['String']>;
};

/** Short desciption of a review associated with a branch or commit */
export type IssueDevOpsReview = {
  __typename?: 'IssueDevOpsReview';
  id: Scalars['String'];
  state?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

/** A summary for the tests results for a particular build */
export type IssueDevOpsTestSummary = {
  __typename?: 'IssueDevOpsTestSummary';
  numberFailed?: Maybe<Scalars['Int']>;
  numberPassed?: Maybe<Scalars['Int']>;
  numberSkipped?: Maybe<Scalars['Int']>;
  totalNumber?: Maybe<Scalars['Int']>;
};

/** Represents the Atlassian Document Format content in JSON format. */
export type JiraAdf = {
  __typename?: 'JiraADF';
  /** The content of ADF in JSON. */
  json?: Maybe<Scalars['JSON']>;
};

/**
 * Represents an affected service entity for a Jira Issue.
 * AffectedService provides context on what has been changed.
 */
export type JiraAffectedService = {
  __typename?: 'JiraAffectedService';
  /** The id of the affected service. E.g. jira. */
  serviceId?: Maybe<Scalars['String']>;
};

/** The connection type for JiraAffectedService. */
export type JiraAffectedServiceConnection = {
  __typename?: 'JiraAffectedServiceConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraAffectedServiceEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraAffectedService connection. */
export type JiraAffectedServiceEdge = {
  __typename?: 'JiraAffectedServiceEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraAffectedService>;
};

/** Represents Affected Services field. */
export type JiraAffectedServicesField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraAffectedServicesField';
    /**
     * Paginated list of affected services available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    affectedServices?: Maybe<JiraAffectedServiceConnection>;
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to query for all Affected Services when user interact with field. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The affected services available on the Issue or default affected services configured for the field. */
    selectedAffectedServices?: Maybe<Array<Maybe<JiraAffectedService>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents Affected Services field. */
export type JiraAffectedServicesFieldAffectedServicesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/**
 * Jira application properties is effectively a key/value store scoped to a Jira instance. A JiraApplicationProperty
 * represents one of these key/value pairs, along with associated metadata about the property.
 */
export type JiraApplicationProperty = Node & {
  __typename?: 'JiraApplicationProperty';
  /**
   * If the type is 'enum', then allowedValues may optionally contain a list of values which are valid for this property.
   * Otherwise the value will be null.
   */
  allowedValues?: Maybe<Array<Scalars['String']>>;
  /**
   * The default value which will be returned if there is no value stored. This might be useful for UIs which allow a
   * user to 'reset' an application property to the default value.
   */
  defaultValue: Scalars['String'];
  /** The human readable description for the application property */
  description?: Maybe<Scalars['String']>;
  /**
   * Example is mostly used for application properties which store some sort of format pattern (e.g. date formats).
   * Example will contain an example string formatted according to the format stored in the property.
   */
  example?: Maybe<Scalars['String']>;
  /** Globally unique identifier */
  id: Scalars['ID'];
  /** True if the user is allowed to edit the property, false otherwise */
  isEditable: Scalars['Boolean'];
  /** The unique key of the application property */
  key: Scalars['String'];
  /**
   * The human readable name for the application property. If no human readable name has been defined then the key will
   * be returned.
   */
  name: Scalars['String'];
  /**
   * Although all application properties are stored as strings, they notionally have a type (e.g. boolean, int, enum,
   * string). The type can be anything (for example, there is even a colour type), and there may be associated validation
   * on the server based on the property's type.
   */
  type: Scalars['String'];
  /**
   * The value of the application property, encoded as a string. If no value is stored the default value will
   * be returned.
   */
  value: Scalars['String'];
};

/** Represents a single option value for an asset field. */
export type JiraAsset = {
  __typename?: 'JiraAsset';
  /** The app key, which should be the Connect app key. This parameter is used to scope the originId. */
  appKey?: Maybe<Scalars['String']>;
  /** The identifier of an asset. This is the same identifier for the asset in its origin (external) system. */
  originId?: Maybe<Scalars['String']>;
  /** The appKey + originId separated by a forward slash. */
  serializedOrigin?: Maybe<Scalars['String']>;
  /** The appKey + originId separated by a forward slash. */
  value?: Maybe<Scalars['String']>;
};

/** Represents the Asset field on a Jira Issue. */
export type JiraAssetField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraAssetField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch all the assets for the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The assets available on the Issue or default assets configured for the field. */
    selectedAssets?: Maybe<Array<Maybe<JiraAsset>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents an Atlassian team in Jira. */
export type JiraAtlassianTeam = {
  __typename?: 'JiraAtlassianTeam';
  /** The avatar of the team. */
  avatar?: Maybe<JiraAvatar>;
  /** The name of the team. */
  name?: Maybe<Scalars['String']>;
  /** The UUID of team. */
  teamId?: Maybe<Scalars['String']>;
};

/** The connection type for JiraAtlassianTeam. */
export type JiraAtlassianTeamConnection = {
  __typename?: 'JiraAtlassianTeamConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraAtlassianTeamEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraAtlassianTeam connection. */
export type JiraAtlassianTeamEdge = {
  __typename?: 'JiraAtlassianTeamEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraAtlassianTeam>;
};

/** Represents the Atlassian team field on a Jira Issue. Allows you to select a team to be associated with an issue. */
export type JiraAtlassianTeamField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraAtlassianTeamField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch all the teams options for the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The team available on the Issue or default team configured for the field. */
    selectedTeam?: Maybe<JiraAtlassianTeam>;
    /**
     * Paginated list of team options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    teams?: Maybe<JiraAtlassianTeamConnection>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the Atlassian team field on a Jira Issue. Allows you to select a team to be associated with an issue. */
export type JiraAtlassianTeamFieldTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** An interface shared across all attachment types. */
export type JiraAttachment = {
  /** Identifier for the attachment. */
  attachmentId: Scalars['String'];
  /** User profile of the attachment author. */
  author?: Maybe<User>;
  /** Date the attachment was created in seconds since the epoch. */
  created: Scalars['DateTime'];
  /** Filename of the attachment. */
  fileName?: Maybe<Scalars['String']>;
  /** Size of the attachment in bytes. */
  fileSize?: Maybe<Scalars['Long']>;
  /** Media Services file id of this Attachment, May be absent if the attachment has not yet been migrated to Media Services. */
  mediaApiFileId?: Maybe<Scalars['String']>;
  /** The mimetype (also called content type) of the attachment. This may be {@code null}. */
  mimeType?: Maybe<Scalars['String']>;
  /** Parent id that this attachment is contained in. */
  parentId?: Maybe<Scalars['String']>;
  /** Parent name that this attachment is contained in e.g Issue, Field, Comment, Worklog. */
  parentName?: Maybe<Scalars['String']>;
};

/** The connection type for JiraAttachment. */
export type JiraAttachmentConnection = {
  __typename?: 'JiraAttachmentConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraAttachmentEdge>>>;
  /** The approximate count of items in the connection. */
  indicativeCount?: Maybe<Scalars['Int']>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
};

/** An edge in a JiraAttachment connection. */
export type JiraAttachmentEdge = {
  __typename?: 'JiraAttachmentEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the the edge. */
  node?: Maybe<JiraAttachment>;
};

/** Represents an attachment field on a Jira Issue. */
export type JiraAttachmentsField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraAttachmentsField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Paginated list of attachments available for the field or the Issue. */
    attachments?: Maybe<JiraAttachmentConnection>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Defines the maximum size limit (in bytes) of the total of all the attachments which can be associated with this field. */
    maxAllowedTotalAttachmentsSize?: Maybe<Scalars['Long']>;
    /** Contains the information needed to add a media content to this field. */
    mediaContext?: Maybe<JiraMediaContext>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Defines the permissions of the attachment collection. */
    permissions?: Maybe<Array<Maybe<JiraAttachmentsPermissions>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents an attachment field on a Jira Issue. */
export type JiraAttachmentsFieldAttachmentsArgs = {
  maxResults?: Maybe<Scalars['Int']>;
  orderDirection?: Maybe<JiraOrderDirection>;
  orderField?: Maybe<JiraAttachmentsOrderField>;
  startAt?: Maybe<Scalars['Int']>;
};

export type JiraAttachmentsOrderField = {
  id?: Maybe<Scalars['ID']>;
};

export enum JiraAttachmentsPermissions {
  /** Allows the user to create atachments on the correspondig Issue. */
  CREATE_ATTACHMENTS = 'CREATE_ATTACHMENTS',
  /** Allows the user to delete attachments on the corresponding Issue. */
  DELETE_OWN_ATTACHMENTS = 'DELETE_OWN_ATTACHMENTS',
}

/** Represents the four avatar sizes' url. */
export type JiraAvatar = {
  __typename?: 'JiraAvatar';
  /** A large avatar (48x48 pixels). */
  large?: Maybe<Scalars['String']>;
  /** A medium avatar (32x32 pixels). */
  medium?: Maybe<Scalars['String']>;
  /** A small avatar (24x24 pixels). */
  small?: Maybe<Scalars['String']>;
  /** An extra-small avatar (16x16 pixels). */
  xsmall?: Maybe<Scalars['String']>;
};

/**
 * Represents the pair of values (parent & child combination) in a cascading select.
 * This type is used to represent a selected cascading field value on a Jira Issue.
 * Since this is 2 level hierarchy, it is not possible to represent the same underlying
 * type for both single cascadingOption and list of cascadingOptions. Thus, we have created different types.
 */
export type JiraCascadingOption = {
  __typename?: 'JiraCascadingOption';
  /** Defines the selected single child option value for the parent. */
  childOptionValue?: Maybe<JiraOption>;
  /** Defines the parent option value. */
  parentOptionValue?: Maybe<JiraOption>;
};

/** Represents the childs options allowed values for a parent option in cascading select operation. */
export type JiraCascadingOptions = {
  __typename?: 'JiraCascadingOptions';
  /** Defines all the list of child options available for the parent option. */
  childOptionValues?: Maybe<Array<Maybe<JiraOption>>>;
  /** Defines the parent option value. */
  parentOptionValue?: Maybe<JiraOption>;
};

/** The connection type for JiraCascadingOptions. */
export type JiraCascadingOptionsConnection = {
  __typename?: 'JiraCascadingOptionsConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraCascadingOptionsEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraCascadingOptions connection. */
export type JiraCascadingOptionsEdge = {
  __typename?: 'JiraCascadingOptionsEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraCascadingOptions>;
};

/** Represents cascading select field. Currently only handles 2 level hierarchy. */
export type JiraCascadingSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraCascadingSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** The cascading option available on the Issue or default cascading option configured for the field. */
    cascadingOption?: Maybe<JiraCascadingOption>;
    /**
     * Paginated list of cascading options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    cascadingOptions?: Maybe<JiraCascadingOptionsConnection>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents cascading select field. Currently only handles 2 level hierarchy. */
export type JiraCascadingSelectFieldCascadingOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** An input filter used to specify the cascading options returned. */
export type JiraCascadingSelectOptionsFilter = {
  /** The type of cascading option to be returned. */
  optionType: JiraCascadingSelectOptionType;
  /**
   * Used for retrieving CHILD cascading options by specifying the PARENT cascading option's name.
   *
   * The parent name is case-sensitive and it will not be applied to non-child cascading options.
   */
  parentOptionName?: Maybe<Scalars['String']>;
};

/**
 * Cascading options can either be a parent or a child - this enum captures this characteristic.
 *
 * E.g. If there is a parent cascading option named `P1`, it may or may not have
 * child cascading options named `C1` and `C2`.
 * - `P1` would be a `PARENT` enum
 * - `C1` and `C2` would be `CHILD` enums
 */
export enum JiraCascadingSelectOptionType {
  /** All options, regardless of whether they're a parent or child. */
  ALL = 'ALL',
  /** Child option only */
  CHILD = 'CHILD',
  /** Parent option only */
  PARENT = 'PARENT',
}

/** Represents the check boxes field on a Jira Issue. */
export type JiraCheckboxesField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraCheckboxesField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The options available on the Issue or default options configured for the field. */
    selectedFieldOptions?: Maybe<Array<Maybe<JiraOption>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the check boxes field on a Jira Issue. */
export type JiraCheckboxesFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents CMDB field on a Jira Issue. */
export type JiraCmdbField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraCMDBField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Attributes that are configured for autocomplete search. */
    attributesIncludedInAutoCompleteSearch?: Maybe<
      Array<Maybe<Scalars['String']>>
    >;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Whether the field is configured to act as single/multi select CMDB(s) field. */
    isMulti?: Maybe<Scalars['Boolean']>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available cmdb options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The CMDB objects available on the Issue or default CMDB objects configured for the field. */
    selectedCmdbObjects?: Maybe<Array<Maybe<JiraCmdbObject>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Jira Configuration Management Database. */
export type JiraCmdbObject = Node & {
  __typename?: 'JiraCmdbObject';
  /** Global identifier for the cmdb field. */
  id: Scalars['ID'];
  /** Label display in the cmdb field. */
  label?: Maybe<Scalars['String']>;
  /** Unique object id formed with `workspaceId`:`objectId`. */
  objectGlobalId?: Maybe<Scalars['String']>;
  /** Unique id in the workspace of the cmdb object. */
  objectId?: Maybe<Scalars['String']>;
  /** Workspace id of the cmdb object. */
  workspaceId?: Maybe<Scalars['String']>;
};

/** Jira color that displays on a field. */
export type JiraColor = {
  __typename?: 'JiraColor';
  /** The key associated with the color based on the field type (issue color, epic color). */
  colorKey?: Maybe<Scalars['String']>;
  /** Global identifier for the color. */
  id?: Maybe<Scalars['ID']>;
};

/** Represents color field on a Jira Issue. E.g. issue color, epic color. */
export type JiraColorField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraColorField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** The color available on the Issue or default color configured for the field. */
    color?: Maybe<JiraColor>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** An interface shared across all comment types. */
export type JiraComment = {
  /** User profile of the original comment author. */
  author?: Maybe<User>;
  /** Identifier for the comment. */
  commentId: Scalars['ID'];
  /** Time of comment creation. */
  created: Scalars['DateTime'];
  /**
   * Either the group or the project role associated with this comment, but not both.
   * Null means the permission level is unspecified, i.e. the comment is public.
   */
  permissionLevel?: Maybe<JiraPermissionLevel>;
  /** Comment body rich text. */
  richText?: Maybe<JiraRichText>;
  /** User profile of the author performing the comment update. */
  updateAuthor?: Maybe<User>;
  /** Time of last comment update. */
  updated?: Maybe<Scalars['DateTime']>;
};

/** The connection type for JiraComment. */
export type JiraCommentConnection = {
  __typename?: 'JiraCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraCommentEdge>>>;
  /** The approximate count of items in the connection. */
  indicativeCount?: Maybe<Scalars['Int']>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a JiraCommentConnection connection. */
export type JiraCommentEdge = {
  __typename?: 'JiraCommentEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the the edge. */
  node?: Maybe<JiraComment>;
};

/** Jira component defines a sub-selectin of a project. */
export type JiraComponent = Node & {
  __typename?: 'JiraComponent';
  /** Component id in digital format. */
  componentId: Scalars['String'];
  /** Component description. */
  description?: Maybe<Scalars['String']>;
  /** Global identifier for the color. */
  id: Scalars['ID'];
  /** The name of the component. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for JiraComponent. */
export type JiraComponentConnection = {
  __typename?: 'JiraComponentConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraComponentEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraComponent connection. */
export type JiraComponentEdge = {
  __typename?: 'JiraComponentEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraComponent>;
};

/** Represents components field on a Jira Issue. */
export type JiraComponentsField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraComponentsField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /**
     * Paginated list of component options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    components?: Maybe<JiraComponentConnection>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The component available on the Issue or default component configured for the field. */
    selectedComponents?: Maybe<Array<Maybe<JiraComponent>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents components field on a Jira Issue. */
export type JiraComponentsFieldComponentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a multi-select field created by Connect App. */
export type JiraConnectMultipleSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraConnectMultipleSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    searchUrl?: Maybe<Scalars['String']>;
    /** The options available on the Issue or default options configured for the field. */
    selectedFieldOptions?: Maybe<Array<Maybe<JiraOption>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a multi-select field created by Connect App. */
export type JiraConnectMultipleSelectFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a number field created by Connect App. */
export type JiraConnectNumberField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraConnectNumberField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Connected number. */
    number?: Maybe<Scalars['Float']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents rich text field on a Jira Issue. E.g. description, environment. */
export type JiraConnectRichTextField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraConnectRichTextField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Contains the information needed to add a media content to this field. */
    mediaContext?: Maybe<JiraMediaContext>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Determines what editor to render.
     * E.g. default text rendering or wiki text rendering.
     */
    renderer?: Maybe<Scalars['String']>;
    /** The rich text available on the Issue or default rich text configured for the field. */
    richText?: Maybe<JiraRichText>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a single select field created by Connect App. */
export type JiraConnectSingleSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraConnectSingleSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** The option available on the Issue or default option configured for the field. */
    fieldOption?: Maybe<JiraOption>;
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a single select field created by Connect App. */
export type JiraConnectSingleSelectFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a text field created by Connect App. */
export type JiraConnectTextField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraConnectTextField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Content of the connect text field. */
    text?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a date picker field on an issue. */
export type JiraDatePickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraDatePickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** The date available on the Issue or default date configured for the field. */
    date?: Maybe<Scalars['Date']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a date time picker field on a Jira Issue. */
export type JiraDateTimePickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraDateTimePickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** The datetime available on the Issue or default datetime configured for the field. */
    dateTime?: Maybe<Scalars['DateTime']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/**
 * The default grant type with only id and name to return data for grant types such as PROJECT_LEAD, APPLICATION_ROLE,
 * ANY_LOGGEDIN_USER_APPLICATION_ROLE, ANONYMOUS_ACCESS, SERVICE_PROJECT_CUSTOMER_PORTAL_ACCESS
 */
export type JiraDefaultGrantTypeValue = Node & {
  __typename?: 'JiraDefaultGrantTypeValue';
  /**
   * The ARI to represent the default grant type value.
   * For example:
   * PROJECT_LEAD ari - ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:role/project-lead/activation/bd0c43a9-a23a-4302-8ffa-ca04bde7c747/project/f67c73a8-545e-455b-a6bd-3d53cb7e0524
   * APPLICATION_ROLE ari for JSM - ari:cloud:jira-servicedesk::role/123
   * ANY_LOGGEDIN_USER_APPLICATION_ROLE ari - ari:cloud:jira::role/product/member
   * ANONYMOUS_ACCESS ari - ari:cloud:identity::user/unidentified
   */
  id: Scalars['ID'];
  /** The display name of the grant type value such as GROUP. */
  name: Scalars['String'];
};

/** Container for all DevOps data for an issue, to be displayed in the DevOps Panel of an issue */
export type JiraDevOpsIssuePanel = {
  __typename?: 'JiraDevOpsIssuePanel';
  /** Specify a banner to show on top of the dev panel. `null` means that no banner should be displayed. */
  devOpsIssuePanelBanner?: Maybe<JiraDevOpsIssuePanelBannerType>;
  /** Container for the Dev Summary of this issue */
  devSummaryResult?: Maybe<JiraIssueDevSummaryResult>;
  /** Specifies the state the DevOps panel in the issue view should be in */
  panelState?: Maybe<JiraDevOpsIssuePanelState>;
};

export enum JiraDevOpsIssuePanelBannerType {
  /** Banner that explains how to add issue keys in your commits, branches and PRs */
  ISSUE_KEY_ONBOARDING = 'ISSUE_KEY_ONBOARDING',
}

/** The possible States the DevOps Issue Panel can be in */
export enum JiraDevOpsIssuePanelState {
  /** Panel should show the available Dev Summary */
  DEV_SUMMARY = 'DEV_SUMMARY',
  /** Panel should be hidden */
  HIDDEN = 'HIDDEN',
  /** Panel should show the "not connected" state to prompt user to integrate tools */
  NOT_CONNECTED = 'NOT_CONNECTED',
}

/** Container for all DevOps related mutations in Jira */
export type JiraDevOpsMutation = {
  __typename?: 'JiraDevOpsMutation';
  /**
   * Lets a user dismiss a banner shown in the DevOps Issue Panel
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraDevOps` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  dismissDevOpsIssuePanelBanner?: Maybe<
    JiraDismissDevOpsIssuePanelBannerPayload
  >;
  /**
   * Lets a user opt-out of the "not-connected" state in the DevOps Issue Panel
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraDevOps` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  optoutOfDevOpsIssuePanelNotConnectedState?: Maybe<
    JiraOptoutDevOpsIssuePanelNotConnectedPayload
  >;
};

/** Container for all DevOps related mutations in Jira */
export type JiraDevOpsMutationDismissDevOpsIssuePanelBannerArgs = {
  input: JiraDismissDevOpsIssuePanelBannerInput;
};

/** Container for all DevOps related mutations in Jira */
export type JiraDevOpsMutationOptoutOfDevOpsIssuePanelNotConnectedStateArgs = {
  input: JiraOptoutDevOpsIssuePanelNotConnectedInput;
};

/** Container for all DevOps related queries in Jira */
export type JiraDevOpsQuery = {
  __typename?: 'JiraDevOpsQuery';
  /**
   * Returns the JiraDevOpsIssuePanel for an issue
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraDevOps` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  devOpsIssuePanel?: Maybe<JiraDevOpsIssuePanel>;
};

/** Container for all DevOps related queries in Jira */
export type JiraDevOpsQueryDevOpsIssuePanelArgs = {
  issueId: Scalars['ID'];
};

/** The input type for devops panel banner dismissal */
export type JiraDismissDevOpsIssuePanelBannerInput = {
  /**
   * Only "issue-key-onboarding" is supported currently as this is the only banner
   * that can be displayed in the panel for now
   */
  bannerType: JiraDevOpsIssuePanelBannerType;
  /** ID of the issue this banner was dismissed on */
  issueId: Scalars['ID'];
};

/** The response payload for devops panel banner dismissal */
export type JiraDismissDevOpsIssuePanelBannerPayload = Payload & {
  __typename?: 'JiraDismissDevOpsIssuePanelBannerPayload';
  /** The errors field represents additional mutation error information if exists. */
  errors?: Maybe<Array<MutationError>>;
  /** The success indicator saying whether mutation operation was successful as a whole or not. */
  success: Scalars['Boolean'];
};

/** Represents an epic. */
export type JiraEpic = {
  __typename?: 'JiraEpic';
  /** Color string for the epic. */
  color?: Maybe<Scalars['String']>;
  /** Status of the epic, whether its completed or not. */
  done?: Maybe<Scalars['Boolean']>;
  /** Global identifier for the epic/issue Id. */
  id: Scalars['ID'];
  /** Issue Id for the epic. */
  issueId: Scalars['String'];
  /** Key identifier for the issue. */
  key?: Maybe<Scalars['String']>;
  /** Name of the epic. */
  name?: Maybe<Scalars['String']>;
  /** Summary of the epic. */
  summary?: Maybe<Scalars['String']>;
};

/** The connection type for JiraEpic. */
export type JiraEpicConnection = {
  __typename?: 'JiraEpicConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraEpicEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraEpic connection. */
export type JiraEpicEdge = {
  __typename?: 'JiraEpicEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraEpic>;
};

/** Represents epic link field on a Jira Issue. */
export type JiraEpicLinkField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraEpicLinkField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** The epic available on the Issue or default epic configured for the field. */
    epic?: Maybe<JiraEpic>;
    /**
     * Paginated list of epic options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    epics?: Maybe<JiraEpicConnection>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available epics options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents epic link field on a Jira Issue. */
export type JiraEpicLinkFieldEpicsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  done?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents the Jira time tracking estimate type. */
export type JiraEstimate = {
  __typename?: 'JiraEstimate';
  /** The estimated time in seconds. */
  timeInSeconds?: Maybe<Scalars['Long']>;
};

/** Attributes of field configuration. */
export type JiraFieldConfig = {
  __typename?: 'JiraFieldConfig';
  /** Defines if a field is editable. */
  isEditable?: Maybe<Scalars['Boolean']>;
  /** Defines if a field is required on a screen. */
  isRequired?: Maybe<Scalars['Boolean']>;
  /**
   * Explains the reason why a field is not editable on a screen.
   * E.g. cases where a field needs a licensed premium version to be editable.
   */
  nonEditableReason?: Maybe<JiraFieldNonEditableReason>;
};

/** Represents the information for a field being non-editable on Issue screens. */
export type JiraFieldNonEditableReason = {
  __typename?: 'JiraFieldNonEditableReason';
  /** Message explanining why the field is non-editable (if present). */
  message?: Maybe<Scalars['String']>;
};

/** Represents the Jira flag. */
export type JiraFlag = {
  __typename?: 'JiraFlag';
  /** Indicates whether the issue is flagged or not. */
  isFlagged?: Maybe<Scalars['Boolean']>;
};

/** Represents a flag field on a Jira Issue. E.g. flagged. */
export type JiraFlagField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraFlagField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** The flag value available on the issue. */
    flag?: Maybe<JiraFlag>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a Group field created by Forge App. */
export type JiraForgeGroupField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraForgeGroupField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of group options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    groups?: Maybe<JiraGroupConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    searchUrl?: Maybe<Scalars['String']>;
    /** The group available on the Issue or default group configured for the field. */
    selectedGroup?: Maybe<JiraGroup>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a Group field created by Forge App. */
export type JiraForgeGroupFieldGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a number field created by Forge App. */
export type JiraForgeNumberField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraForgeNumberField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The number available on the Issue or default number configured for the field. */
    number?: Maybe<Scalars['Float']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a string field created by Forge App. */
export type JiraForgeStringField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraForgeStringField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The text available on the Issue or default text configured for the field. */
    text?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a strings field created by Forge App. */
export type JiraForgeStringsField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraForgeStringsField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /**
     * Paginated list of label options for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    labels?: Maybe<JiraLabelConnection>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available labels options on the field or an Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The labels available on the Issue or default labels configured for the field. */
    selectedLabels?: Maybe<Array<Maybe<JiraLabel>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a strings field created by Forge App. */
export type JiraForgeStringsFieldLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents a User field created by Forge App. */
export type JiraForgeUserField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraForgeUserField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** The user available on the Issue or default user configured for the field. */
    user?: Maybe<User>;
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a User field created by Forge App. */
export type JiraForgeUserFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** The unique key of the grant type such as PROJECT_ROLE. */
export type JiraGrantTypeKey = {
  __typename?: 'JiraGrantTypeKey';
  /** The key to identify the grant type such as PROJECT_ROLE. */
  key: JiraGrantTypeKeyEnum;
  /** The display name of the grant type key such as Project Role. */
  name: Scalars['String'];
};

/**
 * The grant type key enum represents all the possible grant types available in Jira.
 * A grant type may take an optional parameter value.
 * For example: PROJECT_ROLE grant type takes project role id as parameter. And, PROJECT_LEAD grant type do not.
 *
 * The actual ARI formats are documented on the various concrete grant type values.
 */
export enum JiraGrantTypeKeyEnum {
  /**
   * The anonymous access represents the public access without logging in.
   * It takes no parameter.
   */
  ANONYMOUS_ACCESS = 'ANONYMOUS_ACCESS',
  /**
   * Any user who has the product access.
   * It takes no parameter.
   */
  ANY_LOGGEDIN_USER_APPLICATION_ROLE = 'ANY_LOGGEDIN_USER_APPLICATION_ROLE',
  /**
   * A application role is used to grant a user/group access to the application group.
   * It takes application role as parameter.
   */
  APPLICATION_ROLE = 'APPLICATION_ROLE',
  /**
   * The issue assignee role.
   * It takes platform defined 'assignee' as parameter to represent the issue field value.
   */
  ASSIGNEE = 'ASSIGNEE',
  /**
   * A group is a collection of users who can be given access together.
   * It represents group in the organization's user base.
   * It takes group id as parameter.
   */
  GROUP = 'GROUP',
  /**
   * A multi group picker custom field.
   * It takes multi group picker custom field id as parameter.
   */
  MULTI_GROUP_PICKER = 'MULTI_GROUP_PICKER',
  /**
   * A multi user picker custom field.
   * It takes multi user picker custom field id as parameter.
   */
  MULTI_USER_PICKER = 'MULTI_USER_PICKER',
  /**
   * The project lead role.
   * It takes no parameter.
   */
  PROJECT_LEAD = 'PROJECT_LEAD',
  /**
   * A role that user/group can play in a project.
   * It takes project role as parameter.
   */
  PROJECT_ROLE = 'PROJECT_ROLE',
  /**
   * The issue reporter role.
   * It takes platform defined 'reporter' as parameter to represent the issue field value.
   */
  REPORTER = 'REPORTER',
  /**
   * The grant type defines what the customers can do from the portal view.
   * It takes no parameter.
   */
  SERVICE_PROJECT_CUSTOMER_PORTAL_ACCESS = 'SERVICE_PROJECT_CUSTOMER_PORTAL_ACCESS',
  /**
   * An individual user who can be given the access to work on one or more projects.
   * It takes user account id as parameter.
   */
  USER = 'USER',
}

/**
 * The JiraGrantTypeValue union resolves to one of the concrete types such as
 * JiraDefaultGrantTypeValue, JiraProjectRoleGrantTypeValue.
 */
export type JiraGrantTypeValue =
  | JiraDefaultGrantTypeValue
  | JiraGroupGrantTypeValue
  | JiraIssueFieldGrantTypeValue
  | JiraProjectRoleGrantTypeValue
  | JiraUserGrantTypeValue;

/** A type to represent one or more paginated list of one or more permission grant values available for a given grant type. */
export type JiraGrantTypeValueConnection = {
  __typename?: 'JiraGrantTypeValueConnection';
  /** The data for edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraGrantTypeValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of items matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge object representing grant type value information used within connection object. */
export type JiraGrantTypeValueEdge = {
  __typename?: 'JiraGrantTypeValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at this edge. */
  node: JiraGrantTypeValue;
};

/** Represents a Jira Group. */
export type JiraGroup = {
  __typename?: 'JiraGroup';
  /** Group Id, can be null on group creation */
  groupId?: Maybe<Scalars['String']>;
  /** The global identifier of the group in ARI format. */
  id?: Maybe<Scalars['ID']>;
  /** Name of the Group */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for JiraGroup. */
export type JiraGroupConnection = {
  __typename?: 'JiraGroupConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraGroup>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraGroupConnection connection. */
export type JiraGroupEdge = {
  __typename?: 'JiraGroupEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraGroup>;
};

/** The GROUP grant type value where group data is provided by identity service. */
export type JiraGroupGrantTypeValue = Node & {
  __typename?: 'JiraGroupGrantTypeValue';
  /** The group information such as name, and description. */
  group: JiraGroup;
  /**
   * The ARI to represent the group grant type value.
   * For example: ari:cloud:identity::group/123
   */
  id: Scalars['ID'];
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssue = Node & {
  __typename?: 'JiraIssue';
  /**
   * Paginated list of attachments available on this issue.
   * The server may throw an error if both a forward page (specified with `first`)
   * and a backward page (specified with `last`) are requested simultaneously.
   */
  attachments?: Maybe<JiraAttachmentConnection>;
  /**
   * Paginated list of comments available on this issue.
   * The server may throw an error if both a forward page (specified with `first`)
   * and a backward page (specified with `last`) are requested simultaneously.
   */
  comments?: Maybe<JiraCommentConnection>;
  /**
   * Loads the displayable fields relevant to the current Issue/User context.
   * The server may throw an error if both a forward page (specified with `first`)
   * and a backward page (specified with `last`) are requested simultaneously.
   */
  fields?: Maybe<JiraIssueFieldConnection>;
  /**
   * Paginated list of fields available on this issue. Allows clients to specify fields by their identifier.
   * The server may throw an error if both a forward page (specified with `first`)
   * and a backward page (specified with `last`) are requested simultaneously.
   */
  fieldsById?: Maybe<JiraIssueFieldConnection>;
  /** Unique identifier associated with this Issue. */
  id: Scalars['ID'];
  /** Issue ID in numeric format. E.g. 10000 */
  issueId: Scalars['String'];
  /** The {projectKey}-{issueNumber} associated with this Issue. */
  key: Scalars['String'];
  /**
   * Paginated list of worklogs available on this issue.
   * The server may throw an error if both a forward page (specified with `first`)
   * and a backward page (specified with `last`) are requested simultaneously.
   */
  worklogs?: Maybe<JiraWorkLogConnection>;
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssueAttachmentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssueCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssueFieldsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssueFieldsByIdArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  ids: Array<Scalars['ID']>;
  last?: Maybe<Scalars['Int']>;
};

/** Jira Issue node. Includes the Issue data displayable in the current User context. */
export type JiraIssueWorklogsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Summary of the Branches attached to the issue */
export type JiraIssueBranchDevSummary = {
  __typename?: 'JiraIssueBranchDevSummary';
  /** Total number of Branches for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
};

/** Container for the summary of the Branches attached to the issue */
export type JiraIssueBranchDevSummaryContainer = {
  __typename?: 'JiraIssueBranchDevSummaryContainer';
  /** The actual summary of the Branches attached to the issue */
  overall?: Maybe<JiraIssueBranchDevSummary>;
  /** Count of Branches aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

/** Summary of the Builds attached to the issue */
export type JiraIssueBuildDevSummary = {
  __typename?: 'JiraIssueBuildDevSummary';
  /** Total number of Builds for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Number of failed buids for the issue */
  failedBuildCount?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
  /** Number of successful buids for the issue */
  successfulBuildCount?: Maybe<Scalars['Int']>;
  /** Number of buids with unknown result for the issue */
  unknownBuildCount?: Maybe<Scalars['Int']>;
};

/** Container for the summary of the Builds attached to the issue */
export type JiraIssueBuildDevSummaryContainer = {
  __typename?: 'JiraIssueBuildDevSummaryContainer';
  /** The actual summary of the Builds attached to the issue */
  overall?: Maybe<JiraIssueBuildDevSummary>;
  /** Count of Builds aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

/** Summary of the Commits attached to the issue */
export type JiraIssueCommitDevSummary = {
  __typename?: 'JiraIssueCommitDevSummary';
  /** Total number of Commits for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
};

/** Container for the summary of the Commits attached to the issue */
export type JiraIssueCommitDevSummaryContainer = {
  __typename?: 'JiraIssueCommitDevSummaryContainer';
  /** The actual summary of the Commits attached to the issue */
  overall?: Maybe<JiraIssueCommitDevSummary>;
  /** Count of Commits aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

/** The connection type for JiraIssue. */
export type JiraIssueConnection = {
  __typename?: 'JiraIssueConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraIssueEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type JiraIssueDeploymentEnvironment = {
  __typename?: 'JiraIssueDeploymentEnvironment';
  /** State of the deployment */
  status?: Maybe<JiraIssueDeploymentEnvironmentState>;
  /** Title of the deployment environment */
  title?: Maybe<Scalars['String']>;
};

/** Summary of the Deployment Environments attached to the issue */
export type JiraIssueDeploymentEnvironmentDevSummary = {
  __typename?: 'JiraIssueDeploymentEnvironmentDevSummary';
  /** Total number of Reviews for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
  /** A list of the top environment there was a deployment on */
  topEnvironments?: Maybe<Array<JiraIssueDeploymentEnvironment>>;
};

/** Container for the summary of the Deployment Environments attached to the issue */
export type JiraIssueDeploymentEnvironmentDevSummaryContainer = {
  __typename?: 'JiraIssueDeploymentEnvironmentDevSummaryContainer';
  /** The actual summary of the Deployment Environments attached to the issue */
  overall?: Maybe<JiraIssueDeploymentEnvironmentDevSummary>;
  /** Count of Deployment Environments aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

/** Possible states for a deployment environment */
export enum JiraIssueDeploymentEnvironmentState {
  /** The deployment was deployed successfully */
  DEPLOYED = 'DEPLOYED',
  /** The deployment was not deployed successfully */
  NOT_DEPLOYED = 'NOT_DEPLOYED',
}

/** Lists the summaries available for each type of dev info, for a given issue */
export type JiraIssueDevSummary = {
  __typename?: 'JiraIssueDevSummary';
  /** Summary of the Branches attached to the issue */
  branch?: Maybe<JiraIssueBranchDevSummaryContainer>;
  /** Summary of the Builds attached to the issue */
  build?: Maybe<JiraIssueBuildDevSummaryContainer>;
  /** Summary of the Commits attached to the issue */
  commit?: Maybe<JiraIssueCommitDevSummaryContainer>;
  /**
   * Summary of the deployment environments attached to some builds.
   * This is a legacy attribute only used by Bamboo builds
   */
  deploymentEnvironments?: Maybe<
    JiraIssueDeploymentEnvironmentDevSummaryContainer
  >;
  /** Summary of the Pull Requests attached to the issue */
  pullrequest?: Maybe<JiraIssuePullRequestDevSummaryContainer>;
  /** Summary of the Reviews attached to the issue */
  review?: Maybe<JiraIssueReviewDevSummaryContainer>;
};

/** Aggregates the `count` of entities for a given provider */
export type JiraIssueDevSummaryByProvider = {
  __typename?: 'JiraIssueDevSummaryByProvider';
  /** Number of entities associated with that provider */
  count?: Maybe<Scalars['Int']>;
  /** Provider name */
  name?: Maybe<Scalars['String']>;
  /** UUID for a given provider, to allow aggregation */
  providerId?: Maybe<Scalars['String']>;
};

/** Error when querying the JiraIssueDevSummary */
export type JiraIssueDevSummaryError = {
  __typename?: 'JiraIssueDevSummaryError';
  /** Information about the provider that triggered the error */
  instance?: Maybe<JiraIssueDevSummaryErrorProviderInstance>;
  /** A message describing the error */
  message?: Maybe<Scalars['String']>;
};

/** Basic information on a provider that triggered an error */
export type JiraIssueDevSummaryErrorProviderInstance = {
  __typename?: 'JiraIssueDevSummaryErrorProviderInstance';
  /** Base URL of the provider's instance that failed */
  baseUrl?: Maybe<Scalars['String']>;
  /** Provider's name */
  name?: Maybe<Scalars['String']>;
  /** Provider's type */
  type?: Maybe<Scalars['String']>;
};

/** Container for the Dev Summary of an issue */
export type JiraIssueDevSummaryResult = {
  __typename?: 'JiraIssueDevSummaryResult';
  /**
   * Returns "non-transient errors". That is, configuration errors that require admin intervention to be solved.
   * This returns an empty collection when called for users that are not administrators or system administrators.
   */
  configErrors?: Maybe<Array<JiraIssueDevSummaryError>>;
  /** Contains all available summaries for the issue */
  devSummary?: Maybe<JiraIssueDevSummary>;
  /**
   * Returns "transient errors". That is, errors that may be solved by retrying the fetch operation.
   * This excludes configuration errors that require admin intervention to be solved.
   */
  errors?: Maybe<Array<JiraIssueDevSummaryError>>;
};

/** An edge in a JiraIssue connection. */
export type JiraIssueEdge = {
  __typename?: 'JiraIssueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssue>;
};

/** Represents the common structure across Issue fields. */
export type JiraIssueField = {
  /**
   * The field ID alias.
   * Applies to managed or commonly known custom fields in Jira, which allow lookup without requiring the custom field ID.
   * E.g. rank or startdate.
   */
  aliasFieldId?: Maybe<Scalars['ID']>;
  /** Description for the field (if present). */
  description?: Maybe<Scalars['String']>;
  /** The identifier of the field. E.g. summary, customfield_10001, etc. */
  fieldId: Scalars['String'];
  /** Unique identifier for the entity. */
  id: Scalars['ID'];
  /** Translated name for the field (if applicable). */
  name: Scalars['String'];
  /** Field type key. E.g. project, issuetype, com.pyxis.greenhopper.Jira:gh-epic-link. */
  type: Scalars['String'];
};

/** Represents the configurations associated with an Issue field. */
export type JiraIssueFieldConfiguration = {
  /** Attributes of an Issue field's configuration info. */
  fieldConfig?: Maybe<JiraFieldConfig>;
};

/** The connection type for JiraIssueField. */
export type JiraIssueFieldConnection = {
  __typename?: 'JiraIssueFieldConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraIssueFieldEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraIssueField connection. */
export type JiraIssueFieldEdge = {
  __typename?: 'JiraIssueFieldEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueField>;
};

/**
 * The issue field grant type used to represent field of an issue.
 * Grant types such as ASSIGNEE, REPORTER, MULTI USER PICKER, and MULTI GROUP PICKER use this grant type value.
 */
export type JiraIssueFieldGrantTypeValue = Node & {
  __typename?: 'JiraIssueFieldGrantTypeValue';
  /** The issue field information such as name, description, field id. */
  field: JiraIssueField;
  /**
   * The ARI to represent the issue field grant type value.
   * For example:
   * assignee field ARI is ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:issuefieldvalue/10000/assignee
   * reporter field ARI is ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:issuefieldvalue/10000/reporter
   * multi user picker field ARI is ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:issuefieldvalue/10000/customfield_10126
   */
  id: Scalars['ID'];
};

/** Represents a system container and its items. */
export type JiraIssueItemContainer = {
  __typename?: 'JiraIssueItemContainer';
  /** The system container type. */
  containerType?: Maybe<JiraIssueItemSystemContainerType>;
  /** The system container items. */
  items?: Maybe<JiraIssueItemContainerItemConnection>;
};

/** Represents the items that can be placed in any system container. */
export type JiraIssueItemContainerItem =
  | JiraIssueItemFieldItem
  | JiraIssueItemGroupContainer
  | JiraIssueItemPanelItem
  | JiraIssueItemTabContainer;

/** The connection type for `JiraIssueItemContainerItem`. */
export type JiraIssueItemContainerItemConnection = {
  __typename?: 'JiraIssueItemContainerItemConnection';
  /** The data for edges in the page. */
  edges?: Maybe<Array<Maybe<JiraIssueItemContainerItemEdge>>>;
  /**
   * Deprecated.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Please use edges instead.
   */
  nodes?: Maybe<Array<Maybe<JiraIssueItemContainerItem>>>;
  /** Information about the page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a `JiraIssueItemContainerItem` connection. */
export type JiraIssueItemContainerItemEdge = {
  __typename?: 'JiraIssueItemContainerItemEdge';
  /** The cursor to the edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueItemContainerItem>;
};

/** Represents a related collection of system containers and their items, and the collection of default item locations. */
export type JiraIssueItemContainers = {
  __typename?: 'JiraIssueItemContainers';
  /** The collection of system containers. */
  containers?: Maybe<Array<Maybe<JiraIssueItemContainer>>>;
  /** The collection of default item locations. */
  defaultItemLocations?: Maybe<
    Array<Maybe<JiraIssueItemLayoutDefaultItemLocation>>
  >;
};

/** Contains the fetched containers or an error. */
export type JiraIssueItemContainersResult =
  | JiraIssueItemContainers
  | QueryError;

/** Represents a reference to a field by field ID, used for laying out fields on an issue. */
export type JiraIssueItemFieldItem = {
  __typename?: 'JiraIssueItemFieldItem';
  /**
   * Represents the position of the field in the container.
   * Aid to preserve the field position when combining items in `PRIMARY` and
   * `REQUEST` container types before saving in JSM projects.
   */
  containerPosition: Scalars['Int'];
  /** The field item ID. */
  fieldItemId: Scalars['String'];
};

/** Represents a collection of items that are held in a group container. */
export type JiraIssueItemGroupContainer = {
  __typename?: 'JiraIssueItemGroupContainer';
  /** The group container ID. */
  groupContainerId: Scalars['String'];
  /** The group container items. */
  items?: Maybe<JiraIssueItemGroupContainerItemConnection>;
  /** Whether a group container is minimized. */
  minimised?: Maybe<Scalars['Boolean']>;
  /** The group container name. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the items that can be placed in any group container. */
export type JiraIssueItemGroupContainerItem =
  | JiraIssueItemFieldItem
  | JiraIssueItemPanelItem;

/** The connection type for `JiraIssueItemGroupContainerItem`. */
export type JiraIssueItemGroupContainerItemConnection = {
  __typename?: 'JiraIssueItemGroupContainerItemConnection';
  /** The data for edges in the page. */
  edges?: Maybe<Array<Maybe<JiraIssueItemGroupContainerItemEdge>>>;
  /**
   * Deprecated.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Please use edges instead.
   */
  nodes?: Maybe<Array<Maybe<JiraIssueItemGroupContainerItem>>>;
  /** Information about the page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a `JiraIssueItemGroupContainerItem` connection. */
export type JiraIssueItemGroupContainerItemEdge = {
  __typename?: 'JiraIssueItemGroupContainerItemEdge';
  /** The cursor to the edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueItemGroupContainerItem>;
};

/**
 * Represents a default location rule for items that are not configured in a container.
 * Example: A user picker is added to a screen. Until the administrator places it in the layout, the item is placed in
 * the location specified by the 'PEOPLE' category. The categories available may vary based on the project type.
 */
export type JiraIssueItemLayoutDefaultItemLocation = {
  __typename?: 'JiraIssueItemLayoutDefaultItemLocation';
  /** A destination container type or the ID of a destination group. */
  containerLocation?: Maybe<Scalars['String']>;
  /** The item location rule type. */
  itemLocationRuleType?: Maybe<JiraIssueItemLayoutItemLocationRuleType>;
};

/** Represents the type of items that the default location rule applies to. */
export enum JiraIssueItemLayoutItemLocationRuleType {
  /** Date items. For example: date or time related fields. */
  DATES = 'DATES',
  /** Multiline text items. For example: a description field or custom multi-line test fields. */
  MULTILINE_TEXT = 'MULTILINE_TEXT',
  /** Any other item types not covered by previous item types. */
  OTHER = 'OTHER',
  /** People items. For example: user pickers, team pickers or group picker. */
  PEOPLE = 'PEOPLE',
  /** Time tracking items. For example: estimate, original estimate or time tracking panels. */
  TIMETRACKING = 'TIMETRACKING',
}

/** Represents a reference to a panel by panel ID, used for laying out panels on an issue. */
export type JiraIssueItemPanelItem = {
  __typename?: 'JiraIssueItemPanelItem';
  /** The panel item ID. */
  panelItemId: Scalars['String'];
};

/** The system container types that are available for placing items. */
export enum JiraIssueItemSystemContainerType {
  /** The container type for the issue content. */
  CONTENT = 'CONTENT',
  /** The container type for the issue context. */
  CONTEXT = 'CONTEXT',
  /** The container type for the issue hidden items. */
  HIDDEN_ITEMS = 'HIDDEN_ITEMS',
  /** The container type for the issue primary context. */
  PRIMARY = 'PRIMARY',
  /** The container type for the request in JSM projects. */
  REQUEST = 'REQUEST',
  /** The container type for the request portal in JSM projects. */
  REQUEST_PORTAL = 'REQUEST_PORTAL',
  /** The container type for the issue secondary context. */
  SECONDARY = 'SECONDARY',
}

/** Represents a collection of system container types to be fetched. */
export type JiraIssueItemSystemContainerTypeWithIdInput = {
  /** ARI of the issue. */
  issueId: Scalars['ID'];
  /** The collection of system container types. */
  systemContainerTypes: Array<JiraIssueItemSystemContainerType>;
};

/** Represents a collection of items that are held in a tab container. */
export type JiraIssueItemTabContainer = {
  __typename?: 'JiraIssueItemTabContainer';
  /** The tab container items. */
  items?: Maybe<JiraIssueItemTabContainerItemConnection>;
  /** The tab container name. */
  name?: Maybe<Scalars['String']>;
  /** The tab container ID. */
  tabContainerId: Scalars['String'];
};

/** Represents the items that can be placed in any tab container. */
export type JiraIssueItemTabContainerItem = JiraIssueItemFieldItem;

/** The connection type for `JiraIssueItemTabContainerItem`. */
export type JiraIssueItemTabContainerItemConnection = {
  __typename?: 'JiraIssueItemTabContainerItemConnection';
  /** The data for edges in the page. */
  edges?: Maybe<Array<Maybe<JiraIssueItemTabContainerItemEdge>>>;
  /**
   * Deprecated.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Please use edges instead.
   */
  nodes?: Maybe<Array<Maybe<JiraIssueItemTabContainerItem>>>;
  /** Information about the page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a `JiraIssueItemTabContainerItem` connection. */
export type JiraIssueItemTabContainerItemEdge = {
  __typename?: 'JiraIssueItemTabContainerItemEdge';
  /** The cursor to the edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueItemTabContainerItem>;
};

/**
 * Represents a single issue link containing the link id, link type and destination issue.
 *
 * For issue create, JiraIssueLink will be populated with
 * the default IssueLink types in the relatedBy field.
 * The issueLinkId and issue fields will be null.
 *
 * For issue view, JiraIssueLink will be populated with
 * the issue link data available on the issue.
 * The issue field will contain a nested JiraIssue that is atmost 1 level deep.
 * The nested JiraIssue will not contain fields that can contain further nesting.
 */
export type JiraIssueLink = {
  __typename?: 'JiraIssueLink';
  /** Global identifier for the Issue Link. */
  id?: Maybe<Scalars['ID']>;
  /** The destination Issue to which this link is connected. */
  issue?: Maybe<JiraIssue>;
  /** Identifier for the Issue Link. Can be null to represent a link not yet created */
  issueLinkId?: Maybe<Scalars['ID']>;
  /**
   * Issue link type relation through which the source issue is connected to the
   * destination issue. Source Issue is the Issue being created/queried.
   */
  relatedBy?: Maybe<JiraIssueLinkTypeRelation>;
};

/** The connection type for JiraIssueLink. */
export type JiraIssueLinkConnection = {
  __typename?: 'JiraIssueLinkConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraIssueLinkEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraIssueLink matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents the possible linking directions between issues. */
export enum JiraIssueLinkDirection {
  /** Going from the other issue to this issue. */
  INWARD = 'INWARD',
  /** Going from this issue to the other issue. */
  OUTWARD = 'OUTWARD',
}

/** An edge in a JiraIssueLink connection. */
export type JiraIssueLinkEdge = {
  __typename?: 'JiraIssueLinkEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueLink>;
};

/** Represents linked issues field on a Jira Issue. */
export type JiraIssueLinkField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraIssueLinkField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /**
     * Paginated list of issue links available on the issue. TODO: Change name to issueLinks once the above array is removed.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    issueLinkConnection?: Maybe<JiraIssueLinkConnection>;
    /**
     * Represents the different issue link type relations/desc which can be mapped/linked to the issue in context.
     * Issue in context is the one which is being created/ which is being queried.
     */
    issueLinkTypeRelations?: Maybe<JiraIssueLinkTypeRelationConnection>;
    /** Represents all the issue links defined on a Jira Issue. Should be deprecated and replaced with issueLinksConnection. */
    issueLinks?: Maybe<Array<Maybe<JiraIssueLink>>>;
    /** Paginated list of issues which can be related/linked with above issueLinkTypeRelations. */
    issues?: Maybe<JiraIssueConnection>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to list all available issues which can be related/linked with above issueLinkTypeRelations. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents linked issues field on a Jira Issue. */
export type JiraIssueLinkFieldIssueLinkConnectionArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents linked issues field on a Jira Issue. */
export type JiraIssueLinkFieldIssueLinkTypeRelationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents linked issues field on a Jira Issue. */
export type JiraIssueLinkFieldIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

export type JiraIssueLinkTypeRelation = Node & {
  __typename?: 'JiraIssueLinkTypeRelation';
  /** Represents the direction of issue link type. E.g. INWARD, OUTWARD */
  direction?: Maybe<JiraIssueLinkDirection>;
  /** Global identifier for the Issue Link Type Relation. */
  id: Scalars['ID'];
  /** Represents the IssueLinkType id to which this type belongs to. */
  linkTypeId: Scalars['String'];
  /** Display name of IssueLinkType to which this relation belongs to. E.g. Blocks, Duplicate, Cloners */
  linkTypeName?: Maybe<Scalars['String']>;
  /**
   * Represents the description of the relation by which this link is identified.
   * This can be the inward or outward description of an IssueLinkType.
   * E.g. blocks, is blocked by, duplicates, is duplicated by, clones, is cloned by.
   */
  relationName?: Maybe<Scalars['String']>;
};

/** The connection type for JiraIssueLinkTypeRelation. */
export type JiraIssueLinkTypeRelationConnection = {
  __typename?: 'JiraIssueLinkTypeRelationConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraIssueLinkTypeRelationEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraIssueLinkTypeRelation matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraIssueLinkType connection. */
export type JiraIssueLinkTypeRelationEdge = {
  __typename?: 'JiraIssueLinkTypeRelationEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraIssueLinkTypeRelation>;
};

/** Summary of the Pull Requests attached to the issue */
export type JiraIssuePullRequestDevSummary = {
  __typename?: 'JiraIssuePullRequestDevSummary';
  /** Total number of Pull Requests for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
  /** Whether the Pull Requests for the given state are open or not */
  open?: Maybe<Scalars['Boolean']>;
  /** State of the Pull Requests in the summary */
  state?: Maybe<JiraPullRequestState>;
  /** Number of Pull Requests for the state */
  stateCount?: Maybe<Scalars['Int']>;
};

/** Container for the summary of the Pull Requests attached to the issue */
export type JiraIssuePullRequestDevSummaryContainer = {
  __typename?: 'JiraIssuePullRequestDevSummaryContainer';
  /** The actual summary of the Pull Requests attached to the issue */
  overall?: Maybe<JiraIssuePullRequestDevSummary>;
  /** Count of Pull Requests aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

/** Represents issue restriction field on an issue for next gen projects. */
export type JiraIssueRestrictionField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraIssueRestrictionField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Paginated list of roles available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    roles?: Maybe<JiraRoleConnection>;
    /** Search URL to fetch all the roles options for the fields on an issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The roles available on the Issue or default roles configured for the field. */
    selectedRoles?: Maybe<Array<Maybe<JiraRole>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents issue restriction field on an issue for next gen projects. */
export type JiraIssueRestrictionFieldRolesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Summary of the Reviews attached to the issue */
export type JiraIssueReviewDevSummary = {
  __typename?: 'JiraIssueReviewDevSummary';
  /** Total number of Reviews for the issue */
  count?: Maybe<Scalars['Int']>;
  /** Date at which this summary was last updated */
  lastUpdated?: Maybe<Scalars['DateTime']>;
  /** State of the Reviews in the summary */
  state?: Maybe<JiraReviewState>;
  /** Number of Reviews for the state */
  stateCount?: Maybe<Scalars['Int']>;
};

/** Container for the summary of the Reviews attached to the issue */
export type JiraIssueReviewDevSummaryContainer = {
  __typename?: 'JiraIssueReviewDevSummaryContainer';
  /** The actual summary of the Reviews attached to the issue */
  overall?: Maybe<JiraIssueReviewDevSummary>;
  /** Count of Reviews aggregated per provider */
  summaryByProvider?: Maybe<Array<JiraIssueDevSummaryByProvider>>;
};

export type JiraIssueType = Node & {
  __typename?: 'JiraIssueType';
  avatar?: Maybe<JiraAvatar>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraIssueTypeConnection = {
  __typename?: 'JiraIssueTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraIssueTypeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type JiraIssueTypeEdge = {
  __typename?: 'JiraIssueTypeEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String'];
  /** The item at the end of the edge */
  node?: Maybe<JiraIssueType>;
};

/** Represents an issue type field on a Jira Issue. */
export type JiraIssueTypeField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraIssueTypeField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /**
     * "
     * The issue type available on the Issue or default issue type configured for the field.
     */
    issueType?: Maybe<JiraIssueType>;
    /**
     * List of issuetype options available to be selected for the field.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    issueTypes?: Maybe<JiraIssueTypeConnection>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
  };

/** Represents an issue type field on a Jira Issue. */
export type JiraIssueTypeFieldIssueTypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/**
 * The autocomplete types available for Jira fields in the context of the Jira Query Language.
 *
 * This enum also describes which fields have field-value support from this schema.
 */
export enum JiraJqlAutocompleteType {
  /** The Jira component field JQL autocomplete type. */
  COMPONENT = 'COMPONENT',
  /** The Jira group field JQL autocomplete type. */
  GROUP = 'GROUP',
  /** The Jira issue field JQL autocomplete type. */
  ISSUE = 'ISSUE',
  /** The Jira issue field type JQL autocomplete type. */
  ISSUETYPE = 'ISSUETYPE',
  /** No autocomplete support. */
  NONE = 'NONE',
  /** The Jira priority field JQL autocomplete type. */
  PRIORITY = 'PRIORITY',
  /** The Jira project field JQL autocomplete type. */
  PROJECT = 'PROJECT',
  /** The Jira sprint field JQL autocomplete type. */
  SPRINT = 'SPRINT',
  /** The Jira status field JQL autocomplete type. */
  STATUS = 'STATUS',
  /** The Jira status category field JQL autocomplete type. */
  STATUSCATEGORY = 'STATUSCATEGORY',
  /** The Jira user field JQL autocomplete type. */
  USER = 'USER',
  /** The Jira version field JQL autocomplete type. */
  VERSION = 'VERSION',
}

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilder = {
  __typename?: 'JiraJqlBuilder';
  /** Retrieves the field-values for the Jira cascading options field. */
  cascadingSelectOptions?: Maybe<JiraJqlOptionFieldValueConnection>;
  /**
   * Retrieves a connection of field-values for a specified Jira Field.
   *
   * E.g. A given Jira checkbox field may have the following field-values: `Option 1`, `Option 2` and `Option 3`.
   */
  fieldValues?: Maybe<JiraJqlFieldValueConnection>;
  /**
   * Retrieves a connection of searchable Jira JQL fields.
   *
   * In a given JQL, fields will precede operators and operators precede field-values/ functions.
   *
   * E.g. `${FIELD} ${OPERATOR} ${FUNCTION}()` => `Assignee = currentUser()`
   */
  fields?: Maybe<JiraJqlFieldConnectionResult>;
  /** A list of available JQL functions. */
  functions: Array<JiraJqlFunction>;
  /** Hydrates the JQL fields and field-values of a given JQL query. */
  hydrateJqlQuery?: Maybe<JiraJqlHydratedQueryResult>;
  /**
   * Hydrates the JQL fields and field-values of a filter corresponding to the provided filter ID.
   *
   * The id provided MUST be in ARI format.
   *
   * This query will error if the id parameter is not in ARI format, does not pass
   * validation or does not correspond to a JiraFilter.
   */
  hydrateJqlQueryForFilter?: Maybe<JiraJqlHydratedQueryResult>;
  /** Retrieves the field-values for the Jira issueType field. */
  issueTypes?: Maybe<JiraJqlIssueTypes>;
  /**
   * The last used JQL builder search mode.
   *
   * This can either be the Basic or JQL search mode.
   */
  lastUsedMode?: Maybe<JiraJqlBuilderMode>;
  /** Retrieves a connection of Jira fields recently used in JQL searches. */
  recentFields?: Maybe<JiraJqlFieldConnectionResult>;
  /** Retrieves a connection of projects that have recently been viewed by the current user. */
  recentlyUsedProjects?: Maybe<JiraJqlProjectFieldValueConnection>;
  /** Retrieves a connection of sprints that have recently been viewed by the current user. */
  recentlyUsedSprints?: Maybe<JiraJqlSprintFieldValueConnection>;
  /** Retrieves a connection of users recently used in Jira user fields. */
  recentlyUsedUsers?: Maybe<JiraJqlUserFieldValueConnection>;
  /**
   * Retrieves a connection of suggested groups.
   *
   * Groups are suggested when the current user is a member.
   */
  suggestedGroups?: Maybe<JiraJqlGroupFieldValueConnection>;
  /** Retrieves the field-values for the Jira version field. */
  versions?: Maybe<JiraJqlVersions>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderCascadingSelectOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filter: JiraCascadingSelectOptionsFilter;
  first?: Maybe<Scalars['Int']>;
  jqlContext?: Maybe<Scalars['String']>;
  jqlTerm: Scalars['String'];
  last?: Maybe<Scalars['Int']>;
  searchString?: Maybe<Scalars['String']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderFieldValuesArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  jqlContext?: Maybe<Scalars['String']>;
  jqlTerm: Scalars['String'];
  searchString?: Maybe<Scalars['String']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderFieldsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  forClause?: Maybe<JiraJqlClauseType>;
  jqlContext?: Maybe<Scalars['String']>;
  searchString?: Maybe<Scalars['String']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderHydrateJqlQueryArgs = {
  query?: Maybe<Scalars['String']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderHydrateJqlQueryForFilterArgs = {
  id: Scalars['ID'];
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderIssueTypesArgs = {
  jqlContext?: Maybe<Scalars['String']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderRecentFieldsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  forClause?: Maybe<JiraJqlClauseType>;
  jqlContext?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderRecentlyUsedProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderRecentlyUsedSprintsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  jqlContext?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderRecentlyUsedUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderSuggestedGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * Encapsulates queries and fields necessary to power the JQL builder.
 *
 * It also exposes generic JQL capabilities that can be leveraged to power other experiences.
 */
export type JiraJqlBuilderVersionsArgs = {
  jqlContext?: Maybe<Scalars['String']>;
  jqlTerm: Scalars['String'];
};

/** The modes the JQL builder can be displayed and used in. */
export enum JiraJqlBuilderMode {
  /**
   * The basic mode, allows queries to be built and executed via the JQL basic editor.
   *
   * This mode allows users to easily construct JQL queries by interacting with the UI.
   */
  BASIC = 'BASIC',
  /**
   * The JQL mode, allows queries to be built and executed via the JQL advanced editor.
   *
   * This mode allows users to manually type and construct complex JQL queries.
   */
  JQL = 'JQL',
}

/** Represents a field-value for a JQL cascading option field. */
export type JiraJqlCascadingOptionFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlCascadingOptionFieldValue';
  /** The user-friendly name for a cascading option JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira cascading option field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira JQL parent option associated with this JQL field value. */
  parentOption?: Maybe<JiraJqlOptionFieldValue>;
};

/** The types of JQL clauses supported by Jira. */
export enum JiraJqlClauseType {
  /** This denotes both WHERE and ORDER_BY. */
  ANY = 'ANY',
  /** This corresponds to fields used to sort Jira Issues. */
  ORDER_BY = 'ORDER_BY',
  /** This corresponds to jql fields used as filter criteria of Jira issues. */
  WHERE = 'WHERE',
}

/** Represents a field-value for a JQL component field. */
export type JiraJqlComponentFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlComponentFieldValue';
  /** The user-friendly name for a component JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira component field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** The representation of a Jira field within the context of the Jira Query Language. */
export type JiraJqlField = {
  __typename?: 'JiraJqlField';
  /** The JQL clause types that can be used with this field. */
  allowedClauseTypes: Array<JiraJqlClauseType>;
  /** Defines how the field-values should be shown for a field in the JQL-Builder's JQL mode. */
  autoCompleteTemplate?: Maybe<JiraJqlAutocompleteType>;
  /**
   * The data types handled by the current field.
   * These can be used to identify which JQL functions are supported.
   */
  dataTypes?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The user-friendly name for the current field, to be displayed in the UI. */
  displayName?: Maybe<Scalars['String']>;
  /**
   * The field-type of the current field.
   * E.g. `Short Text`, `Number`, `Version Picker`, `Team` etc.
   * Important note: This information only exists for collapsed fields.
   */
  jqlFieldType?: Maybe<JiraJqlFieldType>;
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira JQL field.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['ID'];
  /** The JQL operators that can be used with this field. */
  operators: Array<JiraJqlOperator>;
  /** Defines how a field should be represented in the basic search mode of the JQL builder. */
  searchTemplate?: Maybe<JiraJqlSearchTemplate>;
  /** Determines whether or not the current field should be accessible in the current search context. */
  shouldShowInContext?: Maybe<Scalars['Boolean']>;
};

/** Represents a connection of Jira JQL fields. */
export type JiraJqlFieldConnection = {
  __typename?: 'JiraJqlFieldConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlFieldEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlFields matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** A union of a Jira JQL field connection and a GraphQL query error. */
export type JiraJqlFieldConnectionResult = JiraJqlFieldConnection | QueryError;

/** Represents a Jira JQL field edge. */
export type JiraJqlFieldEdge = {
  __typename?: 'JiraJqlFieldEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlField>;
};

/**
 * The representation of a Jira JQL field-type in the context of the Jira Query Language.
 *
 * E.g. `Short Text`, `Number`, `Version Picker`, `Team` etc.
 *
 * Important note: This information only exists for collapsed fields.
 */
export type JiraJqlFieldType = {
  __typename?: 'JiraJqlFieldType';
  /** The translated name of the field type. */
  displayName: Scalars['String'];
  /** The non-translated name of the field type. */
  jqlTerm: Scalars['String'];
};

/** A generic interface for JQL fields in Jira. */
export type JiraJqlFieldValue = {
  /** The user-friendly name for a component JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira JQL field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** Represents a connection of field-values for a JQL field. */
export type JiraJqlFieldValueConnection = {
  __typename?: 'JiraJqlFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL field. */
export type JiraJqlFieldValueEdge = {
  __typename?: 'JiraJqlFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlFieldValue>;
};

/**
 * A function in JQL appears as a word followed by parentheses, which may contain one or more explicit values or Jira fields.
 *
 * In a clause, a function is preceded by an operator, which in turn is preceded by a field.
 *
 * A function performs a calculation on either specific Jira data or the function's content in parentheses,
 * such that only true results are retrieved by the function, and then again by the clause in which the function is used.
 *
 * E.g. `approved()`, `currentUser()`, `endOfMonth()` etc.
 */
export type JiraJqlFunction = {
  __typename?: 'JiraJqlFunction';
  /**
   * The data types that this function handles and creates values for.
   *
   * This allows consumers to infer information on the JiraJqlField type such as which functions are supported.
   */
  dataTypes: Array<Scalars['String']>;
  /** The user-friendly name for the function, to be displayed in the UI. */
  displayName?: Maybe<Scalars['String']>;
  /**
   * Indicates whether or not the function is meant to be used with IN or NOT IN operators, that is,
   * if the function should be viewed as returning a list.
   *
   * The method should return false when it is to be used with the other relational operators (e.g. =, !=, <, >, ...)
   * that only work with single values.
   */
  isList?: Maybe<Scalars['Boolean']>;
  /** A JQL-function safe encoded name. This value will not be encoded if the displayName is already safe. */
  value?: Maybe<Scalars['String']>;
};

/** Represents a field-value for a JQL group field. */
export type JiraJqlGroupFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlGroupFieldValue';
  /** The user-friendly name for a group JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /** The Jira group associated with this JQL field value. */
  group: JiraGroup;
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira group field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it into a query (e.g. wrap it in "" )
   */
  jqlTerm: Scalars['String'];
};

/** Represents a connection of field-values for a JQL group field. */
export type JiraJqlGroupFieldValueConnection = {
  __typename?: 'JiraJqlGroupFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlGroupFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlGroupFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL group field. */
export type JiraJqlGroupFieldValueEdge = {
  __typename?: 'JiraJqlGroupFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlGroupFieldValue>;
};

/** Represents a JQL query with hydrated fields and field-values. */
export type JiraJqlHydratedQuery = {
  __typename?: 'JiraJqlHydratedQuery';
  /** A list of hydrated fields from the provided JQL. */
  fields: Array<JiraJqlQueryHydratedFieldResult>;
  /** The JQL query to be hydrated. */
  jql?: Maybe<Scalars['String']>;
};

/** A union of a Jira JQL hydrated query and a GraphQL query error. */
export type JiraJqlHydratedQueryResult = JiraJqlHydratedQuery | QueryError;

/** Represents a field-value for a JQL Issue field. */
export type JiraJqlIssueFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlIssueFieldValue';
  /** The user-friendly name for an issue JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /** The Jira issue associated with this JQL field value. */
  issue: JiraIssue;
  /**
   * An identifier that a client should use in a JQL query when its referring to a field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** Represents a field-value for a JQL issue type field. */
export type JiraJqlIssueTypeFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlIssueTypeFieldValue';
  /** The user-friendly name for an issue type JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /** The Jira issue types associated with this JQL field value. */
  issueTypes: Array<JiraIssueType>;
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira issue type field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** Represents a connection of field-values for a JQL issue type field. */
export type JiraJqlIssueTypeFieldValueConnection = {
  __typename?: 'JiraJqlIssueTypeFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlIssueTypeFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlIssueTypeFieldValues matching the criteria */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL issue type field. */
export type JiraJqlIssueTypeFieldValueEdge = {
  __typename?: 'JiraJqlIssueTypeFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlIssueTypeFieldValue>;
};

/** A variation of the fieldValues query for retrieving specifically Jira issue type field-values. */
export type JiraJqlIssueTypes = {
  __typename?: 'JiraJqlIssueTypes';
  /**
   * Retrieves top-level issue types that encapsulate all others.
   *
   * E.g. The `Epic` issue type in company-managed projects.
   */
  aboveBaseLevel?: Maybe<JiraJqlIssueTypeFieldValueConnection>;
  /**
   * Retrieves mid-level issue types.
   *
   * E.g. The `Bug`, `Story` and `Task` issue type in company-managed projects.
   */
  baseLevel?: Maybe<JiraJqlIssueTypeFieldValueConnection>;
  /**
   * Retrieves the lowest level issue types.
   *
   * E.g. The `Subtask` issue type in company-managed projects.
   */
  belowBaseLevel?: Maybe<JiraJqlIssueTypeFieldValueConnection>;
};

/** A variation of the fieldValues query for retrieving specifically Jira issue type field-values. */
export type JiraJqlIssueTypesAboveBaseLevelArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A variation of the fieldValues query for retrieving specifically Jira issue type field-values. */
export type JiraJqlIssueTypesBaseLevelArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A variation of the fieldValues query for retrieving specifically Jira issue type field-values. */
export type JiraJqlIssueTypesBelowBaseLevelArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents a field-value for a JQL label field. */
export type JiraJqlLabelFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlLabelFieldValue';
  /** The user-friendly name for a label JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira label field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira label associated with this JQL field value. */
  label?: Maybe<JiraLabel>;
};

/**
 * The types of JQL operators supported by Jira.
 *
 * An operator in JQL is one or more symbols or words,which compares the value of a
 * field on its left with one or more values (or functions) on its right,
 * such that only true results are retrieved by the clause.
 *
 * For more information on JQL operators please visit: https://support.atlassian.com/jira-software-cloud/docs/advanced-search-reference-jql-operators.
 */
export enum JiraJqlOperator {
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  CHANGED = 'CHANGED',
  /** The `CHANGED` operator is used to find issues that have a value that had changed for the specified field. */
  CONTAINS = 'CONTAINS',
  /** The `=` operator is used to search for issues where the value of the specified field exactly matches the specified value. */
  EQUALS = 'EQUALS',
  /** The `>` operator is used to search for issues where the value of the specified field is greater than the specified value. */
  GREATER_THAN = 'GREATER_THAN',
  /**
   * The `>=` operator is used to search for issues where the value of the
   * specified field is greater than or equal to the specified value.
   */
  GREATER_THAN_OR_EQUAL = 'GREATER_THAN_OR_EQUAL',
  /** The `IN` operator is used to search for issues where the value of the specified field is one of multiple specified values. */
  IN = 'IN',
  /**
   * The `IS` operator can only be used with EMPTY or NULL. That is, it is used to
   * search for issues where the specified field has no value.
   */
  IS = 'IS',
  /**
   * The `IS NOT` operator can only be used with EMPTY or NULL. That is, it is used
   * to search for issues where the specified field has a value.
   */
  IS_NOT = 'IS_NOT',
  /** The `<` operator is used to search for issues where the value of the specified field is less than the specified value. */
  LESS_THAN = 'LESS_THAN',
  /**
   * The `<=` operator is used to search for issues where the value of the
   * specified field is less than or equal to than the specified value.
   */
  LESS_THAN_OR_EQUAL = 'LESS_THAN_OR_EQUAL',
  /**
   * The `!~` operator is used to search for issues where the value of the
   * specified field is not a "fuzzy" match for the specified value.
   */
  NOT_CONTAINS = 'NOT_CONTAINS',
  /** The `!=` operator is used to search for issues where the value of the specified field does not match the specified value. */
  NOT_EQUALS = 'NOT_EQUALS',
  /**
   * The `NOT IN` operator is used to search for issues where the value of the
   * specified field is not one of multiple specified values.
   */
  NOT_IN = 'NOT_IN',
  /**
   * The `WAS` operator is used to find issues that currently have or previously
   * had the specified value for the specified field.
   */
  WAS = 'WAS',
  /**
   * The `WAS IN` operator is used to find issues that currently have or previously
   * had any of multiple specified values for the specified field.
   */
  WAS_IN = 'WAS_IN',
  /** The `WAS NOT` operator is used to find issues that have never had the specified value for the specified field. */
  WAS_NOT = 'WAS_NOT',
  /**
   * The `WAS NOT IN` operator is used to search for issues where the value of the
   * specified field has never been one of multiple specified values.
   */
  WAS_NOT_IN = 'WAS_NOT_IN',
}

/** Represents a field-value for a JQL option field. */
export type JiraJqlOptionFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlOptionFieldValue';
  /** The user-friendly name for an option JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira option field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** Represents a connection of field-values for a JQL option field. */
export type JiraJqlOptionFieldValueConnection = {
  __typename?: 'JiraJqlOptionFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlOptionFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlOptionFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL option field. */
export type JiraJqlOptionFieldValueEdge = {
  __typename?: 'JiraJqlOptionFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlOptionFieldValue>;
};

/** Represents a field-value for a JQL priority field. */
export type JiraJqlPriorityFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlPriorityFieldValue';
  /** The user-friendly name for a priority JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira priority field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira property associated with this JQL field value. */
  priority: JiraPriority;
};

/** Represents a field-value for a JQL project field. */
export type JiraJqlProjectFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlProjectFieldValue';
  /** The user-friendly name for a project JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira project field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira project associated with this JQL field value. */
  project: JiraProject;
};

/** Represents a connection of field-values for a JQL project field. */
export type JiraJqlProjectFieldValueConnection = {
  __typename?: 'JiraJqlProjectFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlProjectFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlProjectFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL project field. */
export type JiraJqlProjectFieldValueEdge = {
  __typename?: 'JiraJqlProjectFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlProjectFieldValue>;
};

/** Represents an error for a JQL query hydration. */
export type JiraJqlQueryHydratedError = {
  __typename?: 'JiraJqlQueryHydratedError';
  /** The error that occurred whilst hydrating the Jira JQL field. */
  error?: Maybe<QueryError>;
  /** An identifier for the hydrated Jira JQL field where the error occurred. */
  jqlTerm: Scalars['String'];
};

/** Represents a hydrated field for a JQL query. */
export type JiraJqlQueryHydratedField = {
  __typename?: 'JiraJqlQueryHydratedField';
  /** The Jira JQL field associated with the hydrated field. */
  field: JiraJqlField;
  /** An identifier for the hydrated Jira JQL field. */
  jqlTerm: Scalars['String'];
  /** The hydrated value results. */
  values: Array<Maybe<JiraJqlQueryHydratedValueResult>>;
};

/** A union of a JQL query hydrated field and a GraphQL query error. */
export type JiraJqlQueryHydratedFieldResult =
  | JiraJqlQueryHydratedError
  | JiraJqlQueryHydratedField;

/** Represents a hydrated field-value for a given field in the JQL query. */
export type JiraJqlQueryHydratedValue = {
  __typename?: 'JiraJqlQueryHydratedValue';
  /** An identifier for the hydrated Jira JQL field value. */
  jqlTerm: Scalars['String'];
  /** The hydrated field values. */
  values: Array<Maybe<JiraJqlFieldValue>>;
};

/** A union of a JQL query hydrated field-value and a GraphQL query error. */
export type JiraJqlQueryHydratedValueResult =
  | JiraJqlQueryHydratedError
  | JiraJqlQueryHydratedValue;

/** Represents a field-value for a JQL resolution field. */
export type JiraJqlResolutionFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlResolutionFieldValue';
  /** The user-friendly name for a resolution JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira resolution field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira resolution associated with this JQL field value. */
  resolution?: Maybe<JiraResolution>;
};

/** The representation of a Jira field in the basic search mode of the JQL builder. */
export type JiraJqlSearchTemplate = {
  __typename?: 'JiraJqlSearchTemplate';
  key?: Maybe<Scalars['String']>;
};

/** Represents a field-value for a JQL sprint field. */
export type JiraJqlSprintFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlSprintFieldValue';
  /** The user-friendly name for a sprint JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira sprint field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira sprint associated with this JQL field value. */
  sprint: JiraSprint;
};

/** Represents a connection of field-values for a JQL sprint field. */
export type JiraJqlSprintFieldValueConnection = {
  __typename?: 'JiraJqlSprintFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlSprintFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlSprintFieldValues matching the criteria */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL sprint field. */
export type JiraJqlSprintFieldValueEdge = {
  __typename?: 'JiraJqlSprintFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlSprintFieldValue>;
};

/** Represents a field-value for a JQL status category field. */
export type JiraJqlStatusCategoryFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlStatusCategoryFieldValue';
  /** The user-friendly name for a status category JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira status category field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira status category associated with this JQL field value. */
  statusCategory: JiraStatusCategory;
};

/** Represents a field-value for a JQL status field. */
export type JiraJqlStatusFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlStatusFieldValue';
  /** The user-friendly name for a status JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira status field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The Jira status category associated with this JQL field value. */
  statusCategory: JiraStatusCategory;
};

/** Represents a field-value for a JQL user field. */
export type JiraJqlUserFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlUserFieldValue';
  /** The user-friendly name for a user JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira user field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
  /** The user associated with this JQL field value. */
  user: User;
};

/** Represents a connection of field-values for a JQL user field. */
export type JiraJqlUserFieldValueConnection = {
  __typename?: 'JiraJqlUserFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlUserFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlUserFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL user field. */
export type JiraJqlUserFieldValueEdge = {
  __typename?: 'JiraJqlUserFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlUserFieldValue>;
};

/** Represents a field-value for a JQL version field. */
export type JiraJqlVersionFieldValue = JiraJqlFieldValue & {
  __typename?: 'JiraJqlVersionFieldValue';
  /** The user-friendly name for a version JQL field value, to be displayed in the UI. */
  displayName: Scalars['String'];
  /**
   * An identifier that a client should use in a JQL query when its referring to a Jira version field-value.
   *
   * Important note: this jqlTerm could require proper escaping before placing it  into a query (e.g. wrap it in "" ).
   */
  jqlTerm: Scalars['String'];
};

/** Represents a connection of field-values for a JQL version field. */
export type JiraJqlVersionFieldValueConnection = {
  __typename?: 'JiraJqlVersionFieldValueConnection';
  /** The data for the edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraJqlVersionFieldValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of JiraJqlVersionFieldValues matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** Represents a field-value edge for a JQL version field. */
export type JiraJqlVersionFieldValueEdge = {
  __typename?: 'JiraJqlVersionFieldValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraJqlVersionFieldValue>;
};

/**
 * A variation of the fieldValues query for retrieving specifically Jira version field-values.
 *
 * This type provides the capability to retrieve connections of released, unreleased and archived versions.
 *
 * Important note: that released and unreleased versions can be archived and vice versa.
 */
export type JiraJqlVersions = {
  __typename?: 'JiraJqlVersions';
  /** Retrieves a connection of archived versions. */
  archived?: Maybe<JiraJqlVersionFieldValueConnection>;
  /** Retrieves a connection of released versions. */
  released?: Maybe<JiraJqlVersionFieldValueConnection>;
  /** Retrieves a connection of unreleased versions. */
  unreleased?: Maybe<JiraJqlVersionFieldValueConnection>;
};

/**
 * A variation of the fieldValues query for retrieving specifically Jira version field-values.
 *
 * This type provides the capability to retrieve connections of released, unreleased and archived versions.
 *
 * Important note: that released and unreleased versions can be archived and vice versa.
 */
export type JiraJqlVersionsArchivedArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * A variation of the fieldValues query for retrieving specifically Jira version field-values.
 *
 * This type provides the capability to retrieve connections of released, unreleased and archived versions.
 *
 * Important note: that released and unreleased versions can be archived and vice versa.
 */
export type JiraJqlVersionsReleasedArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includeArchived?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
};

/**
 * A variation of the fieldValues query for retrieving specifically Jira version field-values.
 *
 * This type provides the capability to retrieve connections of released, unreleased and archived versions.
 *
 * Important note: that released and unreleased versions can be archived and vice versa.
 */
export type JiraJqlVersionsUnreleasedArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includeArchived?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents the label of a custom label field. */
export type JiraLabel = {
  __typename?: 'JiraLabel';
  /**
   * The identifier of the label.
   * Can be null when label is not yet created or label was returned without providing an Issue id.
   */
  labelId?: Maybe<Scalars['String']>;
  /** The name of the label. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for JiraLabel. */
export type JiraLabelConnection = {
  __typename?: 'JiraLabelConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraLabelEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a Jiralabel connection. */
export type JiraLabelEdge = {
  __typename?: 'JiraLabelEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraLabel>;
};

/** Represents a labels field on a Jira Issue. Both system & custom field can be represented by this type. */
export type JiraLabelsField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraLabelsField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /**
     * Paginated list of label options for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    labels?: Maybe<JiraLabelConnection>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available label options on a field or an Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The labels available on the Issue or default labels configured for the field. */
    selectedLabels?: Maybe<Array<Maybe<JiraLabel>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a labels field on a Jira Issue. Both system & custom field can be represented by this type. */
export type JiraLabelsFieldLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents a media context used for file uploads. */
export type JiraMediaContext = {
  __typename?: 'JiraMediaContext';
  /** Contains the token information for uploading a media content. */
  uploadToken?: Maybe<JiraMediaUploadTokenResult>;
};

/** Contains the information needed for uploading a media content in jira on issue create/view screens. */
export type JiraMediaUploadToken = {
  __typename?: 'JiraMediaUploadToken';
  /** Registered client id of media API. */
  clientId?: Maybe<Scalars['String']>;
  /** Endpoint where the media content will be uploaded. */
  endpointUrl?: Maybe<Scalars['URL']>;
  /**
   * The collection in which to put the new files.
   * It can be user-scoped (such as upload-user-collection-*)
   * or project scoped (such as upload-project-*).
   */
  targetCollection?: Maybe<Scalars['String']>;
  /** token string value which can be used with Media API requests. */
  token?: Maybe<Scalars['String']>;
  /** Represents the duration (in minutes) for which token will be valid. */
  tokenDurationInMin?: Maybe<Scalars['Int']>;
};

/** Contains either the successful fetched media token information or an error. */
export type JiraMediaUploadTokenResult = JiraMediaUploadToken | QueryError;

/** Represents a multiple group picker field on a Jira Issue. */
export type JiraMultipleGroupPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraMultipleGroupPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of group options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    groups?: Maybe<JiraGroupConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch all group pickers of the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Value or default values configured for the field or values available on the issue. */
    selectedGroups?: Maybe<Array<Maybe<JiraGroup>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a multiple group picker field on a Jira Issue. */
export type JiraMultipleGroupPickerFieldGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents the multi-select field on a Jira Issue. */
export type JiraMultipleSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraMultipleSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch all the teams options for the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The options available on the Issue or default options configured for the field. */
    selectedFieldOptions?: Maybe<Array<Maybe<JiraOption>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the multi-select field on a Jira Issue. */
export type JiraMultipleSelectFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a multi select user picker field on a Jira Issue. E.g. custom user picker */
export type JiraMultipleSelectUserPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraMultipleSelectUserPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the entity. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The users available on the Issue or default users configured for the field. */
    selectedUsers?: Maybe<Array<Maybe<User>>>;
    /** Field type key of the field. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a multi select user picker field on a Jira Issue. E.g. custom user picker */
export type JiraMultipleSelectUserPickerFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents a multi version picker field on a Jira Issue. E.g. fixVersions and multi version custom field. */
export type JiraMultipleVersionPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraMultipleVersionPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The versions available on the Issue or default versions configured for the field. */
    selectedVersions?: Maybe<Array<Maybe<JiraVersion>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of versions options for the field or on a Jira Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    versions?: Maybe<JiraVersionConnection>;
  };

/** Represents a multi version picker field on a Jira Issue. E.g. fixVersions and multi version custom field. */
export type JiraMultipleVersionPickerFieldVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

export type JiraMutation = {
  __typename?: 'JiraMutation';
  /**
   * The mutation operation to add one or more new permission grants to the given permission scheme.
   * The operation takes mandatory permission scheme ID.
   * The limit on the new permission grants can be added is set to 5.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  addPermissionSchemeGrants?: Maybe<JiraPermissionSchemeAddGrantPayload>;
  /**
   * Container for all DevOps related mutations in Jira
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraDevOps` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  devOps?: Maybe<JiraDevOpsMutation>;
  /**
   * The mutation operation to remove one or more existing permission scheme grants in the given permission scheme.
   * The operation takes mandatory permission scheme ID.
   * The limit on the new permission grants can be removed is set to 5.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  removePermissionSchemeGrants?: Maybe<JiraPermissionSchemeRemoveGrantPayload>;
};

export type JiraMutationAddPermissionSchemeGrantsArgs = {
  input: JiraPermissionSchemeAddGrantInput;
};

export type JiraMutationRemovePermissionSchemeGrantsArgs = {
  input: JiraPermissionSchemeRemoveGrantInput;
};

/** Represents a number field on a Jira Issue. E.g. float, story points. */
export type JiraNumberField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraNumberField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The number available on the Issue or default number configured for the field. */
    number?: Maybe<Scalars['Float']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a single option value in a select operation. */
export type JiraOption = Node & {
  __typename?: 'JiraOption';
  /** Global Identifier of the option. */
  id: Scalars['ID'];
  /** Whether or not the option has been disabled by the user. Disabled options are typically not accessible in the UI. */
  isDisabled?: Maybe<Scalars['Boolean']>;
  /** Identifier of the option. */
  optionId: Scalars['String'];
  /** Value of the option. */
  value?: Maybe<Scalars['String']>;
};

/** The connection type for JiraOption. */
export type JiraOptionConnection = {
  __typename?: 'JiraOptionConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraOptionEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraOption connection. */
export type JiraOptionEdge = {
  __typename?: 'JiraOptionEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraOption>;
};

/** The input type for opting out of the Not Connected state in the DevOpsPanel */
export type JiraOptoutDevOpsIssuePanelNotConnectedInput = {
  /** Cloud ID of the tenant this change is applied to */
  cloudId: Scalars['ID'];
};

/** The response payload for opting out of the Not Connected state in the DevOpsPanel */
export type JiraOptoutDevOpsIssuePanelNotConnectedPayload = Payload & {
  __typename?: 'JiraOptoutDevOpsIssuePanelNotConnectedPayload';
  /** The errors field represents additional mutation error information if exists. */
  errors?: Maybe<Array<MutationError>>;
  /** The success indicator saying whether mutation operation was successful as a whole or not. */
  success: Scalars['Boolean'];
};

export type JiraOrderDirection = {
  id?: Maybe<Scalars['ID']>;
};

/** Represents Parent field on a Jira Issue. E.g. JSW Parent, JPO Parent (to be unified). */
export type JiraParentIssueField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraParentIssueField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The parent available on the Issue or default parent configured for the field. */
    parentIssue?: Maybe<JiraIssue>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a people picker field on a Jira Issue. */
export type JiraPeopleField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraPeopleField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Whether the field is configured to act as single/multi select user(s) field. */
    isMulti?: Maybe<Scalars['Boolean']>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The people available on the Issue or default people configured for the field. */
    selectedUsers?: Maybe<Array<Maybe<User>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a people picker field on a Jira Issue. */
export type JiraPeopleFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/**
 * The JiraPermissionGrantHolder represents an association between project permission information and
 * a bounded list of one or more permission grant.
 * A permission grant holds association between grant type and a paginated list of grant values.
 */
export type JiraPermissionGrantHolder = {
  __typename?: 'JiraPermissionGrantHolder';
  /** A bounded list of jira permission grant. */
  grants?: Maybe<Array<JiraPermissionGrants>>;
  /** The basic information about the project permission. */
  permission: JiraProjectPermission;
};

/**
 * The JiraPermissionGrants represents an association between grant type information and a bounded list of one or more grant
 * values associated with given grant type.
 * Each grant value has grant type specific information.
 * For example, PROJECT_ROLE grant type value contains project role ID in ARI format and role specific details.
 */
export type JiraPermissionGrants = {
  __typename?: 'JiraPermissionGrants';
  /** The grant type information includes key and display name. */
  grantType: JiraGrantTypeKey;
  /** A bounded list of grant values. Each grant value has grant type specific information. */
  grantValues?: Maybe<Array<JiraPermissionGrantValue>>;
};

/**
 * The permission grant value represents the actual permission grant value.
 * The id field represent the grant ID and its not an ARI. The value represents
 * actual value information specific to grant type.
 * For example: PROJECT_ROLE grant type value contains project role ID in ARI format and role specific details
 */
export type JiraPermissionGrantValue = {
  __typename?: 'JiraPermissionGrantValue';
  /**
   * The ID of the permission grant.
   * It represents the relationship among permission, grant type and grant type specific value.
   */
  id: Scalars['ID'];
  /**
   * The grant type value is an union type.
   * The value itself may resolve to one of the concrete types such as
   * JiraDefaultGrantTypeValue, JiraProjectRoleGrantTypeValue.
   */
  value: JiraGrantTypeValue;
};

/** The type represents a paginated view of permission grant values in the form of connection object. */
export type JiraPermissionGrantValueConnection = {
  __typename?: 'JiraPermissionGrantValueConnection';
  /** The data for edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraPermissionGrantValueEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** The total number of items matching the criteria. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** The permission grant edge object used in connection object for representing an edge. */
export type JiraPermissionGrantValueEdge = {
  __typename?: 'JiraPermissionGrantValueEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at this edge. */
  node: JiraPermissionGrantValue;
};

/**
 * Contains either the group or the projectRole associated with a comment/worklog, but not both.
 * If both are null, then the permission level is unspecified and the comment/worklog is public.
 */
export type JiraPermissionLevel = {
  __typename?: 'JiraPermissionLevel';
  /** The Jira Group associated with the comment/worklog. */
  group?: Maybe<JiraGroup>;
  /** The Jira ProjectRole associated with the comment/worklog. */
  role?: Maybe<JiraRole>;
};

/** A permission scheme is a collection of permission grants. */
export type JiraPermissionScheme = Node & {
  __typename?: 'JiraPermissionScheme';
  /** The description of the permission scheme. */
  description?: Maybe<Scalars['String']>;
  /** The ARI of the permission scheme. */
  id: Scalars['ID'];
  /** The display name of the permission scheme. */
  name: Scalars['String'];
};

/** The input type to add new permission grants to the given permission scheme. */
export type JiraPermissionSchemeAddGrantInput = {
  /** The list of one or more grants to be added. */
  grants: Array<JiraPermissionSchemeGrantInput>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID'];
};

/** The response payload for add permission grants mutation operation for a given permission scheme. */
export type JiraPermissionSchemeAddGrantPayload = Payload & {
  __typename?: 'JiraPermissionSchemeAddGrantPayload';
  /** The errors field represents additional mutation error information if exists. */
  errors?: Maybe<Array<MutationError>>;
  /** The success indicator saying whether mutation operation was successful as a whole or not. */
  success: Scalars['Boolean'];
};

/**
 * The JiraPermissionSchemeGrantGroup is an association between project permission
 * category information and a bounded list of one or more
 * associated permission grant holder. A grant holder represents project permission
 * information and its associated permission grants.
 */
export type JiraPermissionSchemeGrantGroup = {
  __typename?: 'JiraPermissionSchemeGrantGroup';
  /** The basic project permission category information such as key and display name. */
  category: JiraProjectPermissionCategory;
  /** A bounded list of one or more permission grant holders. */
  grantHolders?: Maybe<Array<Maybe<JiraPermissionGrantHolder>>>;
};

/** Specifies permission scheme grant for the combination of permission key, grant type key, and grant type value ARI. */
export type JiraPermissionSchemeGrantInput = {
  /** The grant type key such as USER. */
  grantType: JiraGrantTypeKeyEnum;
  /**
   * The grant value in ARI format.
   * For example: project role ID ari is of the format - ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:role/project-role/activation/bd0c43a9-a23a-4302-8ffa-ca04bde7c747/projectrole/b434089d-7f6d-476b-884b-7811661f91d2
   */
  grantValue: Scalars['ID'];
  /** the project permission key. */
  permissionKey: Scalars['String'];
};

/** The input type to remove permission grants from the given permission scheme. */
export type JiraPermissionSchemeRemoveGrantInput = {
  /** The list of one or more grants to be removed. */
  grants: Array<JiraPermissionSchemeGrantInput>;
  /** The permission scheme ID in ARI format. */
  schemeId: Scalars['ID'];
};

/** The response payload for remove existing permission grants mutation operation for a given permission scheme. */
export type JiraPermissionSchemeRemoveGrantPayload = Payload & {
  __typename?: 'JiraPermissionSchemeRemoveGrantPayload';
  /** The errors field represents additional mutation error information if exists. */
  errors?: Maybe<Array<MutationError>>;
  /** The success indicator saying whether mutation operation was successful as a whole or not. */
  success: Scalars['Boolean'];
};

/**
 * The JiraPermissionSchemeView represents the composite view to capture basic information of
 * the permission scheme such as id, name, description and a bounded list of one or more grant groups.
 * A grant group contains existing permission grant information such as permission,
 * permission category, grant type and grant type value.
 */
export type JiraPermissionSchemeView = {
  __typename?: 'JiraPermissionSchemeView';
  /**
   * The bounded list of one or more grant groups represent each group of
   * permission grants based on project permission category such as PROJECTS, ISSUES.
   */
  grantGroups?: Maybe<Array<JiraPermissionSchemeGrantGroup>>;
  /** The basic permission scheme information such as id, name and description. */
  scheme: JiraPermissionScheme;
};

/** The union result representing either the composite view of the permission scheme or the query error information. */
export type JiraPermissionSchemeViewResult =
  | JiraPermissionSchemeView
  | QueryError;

/** Represents a Jira platform attachment. */
export type JiraPlatformAttachment = JiraAttachment &
  Node & {
    __typename?: 'JiraPlatformAttachment';
    /** Identifier for the attachment. */
    attachmentId: Scalars['String'];
    /** User profile of the attachment author. */
    author?: Maybe<User>;
    /** Date the attachment was created in seconds since the epoch. */
    created: Scalars['DateTime'];
    /** Filename of the attachment. */
    fileName?: Maybe<Scalars['String']>;
    /** Size of the attachment in bytes. */
    fileSize?: Maybe<Scalars['Long']>;
    /** Global identifier for the attachment */
    id: Scalars['ID'];
    /** Media Services file id of this Attachment, May be absent if the attachment has not yet been migrated to Media Services. */
    mediaApiFileId?: Maybe<Scalars['String']>;
    /** The mimetype (also called content type) of the attachment. This may be {@code null}. */
    mimeType?: Maybe<Scalars['String']>;
    /** Parent id that this attachment is contained in. */
    parentId?: Maybe<Scalars['String']>;
    /** Parent name that this attachment is contained in e.g Issue, Field, Comment, Worklog. */
    parentName?: Maybe<Scalars['String']>;
  };

/** Represents a Jira platform comment. */
export type JiraPlatformComment = JiraComment &
  Node & {
    __typename?: 'JiraPlatformComment';
    /** User profile of the original comment author. */
    author?: Maybe<User>;
    /** Identifier for the comment. */
    commentId: Scalars['ID'];
    /** Time of comment creation. */
    created: Scalars['DateTime'];
    /** Global identifier for the comment */
    id: Scalars['ID'];
    /**
     * Either the group or the project role associated with this comment, but not both.
     * Null means the permission level is unspecified, i.e. the comment is public.
     */
    permissionLevel?: Maybe<JiraPermissionLevel>;
    /** Comment body rich text. */
    richText?: Maybe<JiraRichText>;
    /** User profile of the author performing the comment update. */
    updateAuthor?: Maybe<User>;
    /** Time of last comment update. */
    updated?: Maybe<Scalars['DateTime']>;
  };

/** Represents an issue's priority field */
export type JiraPriority = Node & {
  __typename?: 'JiraPriority';
  /** The priority color. */
  color?: Maybe<Scalars['String']>;
  /** The priority icon URL. */
  iconUrl?: Maybe<Scalars['URL']>;
  /** Unique identifier referencing the priority ID. */
  id: Scalars['ID'];
  /** The priority name. */
  name?: Maybe<Scalars['String']>;
  /**
   * "
   * The priority ID. E.g. 10000.
   */
  priorityId: Scalars['String'];
};

/** The connection type for JiraPriority. */
export type JiraPriorityConnection = {
  __typename?: 'JiraPriorityConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraPriorityEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraPriority connection. */
export type JiraPriorityEdge = {
  __typename?: 'JiraPriorityEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraPriority>;
};

/** Represents a priority field on a Jira Issue. */
export type JiraPriorityField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraPriorityField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an Issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Paginated list of priority options for the field or on an Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    priorities?: Maybe<JiraPriorityConnection>;
    /** The priority available on the Issue or default priority configured for the field. */
    priority?: Maybe<JiraPriority>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a priority field on a Jira Issue. */
export type JiraPriorityFieldPrioritiesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProject = Node & {
  __typename?: 'JiraProject';
  avatar?: Maybe<JiraAvatar>;
  category?: Maybe<JiraProjectCategory>;
  cloudId: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  /**
   * The connection entity for DevOps Service relationships for this Jira project, according to the specified
   * pagination, filtering.
   */
  devOpsServiceRelationships?: Maybe<
    DevOpsServiceAndJiraProjectRelationshipConnection
  >;
  id: Scalars['ID'];
  key: Scalars['String'];
  leadId?: Maybe<Scalars['ID']>;
  name: Scalars['String'];
  /**
   * The connection entity for Opsgenie Team relationships for this Jira project, according to the specified
   * pagination, filtering.
   */
  opsgenieTeamRelationships?: Maybe<
    JiraProjectAndOpsgenieTeamRelationshipConnection
  >;
  /** Opsgenie teams that are available to be linked with via createJiraProjectAndOpsgenieTeamRelationship */
  opsgenieTeamsAvailableToLinkWith?: Maybe<OpsgenieTeamConnection>;
  projectUrl?: Maybe<Scalars['String']>;
  /**
   * The connection entity for repository relationships for this Jira project, according to the specified
   * pagination, filtering and sorting.
   */
  repositoryRelationships?: Maybe<
    JiraProjectAndRepositoryRelationshipConnection
  >;
  /** Services that are available to be linked with via createDevOpsServiceAndJiraProjectRelationship */
  servicesAvailableToLinkWith?: Maybe<DevOpsServiceConnection>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProjectDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndJiraProjectRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProjectOpsgenieTeamRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProjectOpsgenieTeamsAvailableToLinkWithArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProjectRepositoryRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<JiraProjectAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  sort?: Maybe<JiraProjectAndRepositoryRelationshipSort>;
};

/**  Copied over from jira-project, will extend this type after deprecating rest bridge project */
export type JiraProjectServicesAvailableToLinkWithArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServicesFilterInput>;
  first?: Maybe<Scalars['Int']>;
};

/** A relationship between a Jira Project and Opsgenie Team */
export type JiraProjectAndOpsgenieTeamRelationship = Node & {
  __typename?: 'JiraProjectAndOpsgenieTeamRelationship';
  /** When the relationship was created. */
  createdAt: Scalars['DateTime'];
  /** Who created the relationship. */
  createdBy: Scalars['String'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The ARI of this relationship. */
  id: Scalars['ID'];
  /** The Jira project related to the Opsgenie team. */
  jiraProject?: Maybe<JiraProject>;
  /** The type of Jira. */
  jiraProjectType?: Maybe<DevOpsJiraProjectType>;
  /** When the relationship was updated last.  Only present for relationships that have been updated. */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /** Who updated the relationship last. Only present for relationships that have been updated. */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** The Opsgenie team details related to the Jira Project. */
  opsgenieTeam?: Maybe<OpsgenieTeam>;
  /** Look up JSON properties of the relationship by keys. */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * The revision must be provided when updating a relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

/** A relationship between a Jira Project and Opsgenie Team */
export type JiraProjectAndOpsgenieTeamRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

export type JiraProjectAndOpsgenieTeamRelationshipConnection = {
  __typename?: 'JiraProjectAndOpsgenieTeamRelationshipConnection';
  edges?: Maybe<Array<Maybe<JiraProjectAndOpsgenieTeamRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<JiraProjectAndOpsgenieTeamRelationship>>>;
  pageInfo: PageInfo;
};

export type JiraProjectAndOpsgenieTeamRelationshipEdge = {
  __typename?: 'JiraProjectAndOpsgenieTeamRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<JiraProjectAndOpsgenieTeamRelationship>;
};

/** A relationship between a Jira project and a repository (Bitbucket or third party). */
export type JiraProjectAndRepositoryRelationship = Node & {
  __typename?: 'JiraProjectAndRepositoryRelationship';
  /**
   * If the repository provider is Bitbucket, this will contain the Bitbucket repository details,
   * otherwise null.
   */
  bitbucketRepository?: Maybe<BitbucketRepository>;
  /** Whether the relationship is explicit or inferred. */
  certainty: DevOpsRelationshipCertainty;
  /** When the relationship was created. */
  createdAt: Scalars['DateTime'];
  /** The AAID or system or system entity that created the relationship. */
  createdBy: Scalars['String'];
  /** An optional description of the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The ARI of this relationship. */
  id: Scalars['ID'];
  /** The Jira project related to the repository. */
  jiraProject?: Maybe<JiraProject>;
  /** When the relationship was inferred last. Only present for implicit relationships. */
  lastInferredAt?: Maybe<Scalars['DateTime']>;
  /**
   * The system that inferred the relationship last.
   * Only present for implicit relationships.
   */
  lastInferredBy?: Maybe<Scalars['String']>;
  /** When the relationship was updated last.  Only present for relationships that have been updated. */
  lastUpdatedAt?: Maybe<Scalars['DateTime']>;
  /**
   * The AAID or system or system entity that updated the relationship last.
   * Only present for relationships that have been updated.
   */
  lastUpdatedBy?: Maybe<Scalars['String']>;
  /** Look up JSON properties of the relationship by keys. */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * The revision must be provided when updating a relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
  /**
   * If the repository provider is a third party, this will contain the third party repository details,
   * otherwise null.
   */
  thirdPartyRepository?: Maybe<DevOpsThirdPartyRepository>;
};

/** A relationship between a Jira project and a repository (Bitbucket or third party). */
export type JiraProjectAndRepositoryRelationshipPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

/** The connection object for a collection of Jira project and repository relationships. */
export type JiraProjectAndRepositoryRelationshipConnection = {
  __typename?: 'JiraProjectAndRepositoryRelationshipConnection';
  edges?: Maybe<Array<Maybe<JiraProjectAndRepositoryRelationshipEdge>>>;
  nodes?: Maybe<Array<Maybe<JiraProjectAndRepositoryRelationship>>>;
  pageInfo: PageInfo;
};

export type JiraProjectAndRepositoryRelationshipEdge = {
  __typename?: 'JiraProjectAndRepositoryRelationshipEdge';
  cursor: Scalars['String'];
  node?: Maybe<JiraProjectAndRepositoryRelationship>;
};

/** #################### Filtering and Sorting Inputs ##################### */
export type JiraProjectAndRepositoryRelationshipFilter = {
  /** Include only relationships with the specified certainty */
  certainty?: Maybe<DevOpsRelationshipCertaintyFilter>;
  /** Include only relationships with the specified repository hosting provider type */
  hostingProvider?: Maybe<DevOpsRepositoryHostingProviderFilter>;
  /**
   * Include only relationships with all of the specified property keys.
   * If this is omitted, no filtering by 'all property keys' is applied.
   */
  withAllPropertyKeys?: Maybe<Array<Scalars['String']>>;
};

export type JiraProjectAndRepositoryRelationshipSort = {
  /** The field to apply sorting on */
  by: JiraProjectAndRepositoryRelationshipSortBy;
  /** The direction of sorting */
  order?: SortDirection;
};

/** #################### Enums ##################### */
export enum JiraProjectAndRepositoryRelationshipSortBy {
  LAST_INFERRED_AT = 'LAST_INFERRED_AT',
}

export type JiraProjectCategory = Node & {
  __typename?: 'JiraProjectCategory';
  /** description of the Project category */
  description?: Maybe<Scalars['String']>;
  /** Global id of this project category */
  id: Scalars['ID'];
  /** display name of the Project category */
  name?: Maybe<Scalars['String']>;
};

export type JiraProjectCategoryConnection = {
  __typename?: 'JiraProjectCategoryConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraProjectCategoryEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
};

export type JiraProjectCategoryEdge = {
  __typename?: 'JiraProjectCategoryEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String'];
  /** The item at the end of the edge */
  node?: Maybe<JiraProjectCategory>;
};

export type JiraProjectConnection = {
  __typename?: 'JiraProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraProjectEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraProjectEdge = {
  __typename?: 'JiraProjectEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String'];
  /** The item at the end of the edge */
  node?: Maybe<JiraProject>;
};

/**
 * Represents a project field on a Jira Issue.
 * Both the system & custom project field can be represented by this type.
 */
export type JiraProjectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraProjectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an Issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The ID of the project field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The project available on the Issue or default project configured for the field. */
    project?: Maybe<JiraProject>;
    /**
     * List of project options available for this field to be selected.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    projects?: Maybe<JiraProjectConnection>;
    /**
     * Search url to fetch all available projects options on the field or an Issue.
     * To be deprecated once project connection is supported for custom project fields.
     */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/**
 * Represents a project field on a Jira Issue.
 * Both the system & custom project field can be represented by this type.
 */
export type JiraProjectFieldProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  recent?: Maybe<Scalars['Boolean']>;
  searchBy?: Maybe<Scalars['String']>;
};

export type JiraProjectFilterInput = {
  /**  Filter the results using a literal string. Projects witha matching key or name are returned (case insensitive). */
  keyword?: Maybe<Scalars['String']>;
  /** the project category that can be used to filter list of projects */
  projectCategoryId?: Maybe<Scalars['ID']>;
  /** the sort criteria that is used while filtering the projects */
  sortBy?: Maybe<JiraProjectSortInput>;
  /** the project types that can be used to filter list of projects */
  types?: Maybe<Array<JiraProjectType>>;
};

/** The project permission in Jira and it is scoped to projects. */
export type JiraProjectPermission = {
  __typename?: 'JiraProjectPermission';
  /** The description of the permission. */
  description: Scalars['String'];
  /** The unique key of the permission. */
  key: Scalars['String'];
  /** The display name of the permission. */
  name: Scalars['String'];
  /** The category of the permission. */
  type: JiraProjectPermissionCategory;
};

/**
 * The category of the project permission.
 * The category information is typically seen in the permission scheme Admin UI.
 * It is used to group the project permissions in general and available for connect
 * app developers when registering new project permissions.
 */
export type JiraProjectPermissionCategory = {
  __typename?: 'JiraProjectPermissionCategory';
  /** The unique key of the permission category. */
  key: JiraProjectPermissionCategoryEnum;
  /** The display name of the permission category. */
  name: Scalars['String'];
};

/**
 * The category of the project permission.
 * It represents the logical grouping of the project permissions.
 */
export enum JiraProjectPermissionCategoryEnum {
  /** Represents one or more permissions to manage issue attacments such as create and delete. */
  ATTACHMENTS = 'ATTACHMENTS',
  /** Represents one or more permissions to manage issue comments such as add, delete and edit. */
  COMMENTS = 'COMMENTS',
  /**
   * Represents one or more permissions applicable at issue level to manage
   * operations such as create, delete, edit, and transition.
   */
  ISSUES = 'ISSUES',
  /** Represents one or more permissions representing default category if not any other existing category. */
  OTHER = 'OTHER',
  /**
   * Represents one or more permissions applicable at project level such as project
   * administration, view project information, and manage sprints.
   */
  PROJECTS = 'PROJECTS',
  /** Represents one or more permissions to manage worklogs, time tracking for billing purpose in some cases. */
  TIME_TRACKING = 'TIME_TRACKING',
  /** Represents one or more permissions to manage watchers and voters of an issue. */
  VOTERS_AND_WATCHERS = 'VOTERS_AND_WATCHERS',
}

/** The project role grant type value having the project role information. */
export type JiraProjectRoleGrantTypeValue = Node & {
  __typename?: 'JiraProjectRoleGrantTypeValue';
  /**
   * The ARI to represent the project role grant type value.
   * For example: ari:cloud:jira:a2520569-493f-45bc-807b-54b02bc724d1:role/project-role/activation/bd0c43a9-a23a-4302-8ffa-ca04bde7c747/projectrole/b434089d-7f6d-476b-884b-7811661f91d2
   */
  id: Scalars['ID'];
  /** The project role information such as name, description. */
  role: JiraRole;
};

export enum JiraProjectSortField {
  /** sorts by category */
  CATEGORY = 'CATEGORY',
  /** sorts by project key */
  KEY = 'KEY',
  /** sorts by lead */
  LEAD = 'LEAD',
  /** sorts by project name */
  NAME = 'NAME',
}

export type JiraProjectSortInput = {
  order?: Maybe<SortDirection>;
  sortBy?: Maybe<JiraProjectSortField>;
};

/** Jira Project types */
export enum JiraProjectType {
  /** A business project */
  BUSINESS = 'BUSINESS',
  /** A service desk project */
  SERVICE_DESK = 'SERVICE_DESK',
  /** A software project */
  SOFTWARE = 'SOFTWARE',
}

/** Possible states for Pull Requests */
export enum JiraPullRequestState {
  /** Pull Request is Declined */
  DECLINED = 'DECLINED',
  /** Pull Request is Merged */
  MERGED = 'MERGED',
  /** Pull Request is Open */
  OPEN = 'OPEN',
}

export type JiraQuery = {
  __typename?: 'JiraQuery';
  /**
   * Get all the available grant type keys such as project role, application access, user, group.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  allGrantTypeKeys: Array<JiraGrantTypeKey>;
  /** Returns a paginated connection of project categories */
  allJiraProjectCategories?: Maybe<JiraProjectCategoryConnection>;
  /** Returns a paginated connection of projects that meet the provided filter criteria */
  allJiraProjects?: Maybe<JiraProjectConnection>;
  /**
   * Retrieves application properties for the given instance.
   *
   * Returns an array containing application properties for each of the provided keys. If a matching application property
   * cannot be found, then no entry is added to the array for that key.
   *
   * A maximum of 50 keys can be provided. If the limit is exceeded then then an error may be returned.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraApplicationProperties` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  applicationPropertiesByKey?: Maybe<Array<JiraApplicationProperty>>;
  /**
   * Container for all DevOps related queries in Jira
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraDevOps` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  devOps?: Maybe<JiraDevOpsQuery>;
  /**
   * Get the list of paginated projects associated with the given permission scheme ID.
   * The project objects will be returned based on implicit ascending order by project name.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  getProjectsByPermissionScheme?: Maybe<JiraProjectConnection>;
  /**
   * Get the grant type values by search term amd grant type key.
   * It only supports fetching values for application role, multi user picker and multi group picker grant types.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  grantTypeValues?: Maybe<JiraGrantTypeValueConnection>;
  /**
   * Returns an Issue by the Issue ID and Jira instance Cloud ID.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraIssue` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  issueById?: Maybe<JiraIssue>;
  /**
   * Returns an Issue by the Issue Key and Jira instance Cloud ID.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraIssue` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  issueByKey?: Maybe<JiraIssue>;
  /** Returns an issue's layout information. */
  issueContainersByType: JiraIssueItemContainersResult;
  jiraProject?: Maybe<JiraProject>;
  /**
   * A parent field to get information about jql related aspects from a given jira instance.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraJqlBuilder` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  jqlBuilder?: Maybe<JiraJqlBuilder>;
  /**
   * A list of paginated permission scheme grants based on the given permission scheme ID.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  permissionSchemeGrants?: Maybe<JiraPermissionGrantValueConnection>;
  /**
   * Get version by ARI
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: JiraVersionResult` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  version?: Maybe<JiraVersionResult>;
  /**
   * Get the permission scheme based on scheme id. The scheme ID input represent an ARI.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: PermissionScheme` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  viewPermissionScheme?: Maybe<JiraPermissionSchemeViewResult>;
};

export type JiraQueryAllGrantTypeKeysArgs = {
  cloudId: Scalars['ID'];
};

export type JiraQueryAllJiraProjectCategoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type JiraQueryAllJiraProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  filter: JiraProjectFilterInput;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type JiraQueryApplicationPropertiesByKeyArgs = {
  cloudId: Scalars['ID'];
  keys: Array<Scalars['String']>;
};

export type JiraQueryGetProjectsByPermissionSchemeArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  schemeId: Scalars['ID'];
};

export type JiraQueryGrantTypeValuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  grantTypeKey?: Maybe<JiraGrantTypeKeyEnum>;
  last?: Maybe<Scalars['Int']>;
  searchTerm?: Maybe<Scalars['String']>;
};

export type JiraQueryIssueByIdArgs = {
  id: Scalars['ID'];
};

export type JiraQueryIssueByKeyArgs = {
  cloudId: Scalars['ID'];
  key: Scalars['String'];
};

export type JiraQueryIssueContainersByTypeArgs = {
  input: JiraIssueItemSystemContainerTypeWithIdInput;
};

export type JiraQueryJiraProjectArgs = {
  id: Scalars['ID'];
};

export type JiraQueryJqlBuilderArgs = {
  cloudId: Scalars['ID'];
};

export type JiraQueryPermissionSchemeGrantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  permissionKey?: Maybe<Scalars['String']>;
  schemeId: Scalars['ID'];
};

export type JiraQueryVersionArgs = {
  id: Scalars['ID'];
};

export type JiraQueryViewPermissionSchemeArgs = {
  schemeId: Scalars['ID'];
};

/** Represents the radio select field on a Jira Issue. */
export type JiraRadioSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraRadioSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The option available on the Issue or default option configured for the field. */
    selectedOption?: Maybe<JiraOption>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the radio select field on a Jira Issue. */
export type JiraRadioSelectFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

export type JiraReleases = {
  __typename?: 'JiraReleases';
  /** Deployment summaries that are ordered by the date at which they occured (most recent to least recent). */
  deployments?: Maybe<JiraReleasesDeploymentSummaryConnection>;
  /**
   * Query deployment summaries by ID.
   *
   * A maximum of 100 `deploymentIds` can be asked for at the one time.
   */
  deploymentsById?: Maybe<Array<Maybe<DeploymentSummary>>>;
  /**
   * Epic data that is filtered & ordered based on release-specific information.
   *
   * The returned epics will be ordered by the dates of the most recent deployments for
   * the issues within the epic that match the input filter. An epic containing an issue
   * that was released more recently will appear earlier in the list.
   */
  epics?: Maybe<JiraReleasesEpicConnection>;
  /**
   * Issue data that is filtered & ordered based on release-specific information.
   *
   * The returned issues will be ordered by the dates of the most recent deployments that
   * match the input filter. An issue that was released more recently will appear earlier
   * in the list.
   */
  issues?: Maybe<JiraReleasesIssueConnection>;
};

export type JiraReleasesDeploymentsArgs = {
  after?: Maybe<Scalars['String']>;
  filter: JiraReleasesDeploymentFilter;
  first?: Scalars['Int'];
};

export type JiraReleasesDeploymentsByIdArgs = {
  deploymentIds: Array<Scalars['ID']>;
};

export type JiraReleasesEpicsArgs = {
  after?: Maybe<Scalars['String']>;
  filter: JiraReleasesEpicFilter;
  first?: Scalars['Int'];
};

export type JiraReleasesIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  filter: JiraReleasesIssueFilter;
  first?: Scalars['Int'];
};

export type JiraReleasesDeploymentFilter = {
  /** Only deployments in these environment types will be returned. */
  environmentCategories?: Maybe<Array<DevOpsEnvironmentCategory>>;
  /** Only deployments in these environments will be returned. */
  environmentDisplayNames?: Maybe<Array<Scalars['String']>>;
  /** Only deployments associated with these issues will be returned. */
  issueIds?: Maybe<Array<Scalars['ID']>>;
  /** Only deployments associated with these services will be returned. */
  serviceIds?: Maybe<Array<Scalars['ID']>>;
  /** Only deployments in this time window will be returned. */
  timeWindow: JiraReleasesTimeWindowInput;
};

export type JiraReleasesDeploymentSummaryConnection = {
  __typename?: 'JiraReleasesDeploymentSummaryConnection';
  edges?: Maybe<Array<Maybe<JiraReleasesDeploymentSummaryEdge>>>;
  nodes?: Maybe<Array<Maybe<DeploymentSummary>>>;
  pageInfo: PageInfo;
};

export type JiraReleasesDeploymentSummaryEdge = {
  __typename?: 'JiraReleasesDeploymentSummaryEdge';
  cursor: Scalars['String'];
  node?: Maybe<DeploymentSummary>;
};

export type JiraReleasesEpic = {
  __typename?: 'JiraReleasesEpic';
  assignee?: Maybe<User>;
  color?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  issueKey?: Maybe<Scalars['String']>;
  issueTypeId?: Maybe<Scalars['ID']>;
  lastDeployed?: Maybe<Scalars['DateTime']>;
  summary?: Maybe<Scalars['String']>;
};

export type JiraReleasesEpicConnection = {
  __typename?: 'JiraReleasesEpicConnection';
  edges?: Maybe<Array<Maybe<JiraReleasesEpicEdge>>>;
  nodes?: Maybe<Array<Maybe<JiraReleasesEpic>>>;
  pageInfo: PageInfo;
};

export type JiraReleasesEpicEdge = {
  __typename?: 'JiraReleasesEpicEdge';
  cursor: Scalars['String'];
  node?: Maybe<JiraReleasesEpic>;
};

export type JiraReleasesEpicFilter = {
  /** Only epics in this project will be returned. */
  projectId: Scalars['ID'];
  /** Determines whether epics that haven't been released should be included in the results. */
  releaseStatusFilter?: Maybe<JiraReleasesEpicReleaseStatusFilter>;
  /** Only epics matching this text filter will be returned. */
  text?: Maybe<Scalars['String']>;
};

/**
 * Used for specifying whether or not epics that haven't been released should be included
 * in the results.
 *
 * For an epic to be considered as released, at least one of the issues or subtasks within
 * it must have been released.
 */
export enum JiraReleasesEpicReleaseStatusFilter {
  /** Only epics that have been released (to any environment) will be included in the results. */
  RELEASED = 'RELEASED',
  /**
   * Epics that have been released will be returned first, followed by epics that haven't
   * yet been released.
   */
  RELEASED_AND_UNRELEASED = 'RELEASED_AND_UNRELEASED',
}

export type JiraReleasesIssue = {
  __typename?: 'JiraReleasesIssue';
  assignee?: Maybe<User>;
  /**
   * The epic this issue is contained within (either directly or indirectly).
   *
   * Note: If the issue and its ancestors are not within an epic, the value will be `null`.
   */
  epic?: Maybe<JiraReleasesEpic>;
  id: Scalars['ID'];
  issueKey?: Maybe<Scalars['String']>;
  issueTypeId?: Maybe<Scalars['ID']>;
  lastDeployed?: Maybe<Scalars['DateTime']>;
  summary?: Maybe<Scalars['String']>;
};

export type JiraReleasesIssueConnection = {
  __typename?: 'JiraReleasesIssueConnection';
  edges?: Maybe<Array<Maybe<JiraReleasesIssueEdge>>>;
  nodes?: Maybe<Array<Maybe<JiraReleasesIssue>>>;
  pageInfo: PageInfo;
};

export type JiraReleasesIssueEdge = {
  __typename?: 'JiraReleasesIssueEdge';
  cursor: Scalars['String'];
  node?: Maybe<JiraReleasesIssue>;
};

export type JiraReleasesIssueFilter = {
  /** Only issues assigned to these users will be returned. */
  assignees?: Maybe<Array<Scalars['ID']>>;
  /** Only issues that have been released in these environment *types* will be returned. */
  environmentCategories?: Maybe<Array<Maybe<DevOpsEnvironmentCategory>>>;
  /** Only issues that have been released in these environments will be returned. */
  environmentDisplayNames?: Maybe<Array<Scalars['String']>>;
  /**
   * Only issues in these epics will be returned.
   *
   * Note:
   * * If a null ID is included in the list, issues not in epics will be included in the results.
   * * If a subtask's parent issue is in one of the epics, the subtask will also be returned.
   */
  epicIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** Only issues with the supplied fixVersions will be returned. */
  fixVersions?: Maybe<Array<Scalars['String']>>;
  /** Only issues of these types will be returned. */
  issueTypes?: Maybe<Array<Scalars['ID']>>;
  /** Only issues in this project will be returned. */
  projectId: Scalars['ID'];
  /** Determines whether issues that haven't been released should be included in the results. */
  releaseStatusFilter?: JiraReleasesIssueReleaseStatusFilter;
  /** Only issues matching this text filter will be returned (will match against all issue fields). */
  text?: Maybe<Scalars['String']>;
  /**
   * Only issues that have been released within this time window will be returned.
   *
   * Note: Issues that have not been released within the time window will still be returned
   * if the `includeIssuesWithoutReleases` argument is `true`.
   */
  timeWindow: JiraReleasesTimeWindowInput;
};

/**
 * Used for specifying whether or not issues that haven't been released should be included
 * in the results.
 */
export enum JiraReleasesIssueReleaseStatusFilter {
  /** Only issues that have been released (to any environment) will be included in the results. */
  RELEASED = 'RELEASED',
  /**
   * Issues that have been released will be returned first, followed by issues that haven't
   * yet been released.
   */
  RELEASED_AND_UNRELEASED = 'RELEASED_AND_UNRELEASED',
  /** Only issues that have *not* been released (to any environment) will be included in the results. */
  UNRELEASED = 'UNRELEASED',
}

export type JiraReleasesTimeWindowInput = {
  after: Scalars['DateTime'];
  before: Scalars['DateTime'];
};

/** Represents the resolution field of an issue. */
export type JiraResolution = Node & {
  __typename?: 'JiraResolution';
  /** Resolution description. */
  description?: Maybe<Scalars['String']>;
  /** Global identifier representing the resolution id. */
  id: Scalars['ID'];
  /** Resolution name. */
  name?: Maybe<Scalars['String']>;
  /** Resolution Id in the digital format. */
  resolutionId: Scalars['String'];
};

/** The connection type for JiraResolution. */
export type JiraResolutionConnection = {
  __typename?: 'JiraResolutionConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraResolutionEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo?: Maybe<PageInfo>;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraResolution connection. */
export type JiraResolutionEdge = {
  __typename?: 'JiraResolutionEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraResolution>;
};

/** Represents a resolution field on a Jira Issue. */
export type JiraResolutionField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraResolutionField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The resolution available on the Issue or default resolution configured for the field. */
    resolution?: Maybe<JiraResolution>;
    /**
     * Paginated list of resolution options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    resolutions?: Maybe<JiraResolutionConnection>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a resolution field on a Jira Issue. */
export type JiraResolutionFieldResolutionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Possible states for Reviews */
export enum JiraReviewState {
  /** Review is in Require Approval state */
  APPROVAL = 'APPROVAL',
  /** Review has been closed */
  CLOSED = 'CLOSED',
  /** Review is in Dead state */
  DEAD = 'DEAD',
  /** Review is in Draft state */
  DRAFT = 'DRAFT',
  /** Review has been rejected */
  REJECTED = 'REJECTED',
  /** Review is in Review state */
  REVIEW = 'REVIEW',
  /** Review is in Summarize state */
  SUMMARIZE = 'SUMMARIZE',
  /** Review state is unknown */
  UNKNOWN = 'UNKNOWN',
}

/** Represents the rich text format of a rich text field. */
export type JiraRichText = {
  __typename?: 'JiraRichText';
  /** Text in Atlassian Document Format. */
  adfValue?: Maybe<JiraAdf>;
  /** Plain text version of the text. */
  plainText?: Maybe<Scalars['String']>;
  /** Text in wiki format. */
  wikiValue?: Maybe<Scalars['String']>;
};

/** Represents a rich text field on a Jira Issue. E.g. description, environment. */
export type JiraRichTextField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraRichTextField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Contains the information needed to add media content to the field. */
    mediaContext?: Maybe<JiraMediaContext>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Determines what editor to render.
     * E.g. default text rendering or wiki text rendering.
     */
    renderer?: Maybe<Scalars['String']>;
    /** The rich text available on the Issue or default rich text configured for the field. */
    richText?: Maybe<JiraRichText>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents a Jira ProjectRole. */
export type JiraRole = {
  __typename?: 'JiraRole';
  /** Description of the ProjectRole. */
  description?: Maybe<Scalars['String']>;
  /** Global identifier of the ProjectRole. */
  id: Scalars['ID'];
  /** Name of the ProjectRole. */
  name?: Maybe<Scalars['String']>;
  /** Id of the ProjectRole. */
  roleId: Scalars['String'];
};

/** The connection type for JiraRole. */
export type JiraRoleConnection = {
  __typename?: 'JiraRoleConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraRoleEdge>>>;
  /** The page infor of the current page of results. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraRoleConnection connection. */
export type JiraRoleEdge = {
  __typename?: 'JiraRoleEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraRole>;
};

/** Represents the security levels on an Issue. */
export type JiraSecurityLevel = Node & {
  __typename?: 'JiraSecurityLevel';
  /** Description of the security level. */
  description?: Maybe<Scalars['String']>;
  /** Global identifier for the security level. */
  id: Scalars['ID'];
  /** Name of the security level. */
  name?: Maybe<Scalars['String']>;
  /** identifier for the security level. */
  securityId: Scalars['String'];
};

/** The connection type for JiraSecurityLevel. */
export type JiraSecurityLevelConnection = {
  __typename?: 'JiraSecurityLevelConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraSecurityLevelEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraSecurityLevel connection. */
export type JiraSecurityLevelEdge = {
  __typename?: 'JiraSecurityLevelEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraSecurityLevel>;
};

/** Represents security level field on a Jira Issue. Issue Security allows you to control who can and cannot view issues. */
export type JiraSecurityLevelField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSecurityLevelField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The security level available on the Issue or default security level configured for the field. */
    securityLevel?: Maybe<JiraSecurityLevel>;
    /**
     * Paginated list of security level options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    securityLevels?: Maybe<JiraSecurityLevelConnection>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents security level field on a Jira Issue. Issue Security allows you to control who can and cannot view issues. */
export type JiraSecurityLevelFieldSecurityLevelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents an approval that is still active. */
export type JiraServiceManagementActiveApproval = Node & {
  __typename?: 'JiraServiceManagementActiveApproval';
  /**
   * Approver principals are users or groups that may decide on an approval.
   * The list includes undecided members.
   */
  approverPrincipals?: Maybe<JiraServiceManagementApproverPrincipal>;
  /** Detailed list of the users who must provide a response to the approval. */
  approvers?: Maybe<JiraServiceManagementApproverConnection>;
  /**
   * Indicates whether the user making the request is one of the approvers and can
   * respond to the approval (true) or not (false).
   */
  canAnswerApproval?: Maybe<Scalars['Boolean']>;
  /** Configuration of the approval including the approval condition and approvers configuration. */
  configuration?: Maybe<JiraServiceManagementApprovalConfiguration>;
  /** Date the approval was created. */
  createdDate?: Maybe<Scalars['DateTime']>;
  /** List of the users' decisions. Does not include undecided users. */
  decisions?: Maybe<JiraServiceManagementDecisionConnection>;
  /** Outcome of the approval, based on the approvals provided by all approvers. */
  finalDecision?: Maybe<JiraServiceManagementApprovalDecisionResponseType>;
  /** ID of the active approval. */
  id: Scalars['ID'];
  /** Name of the approval being sought. */
  name?: Maybe<Scalars['String']>;
  /** The number of approvals needed to complete. */
  pendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Status details of the approval. */
  status?: Maybe<JiraServiceManagementApprovalStatus>;
};

/** Represents the details of an approval condition. */
export type JiraServiceManagementApprovalCondition = {
  __typename?: 'JiraServiceManagementApprovalCondition';
  /** Condition type for approval. */
  type?: Maybe<Scalars['String']>;
  /** Condition value for approval. */
  value?: Maybe<Scalars['String']>;
};

/** Represents the configuration details of an approval. */
export type JiraServiceManagementApprovalConfiguration = {
  __typename?: 'JiraServiceManagementApprovalConfiguration';
  /** Contains information about approvers configuration. */
  approversConfiguration?: Maybe<JiraServiceManagementApproversConfiguration>;
  /** Contains information about approval condition. */
  condition?: Maybe<JiraServiceManagementApprovalCondition>;
};

/** Represents the possible decisions that can be made by an approver. */
export enum JiraServiceManagementApprovalDecisionResponseType {
  /** Indicates that the decision is approved by the approver. */
  APPROVED = 'approved',
  /** Indicates that the decision is declined by the approver. */
  DECLINED = 'declined',
  /** Indicates that the decision is pending by the approver. */
  PENDING = 'pending',
}

/** Represents the Approval custom field on an Issue in a JSM project. */
export type JiraServiceManagementApprovalField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementApprovalField';
    /**
     * The active approval is used to render the approval panel that the users can
     * interact with to approve/decline the request or update approvers.
     */
    activeApproval?: Maybe<JiraServiceManagementActiveApproval>;
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /**
     * The completed approvals are used to render the approval history section and
     * contains records for all previous approvals for that issue.
     */
    completedApprovals?: Maybe<
      Array<Maybe<JiraServiceManagementCompletedApproval>>
    >;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. customfield_10001 or description, */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents details of the approval status. */
export type JiraServiceManagementApprovalStatus = {
  __typename?: 'JiraServiceManagementApprovalStatus';
  /** Status category Id of approval. */
  categoryId?: Maybe<Scalars['Long']>;
  /** Status id of approval. */
  id?: Maybe<Scalars['String']>;
  /** Status name of approval. E.g. Waiting for approval. */
  name?: Maybe<Scalars['String']>;
};

/** The user and decision that approved the approval. */
export type JiraServiceManagementApprover = {
  __typename?: 'JiraServiceManagementApprover';
  /** Details of the User who is providing approval. */
  approver?: Maybe<User>;
  /** Decision made by the approver. */
  approverDecision?: Maybe<JiraServiceManagementApprovalDecisionResponseType>;
};

/** The connection type for JiraServiceManagementApprover. */
export type JiraServiceManagementApproverConnection = {
  __typename?: 'JiraServiceManagementApproverConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraServiceManagementApproverEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraServiceManagementApprover connection. */
export type JiraServiceManagementApproverEdge = {
  __typename?: 'JiraServiceManagementApproverEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraServiceManagementApprover>;
};

/** Approver principals are either an user, or users or groups that may decide on an approval. */
export type JiraServiceManagementApproverPrincipal =
  | JiraServiceManagementGroupApproverPrincipals
  | JiraServiceManagementUserApproverPrincipal
  | JiraServiceManagementUserApproverPrincipalConnection;

/** Represents the configuration details of the users providing approval. */
export type JiraServiceManagementApproversConfiguration = {
  __typename?: 'JiraServiceManagementApproversConfiguration';
  /** Custom field id. */
  customFieldId?: Maybe<Scalars['String']>;
  /** Custom field name. Only set for type "field". */
  customFieldName?: Maybe<Scalars['String']>;
  /** Approvers configuration type. E.g. custom_field. */
  type?: Maybe<Scalars['String']>;
};

/** Represents an attachment within a JiraServiceManagement project. */
export type JiraServiceManagementAttachment = JiraAttachment &
  Node & {
    __typename?: 'JiraServiceManagementAttachment';
    /** Identifier for the attachment. */
    attachmentId: Scalars['String'];
    /** User profile of the attachment author. */
    author?: Maybe<User>;
    /** Date the attachment was created in seconds since the epoch. */
    created: Scalars['DateTime'];
    /** Filename of the attachment. */
    fileName?: Maybe<Scalars['String']>;
    /** Size of the attachment in bytes. */
    fileSize?: Maybe<Scalars['Long']>;
    /** Global identifier for the attachment */
    id: Scalars['ID'];
    /** Media Services file id of this Attachment, May be absent if the attachment has not yet been migrated to Media Services. */
    mediaApiFileId?: Maybe<Scalars['String']>;
    /** The mimetype (also called content type) of the attachment. This may be {@code null}. */
    mimeType?: Maybe<Scalars['String']>;
    /**
     * If the parent for the JSM attachment is a comment, this represents the JSM
     * visibility property associated with this comment.
     */
    parentCommentVisibility?: Maybe<JiraServiceManagementCommentVisibility>;
    /** Parent id that this attachment is contained in. */
    parentId?: Maybe<Scalars['String']>;
    /** Parent name that this attachment is contained in e.g Issue, Field, Comment, Worklog. */
    parentName?: Maybe<Scalars['String']>;
  };

/** Represents a comment within a JiraServiceManagement project. */
export type JiraServiceManagementComment = JiraComment &
  Node & {
    __typename?: 'JiraServiceManagementComment';
    /** User profile of the original comment author. */
    author?: Maybe<User>;
    /** Identifier for the comment. */
    commentId: Scalars['ID'];
    /** Time of comment creation. */
    created: Scalars['DateTime'];
    /** Global identifier for the comment */
    id: Scalars['ID'];
    /**
     * Either the group or the project role associated with this comment, but not both.
     * Null means the permission level is unspecified, i.e. the comment is public.
     */
    permissionLevel?: Maybe<JiraPermissionLevel>;
    /** Comment body rich text. */
    richText?: Maybe<JiraRichText>;
    /** User profile of the author performing the comment update. */
    updateAuthor?: Maybe<User>;
    /** Time of last comment update. */
    updated?: Maybe<Scalars['DateTime']>;
    /** The JSM visibility property associated with this comment. */
    visibility?: Maybe<JiraServiceManagementCommentVisibility>;
  };

/** The visibility property of a comment within a JSM project type. */
export enum JiraServiceManagementCommentVisibility {
  /** This comment will only appear in JIRA's issue view. Also called private. */
  INTERNAL = 'INTERNAL',
  /** This comment will appear in the portal, visible to all customers. Also called public. */
  VISIBLE_TO_HELPSEEKER = 'VISIBLE_TO_HELPSEEKER',
}

/** Represents an approval that is completed. */
export type JiraServiceManagementCompletedApproval = Node & {
  __typename?: 'JiraServiceManagementCompletedApproval';
  /** Detailed list of the users who must provide a response to the approval. */
  approvers?: Maybe<JiraServiceManagementApproverConnection>;
  /** Date the approval was completed. */
  completedDate?: Maybe<Scalars['DateTime']>;
  /** Date the approval was created. */
  createdDate?: Maybe<Scalars['DateTime']>;
  /** Outcome of the approval, based on the approvals provided by all approvers. */
  finalDecision?: Maybe<JiraServiceManagementApprovalDecisionResponseType>;
  /** ID of the completed approval. */
  id: Scalars['ID'];
  /** Name of the approval that has been provided. */
  name?: Maybe<Scalars['String']>;
  /** Status details in which the approval is applicable. */
  status?: Maybe<JiraServiceManagementApprovalStatus>;
};

/** Represents a datetime field on an Issue in a JSM project. E.g. request-feedback-date. */
export type JiraServiceManagementDateTimeField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementDateTimeField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** The datetime available on the Issue or default datetime configured for the field. */
    dateTime?: Maybe<Scalars['DateTime']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the user and decision details. */
export type JiraServiceManagementDecision = {
  __typename?: 'JiraServiceManagementDecision';
  /** The user providing a decision. */
  approver?: Maybe<User>;
  /** The decision made by the approver. */
  approverDecision?: Maybe<JiraServiceManagementApprovalDecisionResponseType>;
};

/** The connection type for JiraServiceManagementDecision. */
export type JiraServiceManagementDecisionConnection = {
  __typename?: 'JiraServiceManagementDecisionConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraServiceManagementDecisionEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraServiceManagementDecision connection. */
export type JiraServiceManagementDecisionEdge = {
  __typename?: 'JiraServiceManagementDecisionEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraServiceManagementDecision>;
};

/** Represents the JSM feedback rating. */
export type JiraServiceManagementFeedback = {
  __typename?: 'JiraServiceManagementFeedback';
  /** Represents the integer rating value available on the issue. */
  rating?: Maybe<Scalars['Int']>;
};

/** Contains information about the approvers when approver is a group. */
export type JiraServiceManagementGroupApproverPrincipal = {
  __typename?: 'JiraServiceManagementGroupApproverPrincipal';
  /** This contains the number of members that have approved a decision. */
  approvedCount?: Maybe<Scalars['Int']>;
  /**
   * A group identifier.
   * Note: Group identifiers are nullable.
   */
  groupApproverPrincipalId?: Maybe<Scalars['String']>;
  /** This contains the number of members. */
  memberCount?: Maybe<Scalars['Int']>;
  /** Display name for a group. */
  name?: Maybe<Scalars['String']>;
};

/** Contains list of JiraServiceManagementGroupApproverPrincipal when approver is a group. */
export type JiraServiceManagementGroupApproverPrincipals = {
  __typename?: 'JiraServiceManagementGroupApproverPrincipals';
  /** List of group approvers, maximum 50 items */
  jiraServiceManagementGroupApproverPrincipals?: Maybe<
    Array<Maybe<JiraServiceManagementGroupApproverPrincipal>>
  >;
};

/** Represents the JSM incident. */
export type JiraServiceManagementIncident = {
  __typename?: 'JiraServiceManagementIncident';
  /** Indicates whether any incident is linked to the issue or not. */
  hasLinkedIncidents?: Maybe<Scalars['Boolean']>;
};

/** Represents the Incident Linking custom field on an Issue in a JSM project. */
export type JiraServiceManagementIncidentLinkingField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementIncidentLinkingField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Represents the JSM incident linked to the issue. */
    incident?: Maybe<JiraServiceManagementIncident>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
  };

/**
 * The JiraServiceManagement Issue type hierarchy level.
 * We use hierarchy levels of issue types for issue-parent relationships.
 * A child issue's type must be on a lower hierarchy level compared to the parent's type.
 */
export type JiraServiceManagementIssueTypeHierarchyLevel = {
  __typename?: 'JiraServiceManagementIssueTypeHierarchyLevel';
  /** The global hierarchy level of the issue type, where 0 is the base level. */
  level?: Maybe<Scalars['Int']>;
  /** The name of the issue type hierarchy level. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the language that can be used for fields such as JSM Requested Language. */
export type JiraServiceManagementLanguage = {
  __typename?: 'JiraServiceManagementLanguage';
  /** A readable common name for this language. */
  displayName?: Maybe<Scalars['String']>;
  /** A unique language code that represents the language. */
  languageCode?: Maybe<Scalars['String']>;
};

/** Represents a multi user picker field on an Issue in a JSM project. E.g. sd-request-participants. */
export type JiraServiceManagementMultipleSelectUserPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementMultipleSelectUserPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The users available on the Issue or default users configured for the field. */
    selectedUsers?: Maybe<Array<Maybe<User>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a multi user picker field on an Issue in a JSM project. E.g. sd-request-participants. */
export type JiraServiceManagementMultipleSelectUserPickerFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents the customer organization on an Issue in a JiraServiceManagement project. */
export type JiraServiceManagementOrganization = {
  __typename?: 'JiraServiceManagementOrganization';
  /** The organization's domain. */
  domain?: Maybe<Scalars['String']>;
  /** Globally unique id within this schema. */
  organizationId?: Maybe<Scalars['ID']>;
  /** The organization's name. */
  organizationName?: Maybe<Scalars['String']>;
};

/** The connection type for JiraServiceManagementOrganization. */
export type JiraServiceManagementOrganizationConnection = {
  __typename?: 'JiraServiceManagementOrganizationConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraServiceManagementOrganizationEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraServiceManagementOrganization connection. */
export type JiraServiceManagementOrganizationEdge = {
  __typename?: 'JiraServiceManagementOrganizationEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraServiceManagementOrganization>;
};

/** Represents the Customer Organization field on an Issue in a JSM project. */
export type JiraServiceManagementOrganizationField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementOrganizationField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Paginated list of organization options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    organizations?: Maybe<JiraServiceManagementOrganizationConnection>;
    /** Search url to query for all Customer orgs when user interact with field. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The organizations available on the Issue or default organizations configured for the field. */
    selectedOrganizations?: Maybe<
      Array<Maybe<JiraServiceManagementOrganization>>
    >;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the Customer Organization field on an Issue in a JSM project. */
export type JiraServiceManagementOrganizationFieldOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents a JSM people picker field on a Jira Issue. E.g. servicedesk-approvers-list. */
export type JiraServiceManagementPeopleField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementPeopleField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Whether the field is configured to act as single/multi select user(s) field. */
    isMulti?: Maybe<Scalars['Boolean']>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The people available on the Issue or default people configured for the field. */
    selectedUsers?: Maybe<Array<Maybe<User>>>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a JSM people picker field on a Jira Issue. E.g. servicedesk-approvers-list. */
export type JiraServiceManagementPeopleFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** ITSM project practice categorization. */
export enum JiraServiceManagementPractice {
  /**
   * Empower the IT operations teams with richer contextual information around
   * changes from software development tools so they can make better decisions and minimize risk.
   */
  CHANGE_MANAGEMENT = 'CHANGE_MANAGEMENT',
  /**
   * Bring the development and IT operations teams together to rapidly respond to,
   * resolve, and continuously learn from incidents.
   */
  INCIDENT_MANAGEMENT = 'INCIDENT_MANAGEMENT',
  /** Group incidents to problems, fast-track root cause analysis, and record workarounds to minimize the impact of incidents. */
  PROBLEM_MANAGEMENT = 'PROBLEM_MANAGEMENT',
  /** Manage work across teams with one platform so the employees and customers quickly get the help they need. */
  SERVICE_REQUEST = 'SERVICE_REQUEST',
}

/** Represents the Request Feedback custom field on an Issue in a JSM project. */
export type JiraServiceManagementRequestFeedbackField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementRequestFeedbackField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Represents the JSM feedback rating value available on the issue. */
    feedback?: Maybe<JiraServiceManagementFeedback>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the Request Language field on an Issue in a JSM project. */
export type JiraServiceManagementRequestLanguageField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementRequestLanguageField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** The language available on the Issue or default language configured for the field. */
    language?: Maybe<JiraServiceManagementLanguage>;
    /** List of languages available. */
    languages?: Maybe<Array<Maybe<JiraServiceManagementLanguage>>>;
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Requests the request type structure on an Issue. */
export type JiraServiceManagementRequestType = Node & {
  __typename?: 'JiraServiceManagementRequestType';
  /** Avatar for the request type. */
  avatar?: Maybe<JiraAvatar>;
  /** Description of the request type if applicable. */
  description?: Maybe<Scalars['String']>;
  /** Help text for the request type. */
  helpText?: Maybe<Scalars['String']>;
  /** Global identifier representing the request type id. */
  id: Scalars['ID'];
  /** Issue type to which request type belongs to. */
  issueType?: Maybe<JiraIssueType>;
  /**
   * A deprecated unique identifier string for Request Types.
   * It is still necessary due to the lack of request-type-id in critical parts of JiraServiceManagement backend.
   */
  key?: Maybe<Scalars['String']>;
  /** Name of the request type. */
  name?: Maybe<Scalars['String']>;
  /** Id of the portal that this request type belongs to. */
  portalId?: Maybe<Scalars['String']>;
  /** Request type practice. E.g. incidents, service_request. */
  practices?: Maybe<Array<Maybe<JiraServiceManagementRequestTypePractice>>>;
  /** Identifier for the request type. */
  requestTypeId: Scalars['Long'];
};

/** The connection type for JiraServiceManagementRequestType. */
export type JiraServiceManagementRequestTypeConnection = {
  __typename?: 'JiraServiceManagementRequestTypeConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraServiceManagementRequestTypeEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraServiceManagementIssueType connection. */
export type JiraServiceManagementRequestTypeEdge = {
  __typename?: 'JiraServiceManagementRequestTypeEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraServiceManagementRequestType>;
};

/** Represents the request type field for an Issue in a JSM project. */
export type JiraServiceManagementRequestTypeField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementRequestTypeField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The request type available on the Issue or default request type configured for the field. */
    requestType?: Maybe<JiraServiceManagementRequestType>;
    /**
     * Paginated list of request type options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    requestTypes?: Maybe<JiraServiceManagementRequestTypeConnection>;
    /** Field type key. */
    type: Scalars['String'];
  };

/** Represents the request type field for an Issue in a JSM project. */
export type JiraServiceManagementRequestTypeFieldRequestTypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Defines grouping of the request types,currently only applicable for JiraServiceManagement ITSM projects. */
export type JiraServiceManagementRequestTypePractice = {
  __typename?: 'JiraServiceManagementRequestTypePractice';
  /** Practice in which the request type is categorized. */
  key?: Maybe<JiraServiceManagementPractice>;
};

/** Responder field of a JSM issue, can be either a user or a team. */
export type JiraServiceManagementResponder =
  | JiraServiceManagementTeamResponder
  | JiraServiceManagementUserResponder;

/** Represents the responders entity custom field on an Issue in a JSM project. */
export type JiraServiceManagementRespondersField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraServiceManagementRespondersField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Represents the list of responders. */
    responders?: Maybe<Array<Maybe<JiraServiceManagementResponder>>>;
    /** Field type key. */
    type: Scalars['String'];
  };

/** An Opsgenie team as a responder */
export type JiraServiceManagementTeamResponder = {
  __typename?: 'JiraServiceManagementTeamResponder';
  team?: Maybe<OpsgenieTeam>;
};

/** Contains information about the approvers when approver is a user. */
export type JiraServiceManagementUserApproverPrincipal = {
  __typename?: 'JiraServiceManagementUserApproverPrincipal';
  /** URL for the principal. */
  jiraRest?: Maybe<Scalars['URL']>;
  /** A approver principal who's a user type */
  user?: Maybe<User>;
};

/** The connection type for JiraServiceManagementUserApproverPrincipal. */
export type JiraServiceManagementUserApproverPrincipalConnection = {
  __typename?: 'JiraServiceManagementUserApproverPrincipalConnection';
  /** A list of edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraServiceManagementUserApproverPrincipalEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraServiceManagementUserApproverPrincipal connection. */
export type JiraServiceManagementUserApproverPrincipalEdge = {
  __typename?: 'JiraServiceManagementUserApproverPrincipalEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraServiceManagementUserApproverPrincipal>;
};

/** A user as a responder */
export type JiraServiceManagementUserResponder = {
  __typename?: 'JiraServiceManagementUserResponder';
  user?: Maybe<User>;
};

/** Represents single group picker field. Allows you to select single Jira group to be associated with an issue. */
export type JiraSingleGroupPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSingleGroupPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /**
     * Paginated list of group options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    groups?: Maybe<JiraGroupConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch group picker field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The group available on the Issue or default group configured for the field. */
    selectedGroup?: Maybe<JiraGroup>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents single group picker field. Allows you to select single Jira group to be associated with an issue. */
export type JiraSingleGroupPickerFieldGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents single line text field on a Jira Issue. E.g. summary, epic name, custom text field. */
export type JiraSingleLineTextField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSingleLineTextField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The text available on the Issue or default text configured for the field. */
    text?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents single select field on a Jira Issue. */
export type JiraSingleSelectField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSingleSelectField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** The option available on the Issue or default option configured for the field. */
    fieldOption?: Maybe<JiraOption>;
    /**
     * Paginated list of options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    fieldOptions?: Maybe<JiraOptionConnection>;
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch the select option for the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents single select field on a Jira Issue. */
export type JiraSingleSelectFieldFieldOptionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Represents a single select user field on a Jira Issue. E.g. assignee, reporter, custom user picker. */
export type JiraSingleSelectUserPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSingleSelectUserPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available users options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** Field type key. */
    type: Scalars['String'];
    /** The user available on the Issue or default user configured for the field. */
    user?: Maybe<User>;
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Paginated list of user options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    users?: Maybe<JiraUserConnection>;
  };

/** Represents a single select user field on a Jira Issue. E.g. assignee, reporter, custom user picker. */
export type JiraSingleSelectUserPickerFieldUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents a version field on a Jira Issue. E.g. custom version picker field. */
export type JiraSingleVersionPickerField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSingleVersionPickerField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /** The version available on the Issue or default version configured for the field. */
    version?: Maybe<JiraVersion>;
    /**
     * Paginated list of versions options for the field or on a Jira Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    versions?: Maybe<JiraVersionConnection>;
  };

/** Represents a version field on a Jira Issue. E.g. custom version picker field. */
export type JiraSingleVersionPickerFieldVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  suggested?: Maybe<Scalars['Boolean']>;
};

/** Represents the sprint field of an issue. */
export type JiraSprint = Node & {
  __typename?: 'JiraSprint';
  /** The board name that the sprint belongs to. */
  boardName?: Maybe<Scalars['String']>;
  /** End date of the sprint. */
  endDate?: Maybe<Scalars['DateTime']>;
  /** Global identifier for the sprint. */
  id: Scalars['ID'];
  /** Sprint name. */
  name?: Maybe<Scalars['String']>;
  /** Sprint id in the digital format. */
  sprintId: Scalars['String'];
  /** Start date of the sprint. */
  startDate?: Maybe<Scalars['DateTime']>;
  /** Current state of the sprint. */
  state?: Maybe<JiraSprintState>;
};

/** The connection type for JiraSprint. */
export type JiraSprintConnection = {
  __typename?: 'JiraSprintConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraSprintEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraSprint connection. */
export type JiraSprintEdge = {
  __typename?: 'JiraSprintEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraSprint>;
};

/** Represents sprint field on a Jira Issue. */
export type JiraSprintField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraSprintField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search url to fetch all available sprints options for the field or the Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The sprints available on the Issue or default sprints configured for the field. */
    selectedSprints?: Maybe<Array<Maybe<JiraSprint>>>;
    /**
     * Paginated list of sprint options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    sprints?: Maybe<JiraSprintConnection>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents sprint field on a Jira Issue. */
export type JiraSprintFieldSprintsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
  state?: Maybe<JiraSprintState>;
};

/** Represents the state of the sprint. */
export enum JiraSprintState {
  /** The sprint is in progress. */
  ACTIVE = 'ACTIVE',
  /** The sprint has been completed. */
  CLOSED = 'CLOSED',
  /** The sprint hasn't been started yet. */
  FUTURE = 'FUTURE',
}

/** Represents the status field of an issue. */
export type JiraStatus = Node & {
  __typename?: 'JiraStatus';
  /** Global identifier for the Status. */
  id: Scalars['ID'];
  /** Name of status. E.g. Backlog, Selected for Development, In Progress, Done. */
  name?: Maybe<Scalars['String']>;
  /** Represents a group of Jira statuses. */
  statusCategory?: Maybe<JiraStatusCategory>;
  /** Status id in the digital format. */
  statusId: Scalars['String'];
};

/** Represents the category of a status. */
export type JiraStatusCategory = Node & {
  __typename?: 'JiraStatusCategory';
  /** Color of status category. */
  colorName?: Maybe<JiraStatusCategoryColor>;
  /** Global identifier for the Status Category. */
  id: Scalars['ID'];
  /** A unique key to identify this status category. E.g. new, indeterminate, done. */
  key?: Maybe<Scalars['String']>;
  /** Name of status category. E.g. New, In Progress, Complete. */
  name?: Maybe<Scalars['String']>;
  /** Status category id in the digital format. */
  statusCategoryId: Scalars['String'];
};

/** Color of the status category. */
export enum JiraStatusCategoryColor {
  /** #4a6785 */
  BLUE_GRAY = 'BLUE_GRAY',
  /** #815b3a */
  BROWN = 'BROWN',
  /** #14892c */
  GREEN = 'GREEN',
  /** #707070 */
  MEDIUM_GRAY = 'MEDIUM_GRAY',
  /** #d04437 */
  WARM_RED = 'WARM_RED',
  /** #f6c342 */
  YELLOW = 'YELLOW',
}

/** Represents Status field. */
export type JiraStatusField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraStatusField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** The status available on the Issue or default status configured for the field. */
    status: JiraStatus;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents subtasks on a Jira Issue. */
export type JiraSubtasksField = JiraIssueField &
  JiraIssueFieldConfiguration & {
    __typename?: 'JiraSubtasksField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /**
     * Paginated list of subtasks on the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    subtasks?: Maybe<JiraIssueConnection>;
    /** Field type key. */
    type: Scalars['String'];
  };

/** Represents subtasks on a Jira Issue. */
export type JiraSubtasksFieldSubtasksArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents a single team in Jira */
export type JiraTeam = Node & {
  __typename?: 'JiraTeam';
  /** Avatar of the team */
  avatar?: Maybe<JiraAvatar>;
  /** Description of the team */
  description?: Maybe<Scalars['String']>;
  /** Global identifier of team */
  id: Scalars['ID'];
  /** Members available in the team */
  members?: Maybe<JiraUserConnection>;
  /** Name of the team */
  name?: Maybe<Scalars['String']>;
  /** Team id in the digital format */
  teamId: Scalars['String'];
};

/** The connection type for JiraTeam. */
export type JiraTeamConnection = {
  __typename?: 'JiraTeamConnection';
  /** The data for Edges in the current page */
  edges?: Maybe<Array<Maybe<JiraTeamEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraTeam connection. */
export type JiraTeamEdge = {
  __typename?: 'JiraTeamEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraTeam>;
};

/** Represents the team field on a Jira Issue. Allows you to select a team to be associated with an issue. */
export type JiraTeamField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraTeamField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Search URL to fetch all the teams options for the field on a Jira Issue. */
    searchUrl?: Maybe<Scalars['String']>;
    /** The team available on the Issue or default team configured for the field. */
    selectedTeam?: Maybe<JiraTeam>;
    /**
     * Paginated list of team options available for the field or the Issue.
     * The server may throw an error if both a forward page (specified with `first`)
     * and a backward page (specified with `last`) are requested simultaneously.
     */
    teams?: Maybe<JiraTeamConnection>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the team field on a Jira Issue. Allows you to select a team to be associated with an issue. */
export type JiraTeamFieldTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  searchBy?: Maybe<Scalars['String']>;
};

/** Different time formats supported for entering & displaying time tracking related data. */
export enum JiraTimeFormat {
  /** E.g. 2d 4.5h */
  DAYS = 'DAYS',
  /** E.g. 52.5h */
  HOURS = 'HOURS',
  /** E.g. 2 days, 4 hours, 30 minutes */
  PRETTY = 'PRETTY',
}

/** Represents the time tracking field on Jira issue screens. */
export type JiraTimeTrackingField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraTimeTrackingField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Original Estimate displays the amount of time originally anticipated to resolve the issue. */
    originalEstimate?: Maybe<JiraEstimate>;
    /** Time Remaining displays the amount of time currently anticipated to resolve the issue. */
    remainingEstimate?: Maybe<JiraEstimate>;
    /** Time Spent displays the amount of time that has been spent on resolving the issue. */
    timeSpent?: Maybe<JiraEstimate>;
    /** This represents the global time tracking settings configuration like working hours and days. */
    timeTrackingSettings?: Maybe<JiraTimeTrackingSettings>;
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** Represents the type for representing global time tracking settings. */
export type JiraTimeTrackingSettings = {
  __typename?: 'JiraTimeTrackingSettings';
  /** Format in which the time tracking details are presented to the user. */
  defaultFormat?: Maybe<JiraTimeFormat>;
  /** Default unit for time tracking wherever not specified. */
  defaultUnit?: Maybe<JiraTimeUnit>;
  /** Returns whether time tracking implementation is provided by Jira or some external providers. */
  isJiraConfiguredTimeTrackingEnabled?: Maybe<Scalars['Boolean']>;
  /** Number of days in a working week. */
  workingDaysPerWeek?: Maybe<Scalars['Float']>;
  /** Number of hours in a working day. */
  workingHoursPerDay?: Maybe<Scalars['Float']>;
};

/**
 * Different time units supported for entering & displaying time tracking related data.
 * Get the currently configured default duration to use when parsing duration string for time tracking.
 */
export enum JiraTimeUnit {
  /** When the current duration is in days. */
  DAY = 'DAY',
  /** When the current duration is in hours. */
  HOUR = 'HOUR',
  /** When the current duration is in minutes. */
  MINUTE = 'MINUTE',
  /** When the current duration is in weeks. */
  WEEK = 'WEEK',
}

/** Represents url field on a Jira Issue. */
export type JiraUrlField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraUrlField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** The url available on the Issue or default url configured for the field. */
    url?: Maybe<Scalars['URL']>;
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
  };

/** A connection to a list of users. */
export type JiraUserConnection = {
  __typename?: 'JiraUserConnection';
  /** A list of User edges. */
  edges?: Maybe<Array<Maybe<JiraUserEdge>>>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
  /** A count of filtered result set across all pages. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in an User connection object. */
export type JiraUserEdge = {
  __typename?: 'JiraUserEdge';
  /** The cursor to this edge. */
  cursor?: Maybe<Scalars['String']>;
  /** The node at this edge. */
  node?: Maybe<User>;
};

/** Attributes of user made field configurations. */
export type JiraUserFieldConfig = {
  __typename?: 'JiraUserFieldConfig';
  /** Defines whether a field has been pinned by the user. */
  isPinned?: Maybe<Scalars['Boolean']>;
  /** Defines if the user has preferred to check a field on Issue creation. */
  isSelected?: Maybe<Scalars['Boolean']>;
};

/** The USER grant type value where user data is provided by identity service. */
export type JiraUserGrantTypeValue = Node & {
  __typename?: 'JiraUserGrantTypeValue';
  /**
   * The ARI to represent the grant user type value.
   * For example: ari:cloud:identity::user/123
   */
  id: Scalars['ID'];
  /** The GDPR compliant user profile information. */
  user: User;
};

/** Represents user made configurations associated with an Issue field. */
export type JiraUserIssueFieldConfiguration = {
  /** Attributes of an Issue field configuration info from a user's customisation. */
  userFieldConfig?: Maybe<JiraUserFieldConfig>;
};

/** Jira Version type that can be either Versions system fields or Versions Custom fields. */
export type JiraVersion = Node & {
  __typename?: 'JiraVersion';
  /**
   * Version description.
   * This is a beta field and has not been implemented yet.
   */
  description?: Maybe<Scalars['String']>;
  /** Version icon URL. */
  iconUrl?: Maybe<Scalars['URL']>;
  id: Scalars['ID'];
  /** Version name. */
  name?: Maybe<Scalars['String']>;
  /**
   * The date at which the version was released to customers. Must occur after startDate.
   * This is a beta field and has not been implemented yet.
   */
  releaseDate?: Maybe<Scalars['DateTime']>;
  /**
   * The date at which work on the version began.
   * This is a beta field and has not been implemented yet.
   */
  startDate?: Maybe<Scalars['DateTime']>;
  /** Status to which version belongs to. */
  status?: Maybe<JiraVersionStatus>;
  /** Version Id. */
  versionId: Scalars['String'];
};

/** The connection type for JiraVersion. */
export type JiraVersionConnection = {
  __typename?: 'JiraVersionConnection';
  /** The data for Edges in the current page */
  edges?: Maybe<Array<Maybe<JiraVersionEdge>>>;
  /** Information about the current page. Used to aid in pagination. */
  pageInfo: PageInfo;
  /** The total count of items in the connection. */
  totalCount?: Maybe<Scalars['Int']>;
};

/** An edge in a JiraVersion connection. */
export type JiraVersionEdge = {
  __typename?: 'JiraVersionEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the edge. */
  node?: Maybe<JiraVersion>;
};

/** Contains either the successful fetched version information or an error. */
export type JiraVersionResult = JiraVersion | QueryError;

/** The status of a version field. */
export enum JiraVersionStatus {
  /** Indicates the version is archived, no further changes can be made to this version unless it is un-archived */
  ARCHIVED = 'ARCHIVED',
  /** Indicates the version is available to public */
  RELEASED = 'RELEASED',
  /** Indicates the version is not launched yet */
  UNRELEASED = 'UNRELEASED',
}

/** Represents the votes information of an Issue. */
export type JiraVote = {
  __typename?: 'JiraVote';
  /** Count of users who have voted for this Issue. */
  count?: Maybe<Scalars['Long']>;
  /** Indicates whether the current user has voted for this Issue. */
  hasVoted?: Maybe<Scalars['Boolean']>;
};

/** Represents a votes field on a Jira Issue. */
export type JiraVotesField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraVotesField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Represents the vote value available on the issue.
     * Can be null when voting is disabled.
     */
    vote?: Maybe<JiraVote>;
  };

/** Represents the watches information. */
export type JiraWatch = {
  __typename?: 'JiraWatch';
  /** Count of users who are watching this issue. */
  count?: Maybe<Scalars['Long']>;
  /** Indicates whether the current user is watching this issue. */
  isWatching?: Maybe<Scalars['Boolean']>;
};

/** Represents the Watches system field. */
export type JiraWatchesField = JiraIssueField &
  JiraIssueFieldConfiguration &
  JiraUserIssueFieldConfiguration & {
    __typename?: 'JiraWatchesField';
    /** The field ID alias (if applicable). */
    aliasFieldId?: Maybe<Scalars['ID']>;
    /** Description for the field (if present). */
    description?: Maybe<Scalars['String']>;
    /** Attributes of an issue field's configuration info. */
    fieldConfig?: Maybe<JiraFieldConfig>;
    /** The identifier of the field. E.g. summary, customfield_10001, etc. */
    fieldId: Scalars['String'];
    /** Unique identifier for the field. */
    id: Scalars['ID'];
    /** Translated name for the field (if applicable). */
    name: Scalars['String'];
    /** Field type key. */
    type: Scalars['String'];
    /** Configuration changes which a user can apply to a field. E.g. pin or hide the field. */
    userFieldConfig?: Maybe<JiraUserFieldConfig>;
    /**
     * Represents the watch value available on the issue.
     * Can be null when watching is disabled.
     */
    watch?: Maybe<JiraWatch>;
  };

/** Represents a Jira worklog. */
export type JiraWorklog = Node & {
  __typename?: 'JiraWorklog';
  /** User profile of the original worklog author. */
  author?: Maybe<User>;
  /** Time of worklog creation. */
  created: Scalars['DateTime'];
  /** Global identifier for the worklog. */
  id: Scalars['ID'];
  /**
   * Either the group or the project role associated with this worklog, but not both.
   * Null means the permission level is unspecified, i.e. the worklog is public.
   */
  permissionLevel?: Maybe<JiraPermissionLevel>;
  /** Time Remaining displays the amount of time currently anticipated to resolve the issue. */
  remainingEstimate?: Maybe<JiraEstimate>;
  /** Date and time when this unit of work was started. */
  startDate?: Maybe<Scalars['DateTime']>;
  /** Time spent displays the amount of time logged working on the issue so far. */
  timeSpent?: Maybe<JiraEstimate>;
  /** User profile of the author performing the worklog update. */
  updateAuthor?: Maybe<User>;
  /** Time of last worklog update. */
  updated?: Maybe<Scalars['DateTime']>;
  /** Description related to the achieved work. */
  workDescription?: Maybe<JiraRichText>;
  /** Identifier for the worklog. */
  worklogId: Scalars['ID'];
};

/** The connection type for JiraWorklog. */
export type JiraWorkLogConnection = {
  __typename?: 'JiraWorkLogConnection';
  /** The data for Edges in the current page. */
  edges?: Maybe<Array<Maybe<JiraWorkLogEdge>>>;
  /** The approximate count of items in the connection. */
  indicativeCount?: Maybe<Scalars['Int']>;
  /** The page info of the current page of results. */
  pageInfo: PageInfo;
};

/** An edge in a JiraWorkLog connection. */
export type JiraWorkLogEdge = {
  __typename?: 'JiraWorkLogEdge';
  /** The cursor to this edge. */
  cursor: Scalars['String'];
  /** The node at the the edge. */
  node?: Maybe<JiraWorklog>;
};

export type JswMutation = {
  __typename?: 'JswMutation';
  /**
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: deleteCard` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deleteCard?: Maybe<DeleteCardOutput>;
};

export type JswMutationDeleteCardArgs = {
  input?: Maybe<DeleteCardInput>;
};

export type LabelUsage = {
  __typename?: 'LabelUsage';
  count: Scalars['Int'];
  label: Scalars['String'];
};

export enum LicenseOverrideState {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  TRIAL = 'TRIAL',
}

export type LocalizationContext = {
  /** The locale of user in RFC5646 format. */
  locale?: Maybe<Scalars['String']>;
  /** The timezone of the user as defined in the tz database https://www.iana.org/time-zones. */
  zoneinfo?: Maybe<Scalars['String']>;
};

/** The input for choosing invocations of interest. */
export type LogQueryInput = {
  /**
   * Limits the search to a particular version of the app.
   * Optional: if empty will search all versions of the app
   */
  appVersion?: Maybe<Scalars['String']>;
  /**
   * Limits the search to a particular date range.
   *
   * Note: Logs may have a TTL on them so older logs may not be available
   * despite search parameters.
   */
  dates?: Maybe<DateSearchInput>;
  /**
   * Limits the search to a particular function in the app.
   * Optional: if empty will search all functions.
   */
  functionKey?: Maybe<Scalars['String']>;
  /**
   * Specify which installations you want to search.
   * Optional: if empty will search all installations user has access to.
   */
  installationContexts?: Maybe<Array<Scalars['ID']>>;
};

/** A piece of code that modifies the functionality or look and feel of Atlassian products */
export type MarketplaceApp = {
  __typename?: 'MarketplaceApp';
  /** A numeric identifier for an app in marketplace. */
  appId: Scalars['ID'];
  /** A human-readable identifier for an app in marketplace. */
  appKey: Scalars['String'];
  /** List of categories associated with an app. */
  categories: Array<MarketplaceAppCategory>;
  /** Timestamp when the app was created, in ISO time format `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'` e.g, 2013-10-02T22:05:56.767Z */
  createdAt: Scalars['DateTime'];
  /** Distribution information about the app */
  distribution?: Maybe<MarketplaceAppDistribution>;
  /** Status of the app entity in Marketplace. */
  entityStatus: MarketplaceEntityStatus;
  /** A URL where users can find Community Support resources for the app */
  forumsUrl?: Maybe<Scalars['URL']>;
  /** Google analytics id used for tracking visitors to the app. */
  googleAnalyticsId?: Maybe<Scalars['String']>;
  /** When enabled providing customers with a place to ask questions or browse answers about the app. */
  isAtlassianCommunityEnabled: Scalars['Boolean'];
  /** Link to the issue tracker for the app */
  issueTrackerUrl?: Maybe<Scalars['URL']>;
  /** JSD widget key */
  jsdWidgetKey?: Maybe<Scalars['String']>;
  /** Status of apps listing in Marketplace. */
  listingStatus: MarketplaceListingStatus;
  /** App's logo */
  logo?: Maybe<MarketplaceListingImage>;
  /** Marketing Labels for the app */
  marketingLabels: Array<Scalars['String']>;
  /** App's name in Marketplace. */
  name: Scalars['String'];
  /** Marketplace Partner that provided this app in Marketplace. */
  partner?: Maybe<MarketplacePartner>;
  /** Link to a statement explaining how the app uses and secures user data. */
  privacyPolicyUrl?: Maybe<Scalars['URL']>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions: Array<AtlassianProductHostingType>;
  /** Marketplace App Programs that this App has enrolled in. */
  programs?: Maybe<MarketplaceAppPrograms>;
  /** Summary of the reviews for an app */
  reviewSummary?: Maybe<MarketplaceAppReviewSummary>;
  /** An SEO-friendly URL pathname for the app */
  slug: Scalars['String'];
  /** Link to the status page for the app */
  statusPageUrl?: Maybe<Scalars['URL']>;
  /** A summary describing the app functionality. */
  summary?: Maybe<Scalars['String']>;
  /** Link to the support ticket system for the app */
  supportTicketSystemUrl?: Maybe<Scalars['URL']>;
  /** A short phrase that summarizes what the app does. */
  tagline?: Maybe<Scalars['String']>;
  /** App's versions in Marketplace system. */
  versions: MarketplaceAppVersionConnection;
  /** Information of watchers of a Marketplace app */
  watchersInfo?: Maybe<MarketplaceAppWatchersInfo>;
  /** A URL where users can find documentation platform hosted by the partner */
  wikiUrl?: Maybe<Scalars['URL']>;
};

/** A piece of code that modifies the functionality or look and feel of Atlassian products */
export type MarketplaceAppProductHostingOptionsArgs = {
  excludeHiddenIn?: Maybe<MarketplaceLocation>;
};

/** A piece of code that modifies the functionality or look and feel of Atlassian products */
export type MarketplaceAppVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<MarketplaceAppVersionFilter>;
  first?: Maybe<Scalars['Int']>;
};

/** Category associated with an app */
export type MarketplaceAppCategory = {
  __typename?: 'MarketplaceAppCategory';
  /** Name of the category */
  name: Scalars['String'];
};

/** All deployment related properties for an app version */
export type MarketplaceAppDeployment = {
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
};

/** Step for installing the instructional app */
export type MarketplaceAppDeploymentStep = {
  __typename?: 'MarketplaceAppDeploymentStep';
  /** Text/html to explain the step */
  instruction: Scalars['String'];
  /** Screenshot of the step */
  screenshot?: Maybe<MarketplaceListingImage>;
};

/** Marketplace app's distribution information */
export type MarketplaceAppDistribution = {
  __typename?: 'MarketplaceAppDistribution';
  /** Number of app downloads */
  downloadCount?: Maybe<Scalars['Int']>;
  /** Number of app installations */
  installationCount?: Maybe<Scalars['Int']>;
  /** Tells whether the app is preinstalled on Cloud */
  isPreinstalledInCloud: Scalars['Boolean'];
  /** Tells whether the app is preinstalled on Server and Data Center */
  isPreinstalledInServerDC: Scalars['Boolean'];
};

/** Payment model for integrating an app with an Atlassian product. */
export enum MarketplaceAppPaymentModel {
  FREE = 'FREE',
  PAID_VIA_ATLASSIAN = 'PAID_VIA_ATLASSIAN',
  PAID_VIA_PARTNER = 'PAID_VIA_PARTNER',
}

/** Permissions that a MarketplaceUser can have on MarketplaceApps */
export enum MarketplaceAppPermission {
  MANAGE_APP_DETAILS = 'MANAGE_APP_DETAILS',
}

/** Marketplace App Programs that this Marketplace App has enrolled into. */
export type MarketplaceAppPrograms = {
  __typename?: 'MarketplaceAppPrograms';
  cloudFortified?: Maybe<MarketplaceCloudFortified>;
};

/** Summary of the reviews for an app */
export type MarketplaceAppReviewSummary = {
  __typename?: 'MarketplaceAppReviewSummary';
  /** Number of reviews for app */
  count?: Maybe<Scalars['Int']>;
  /** Rating of the app */
  rating?: Maybe<Scalars['Float']>;
  /**
   * Review score of the app
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Use field `rating`
   */
  score?: Maybe<Scalars['Float']>;
};

/** Version of App in Marketplace system */
export type MarketplaceAppVersion = {
  __typename?: 'MarketplaceAppVersion';
  /** A unique number for each version, higher value indicates more recent version of the app. */
  buildNumber: Scalars['ID'];
  /** All deployment related properties for this app version */
  deployment: MarketplaceAppDeployment;
  /** A URL where users can find version-specific or general documentation about the app. */
  documentationUrl?: Maybe<Scalars['URL']>;
  /** Link to the terms that give end users the right to use the app. */
  endUserLicenseAgreementUrl?: Maybe<Scalars['URL']>;
  /** Hero image to be displayed on this app's listing */
  heroImage?: Maybe<MarketplaceListingImage>;
  /** Feature highlights to be displayed on this app's listing */
  highlights?: Maybe<Array<MarketplaceListingHighlight>>;
  /** Tells whether this version has official support. */
  isSupported: Scalars['Boolean'];
  /** A URL where customers can access more information about this app. */
  learnMoreUrl?: Maybe<Scalars['URL']>;
  /** License type for this version of Marketplace app. */
  licenseType?: Maybe<MarketplaceAppVersionLicenseType>;
  /** Awards, customer testimonials, accolades, language support, or other details about this app. */
  moreDetails?: Maybe<Scalars['String']>;
  /** Payment model for integrating an app with an Atlassian product. */
  paymentModel: MarketplaceAppPaymentModel;
  /** List of Hosting types where compatible Atlassian product instances are installed. */
  productHostingOptions: Array<AtlassianProductHostingType>;
  /** A URL where customers can purchase this app. */
  purchaseUrl?: Maybe<Scalars['URL']>;
  /** Version release date */
  releaseDate: Scalars['DateTime'];
  /** Version release notes */
  releaseNotes?: Maybe<Scalars['String']>;
  /** URL with further details about this version release (link available for versions listed before October 2013) */
  releaseNotesUrl?: Maybe<Scalars['URL']>;
  /** Version release summary */
  releaseSummary?: Maybe<Scalars['String']>;
  /** Feature screenshots to be displayed on this app's listing */
  screenshots?: Maybe<Array<MarketplaceListingScreenshot>>;
  /** A URL to access the app's source code license agreement. This agreement governs how the app's source code is used. */
  sourceCodeLicenseUrl?: Maybe<Scalars['URL']>;
  /** This version identifier is for end users, more than one app versions can have same version value. */
  version: Scalars['String'];
  /** Visibility of this version of Marketplace app. */
  visibility: MarketplaceAppVersionVisibility;
  /** The ID of a YouTube video explaining the features of this app version. */
  youtubeId?: Maybe<Scalars['String']>;
};

export type MarketplaceAppVersionConnection = {
  __typename?: 'MarketplaceAppVersionConnection';
  edges?: Maybe<Array<Maybe<MarketplaceAppVersionEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type MarketplaceAppVersionEdge = {
  __typename?: 'MarketplaceAppVersionEdge';
  cursor: Scalars['String'];
  node?: Maybe<MarketplaceAppVersion>;
};

export type MarketplaceAppVersionFilter = {
  /** Unique id of Cloud App's version */
  cloudAppVersionId?: Maybe<Scalars['ID']>;
  /** Excludes hidden versions as per Marketplace */
  excludeHiddenIn?: Maybe<MarketplaceLocation>;
  /** Options of Atlassian product instance hosting types for which app versions are available. */
  productHostingOptions?: Maybe<Array<AtlassianProductHostingType>>;
  /** Visibility of the version. */
  visibility?: Maybe<MarketplaceAppVersionVisibility>;
};

/** License type for an app version */
export type MarketplaceAppVersionLicenseType = {
  __typename?: 'MarketplaceAppVersionLicenseType';
  /** Unique ID for the license type. */
  id: Scalars['ID'];
  /** A URL where customers can see the license terms. */
  link?: Maybe<Scalars['URL']>;
  /** Display name for the license type. */
  name: Scalars['String'];
};

/** Visibility of the Marketplace app's version */
export enum MarketplaceAppVersionVisibility {
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC',
}

/** Information of watchers of a Marketplace app */
export type MarketplaceAppWatchersInfo = {
  __typename?: 'MarketplaceAppWatchersInfo';
  /** Tells if the user is subscribed to the app updates */
  isUserWatchingApp: Scalars['Boolean'];
  /** Number of users watching the app */
  watchersCount: Scalars['Int'];
};

/** Billing cycle for which pricing plan applies */
export enum MarketplaceBillingCycle {
  ANNUAL = 'ANNUAL',
  MONTHLY = 'MONTHLY',
}

/** Cloud app deployment properties */
export type MarketplaceCloudAppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplaceCloudAppDeployment';
  /** Unique identifier for the Cloud app's production environment */
  cloudAppEnvironmentId: Scalars['ID'];
  /** Cloud Apps unique identifier */
  cloudAppId: Scalars['ID'];
  /** Unique identifier of Cloud Apps version */
  cloudAppVersionId: Scalars['ID'];
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Level of access to an Atlassian product that this app can request */
  scopes: Array<CloudAppScope>;
};

export type MarketplaceCloudFortified = {
  __typename?: 'MarketplaceCloudFortified';
  status?: Maybe<MarketplaceCloudFortifiedStatus>;
};

export enum MarketplaceCloudFortifiedStatus {
  APPROVED = 'APPROVED',
  NOT_A_PARTICIPANT = 'NOT_A_PARTICIPANT',
  REJECTED = 'REJECTED',
}

/** Connect app deployment properties */
export type MarketplaceConnectAppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplaceConnectAppDeployment';
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Tells whether there Atlassian Connect app's descriptor file is available */
  isDescriptorFileAvailable: Scalars['Boolean'];
  /** Level of access to an Atlassian product that this app can request */
  scopes: Array<ConnectAppScope>;
};

/** Status of an entity in Marketplace system */
export enum MarketplaceEntityStatus {
  ACTIVE = 'ACTIVE',
  ARCHIVED = 'ARCHIVED',
}

/** An image file in Atlassian Marketplace system */
export type MarketplaceImageFile = {
  __typename?: 'MarketplaceImageFile';
  /** Height of the image */
  height: Scalars['Int'];
  /** Unique id of the file in Atlassian Marketplace system */
  id: Scalars['String'];
  /** Width of the image */
  width: Scalars['Int'];
};

/** Instructional app deployment properties */
export type MarketplaceInstructionalAppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplaceInstructionalAppDeployment';
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Steps for installing the instructional app */
  instructions?: Maybe<Array<MarketplaceAppDeploymentStep>>;
  /** Tells whether this instructional app has a url for its binary */
  isBinaryUrlAvailable: Scalars['Boolean'];
};

export type MarketplaceListingHighlight = {
  __typename?: 'MarketplaceListingHighlight';
  /** Screenshot's explaination */
  caption?: Maybe<Scalars['String']>;
  /** Highlight's cropped screenshot */
  croppedScreenshot: MarketplaceListingImage;
  /** Highlight's screenshot */
  screenshot: MarketplaceListingScreenshot;
  /** Key feature summary. */
  summary?: Maybe<Scalars['String']>;
  /** A short action-oriented highlight title. */
  title?: Maybe<Scalars['String']>;
};

/** Image to be displayed on a listing in Marketplace */
export type MarketplaceListingImage = {
  __typename?: 'MarketplaceListingImage';
  /** High resolution image file */
  highResolution?: Maybe<MarketplaceImageFile>;
  /** Original image file uploaded */
  original: MarketplaceImageFile;
  /** Image scaled to get required size */
  scaled: MarketplaceImageFile;
};

export type MarketplaceListingScreenshot = {
  __typename?: 'MarketplaceListingScreenshot';
  /** Screenshot's explaination */
  caption?: Maybe<Scalars['String']>;
  /** Screenshot's image file */
  image: MarketplaceListingImage;
};

/** Status of apps listing in Marketplace. */
export enum MarketplaceListingStatus {
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC',
  READY_TO_LAUNCH = 'READY_TO_LAUNCH',
  REJECTED = 'REJECTED',
  SUBMITTED = 'SUBMITTED',
}

/** Marketplace location */
export enum MarketplaceLocation {
  IN_PRODUCT = 'IN_PRODUCT',
  WEBSITE = 'WEBSITE',
}

/**
 * Marketplace Partners provide apps and integrations available for purchase on the
 * Atlassian Marketplace that extend the power of Atlassian products.
 */
export type MarketplacePartner = {
  __typename?: 'MarketplacePartner';
  /** Marketplace Partners address */
  address?: Maybe<MarketplacePartnerAddress>;
  /** Marketplace Partner's contact details */
  contactDetails?: Maybe<MarketplacePartnerContactDetails>;
  /** Unique id of a Marketplace Partner. */
  id: Scalars['ID'];
  /** Name of Marketplace Partner */
  name: Scalars['String'];
  /** Tells if the Marketplace partner is an Atlassians internal one. */
  partnerType?: Maybe<MarketplacePartnerType>;
  /** Marketplace Programs that this Marketplace Partner has participated in. */
  programs?: Maybe<MarketplacePartnerPrograms>;
  /** An SEO-friendly URL pathname for this Marketplace Partner */
  slug: Scalars['String'];
  /** Marketplace Partner support information */
  support?: Maybe<MarketplacePartnerSupport>;
};

/** Marketplace Partner's address */
export type MarketplacePartnerAddress = {
  __typename?: 'MarketplacePartnerAddress';
  /** City of Marketplace Partners address */
  city?: Maybe<Scalars['String']>;
  /** Country of Marketplace Partners address */
  country?: Maybe<Scalars['String']>;
  /** Line 1 of Marketplace Partners address */
  line1?: Maybe<Scalars['String']>;
  /** Line 2 of Marketplace Partners address */
  line2?: Maybe<Scalars['String']>;
  /** Postal code of Marketplace Partners address */
  postalCode?: Maybe<Scalars['String']>;
  /** State of Marketplace Partners address */
  state?: Maybe<Scalars['String']>;
};

/** Marketplace Partner's contact information */
export type MarketplacePartnerContactDetails = {
  __typename?: 'MarketplacePartnerContactDetails';
  /** Marketplace Partners contact email id */
  emailId?: Maybe<Scalars['String']>;
  /** Marketplace Partners homepage URL */
  homepageUrl?: Maybe<Scalars['String']>;
  /** Marketplace Partner's other contact details */
  otherContactDetails?: Maybe<Scalars['String']>;
  /** Marketplace Partners contact phone number */
  phoneNumber?: Maybe<Scalars['String']>;
};

/** Marketplace Programs that this Marketplace Partner has participated in. */
export type MarketplacePartnerPrograms = {
  __typename?: 'MarketplacePartnerPrograms';
  isCloudAppSecuritySelfAssessmentDone?: Maybe<Scalars['Boolean']>;
};

/** Marketplace Partner's support information. */
export type MarketplacePartnerSupport = {
  __typename?: 'MarketplacePartnerSupport';
  /** Marketplace Partners support availability details */
  availability?: Maybe<MarketplacePartnerSupportAvailability>;
  /** Marketplace Partners support contact details */
  contactDetails?: Maybe<MarketplacePartnerSupportContact>;
};

/** Marketplace Partner's support availability information */
export type MarketplacePartnerSupportAvailability = {
  __typename?: 'MarketplacePartnerSupportAvailability';
  /**
   * Days of week when Marketplace Partner support is available, as per ISO 8601
   * format for weekday, i.e. `1-7` for Monday - Sunday
   */
  daysOfWeek: Array<Scalars['Int']>;
  /** Support availability end time, in ISO time format `hh:mm` e.g, 23:25 */
  endTime?: Maybe<Scalars['String']>;
  /** Dates on which MarketplacePartners support is not available due to holiday */
  holidays: Array<MarketplacePartnerSupportHoliday>;
  /** Tells if the support is available for all 24 hours */
  isAvailable24Hours: Scalars['Boolean'];
  /** Support availability start time, in ISO time format `hh:mm` e.g, 23:25 */
  startTime?: Maybe<Scalars['String']>;
  /** Support availability timezone for startTime and endTime values. e.g, `America/Los_Angeles` */
  timezone: Scalars['String'];
  /** Support availability timezone in ISO 8601 format e.g. `+00:00`, `+05:30`, etc */
  timezoneOffset: Scalars['String'];
};

/** Marketplace Partner's support contact information */
export type MarketplacePartnerSupportContact = {
  __typename?: 'MarketplacePartnerSupportContact';
  /** Marketplace Partners support contact email id */
  emailId?: Maybe<Scalars['String']>;
  /** Marketplace Partners support contact phone number */
  phoneNumber?: Maybe<Scalars['String']>;
  /** Marketplace Partners support website URL */
  websiteUrl?: Maybe<Scalars['URL']>;
};

/** Marketplace Partner's support holiday */
export type MarketplacePartnerSupportHoliday = {
  __typename?: 'MarketplacePartnerSupportHoliday';
  /** Support holiday date, follows ISO date format `YYYY-MM-DD` e.g, 2020-08-12 */
  date: Scalars['String'];
  /** Tells whether it occurs one time or is annual. */
  holidayFrequency: MarketplacePartnerSupportHolidayFrequency;
  /** Holidays title */
  title: Scalars['String'];
};

/** Tells whether support is on holiday only one time or if it repeats annually. */
export enum MarketplacePartnerSupportHolidayFrequency {
  ANNUAL = 'ANNUAL',
  ONE_TIME = 'ONE_TIME',
}

/** Tells if the Marketplace partner is an Atlassians internal one. */
export enum MarketplacePartnerType {
  ATLASSIAN_INTERNAL = 'ATLASSIAN_INTERNAL',
}

/** Plugins1 app deployment properties */
export type MarketplacePlugins1AppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplacePlugins1AppDeployment';
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Tells whether there is a deployment artifact */
  isDeploymentArtifactAvailable: Scalars['Boolean'];
};

/** Plugins2 app deployment properties */
export type MarketplacePlugins2AppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplacePlugins2AppDeployment';
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Tells whether there is a deployment artifact */
  isDeploymentArtifactAvailable: Scalars['Boolean'];
};

/** Pricing items based on tiers */
export type MarketplacePricingItem = {
  __typename?: 'MarketplacePricingItem';
  /** The amount that a customer pays for a license at this tier */
  amount: Scalars['Float'];
  /**
   * The upper limit for unit count (number of users of Jira, remote agents in
   * Bamboo) defining this pricing tier. Null in case of highest tier
   */
  ceiling?: Maybe<Scalars['Int']>;
  /** The lower limit for unit count (number of users of Jira, remote agents in Bamboo) defining this pricing tier */
  floor: Scalars['Int'];
  /** Policy of the tier : BLOCK (FLAT) or PER_UNIT (PUP) */
  policy: MarketplacePricingTierPolicy;
};

/** Pricing plan for a marketplace entity */
export type MarketplacePricingPlan = {
  __typename?: 'MarketplacePricingPlan';
  /** Billing cycle of the marketplace entity */
  billingCycle: MarketplaceBillingCycle;
  /** Currency code for all items in the pricing plan. Defaults to USD */
  currency: Scalars['String'];
  /** Status of the plan : LIVE, PENDING or DRAFT */
  status: MarketplacePricingPlanStatus;
  /** Tiered Pricing for the plan */
  tieredPricing: MarketplaceTieredPricing;
};

/** Option parameters to fetch pricing plan for a marketplace entity */
export type MarketplacePricingPlanOptions = {
  /** Period for which Pricing Plan is to be fetched. Defaults to MONTHLY */
  billingCycle?: Maybe<MarketplaceBillingCycle>;
  /**
   * Country code (ISO 3166-1 alpha-2) of the client. Either of currencyCode and
   * countryCode is needed. If both are not present, fallback to default currency - USD
   */
  countryCode?: Maybe<Scalars['String']>;
  /**
   * Currency code (ISO 4217) to return the amount in pricing items. Either of
   * currencyCode and countryCode is needed. If currency code is not present,
   * fallback to country code to fetch currency
   */
  currencyCode?: Maybe<Scalars['String']>;
  /** Fetch pricing plan with status: LIVE, PENDING, DRAFT. Unless, pricing plan will be fetched based on user access */
  planStatus?: Maybe<MarketplacePricingPlanStatus>;
};

/** Status of the plan : LIVE, PENDING or DRAFT */
export enum MarketplacePricingPlanStatus {
  DRAFT = 'DRAFT',
  LIVE = 'LIVE',
  PENDING = 'PENDING',
}

/** Mode of the tier : GRADUATED (progressive PUP), VOLUME (constant for all users) */
export enum MarketplacePricingTierMode {
  GRADUATED = 'GRADUATED',
  VOLUME = 'VOLUME',
}

/** Policy of the tier : BLOCK (FLAT) or PER_UNIT (PUP) */
export enum MarketplacePricingTierPolicy {
  BLOCK = 'BLOCK',
  PER_UNIT = 'PER_UNIT',
}

/** Type of the tier */
export enum MarketplacePricingTierType {
  REMOTE_AGENT_TIERED = 'REMOTE_AGENT_TIERED',
  USER_TIERED = 'USER_TIERED',
}

/** Atlassian Product for which apps are available in Marketplace */
export type MarketplaceSupportedAtlassianProduct = {
  __typename?: 'MarketplaceSupportedAtlassianProduct';
  /** Hosting options where the product is available */
  hostingOptions: Array<AtlassianProductHostingType>;
  /** Unique id of Atlassian product entity in marketplace system */
  id: Scalars['ID'];
  /** Name of Atlassian product */
  name: Scalars['String'];
};

/** Tiered pricing object for pricing plan */
export type MarketplaceTieredPricing = {
  __typename?: 'MarketplaceTieredPricing';
  /** List of pricing items */
  items: Array<MarketplacePricingItem>;
  /** Type of the tier */
  tierType: MarketplacePricingTierType;
  /** Mode of the tier : GRADUATED (progressive PUP), VOLUME (constant for all users) */
  tiersMode: MarketplacePricingTierMode;
};

/** Atlassian Marketplace User */
export type MarketplaceUser = {
  __typename?: 'MarketplaceUser';
  /** Permissions that a MarketplaceUser can have on MarketplaceApps */
  appPermissions: Array<MarketplaceAppPermission>;
  /** The accountId of the user. */
  id: Scalars['ID'];
};

/** Atlassian Marketplace User */
export type MarketplaceUserAppPermissionsArgs = {
  appId: Scalars['ID'];
};

/** Workflow app deployment properties */
export type MarketplaceWorkflowAppDeployment = MarketplaceAppDeployment & {
  __typename?: 'MarketplaceWorkflowAppDeployment';
  /** All Atlassian Products this app version is compatible with */
  compatibleProducts: Array<CompatibleAtlassianProduct>;
  /** Tells whether this workflow app has a JWB file */
  isWorkflowDataFileAvailable: Scalars['Boolean'];
};

export type MigrationKeys = {
  __typename?: 'MigrationKeys';
  confluence: Scalars['String'];
  jira: Scalars['String'];
};

/** Card mutations response */
export type MoveCardOutput = {
  __typename?: 'MoveCardOutput';
  clientMutationId?: Maybe<Scalars['ID']>;
  issuesWereTransitioned?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  statusCode?: Maybe<Scalars['Int']>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Move sprint down */
export type MoveSprintDownInput = {
  boardId: Scalars['ID'];
  sprintId: Scalars['ID'];
};

export type MoveSprintDownResponse = MutationResponse & {
  __typename?: 'MoveSprintDownResponse';
  boardScope?: Maybe<BoardScope>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Move sprint up */
export type MoveSprintUpInput = {
  boardId: Scalars['ID'];
  sprintId: Scalars['ID'];
};

export type MoveSprintUpResponse = MutationResponse & {
  __typename?: 'MoveSprintUpResponse';
  boardScope?: Maybe<BoardScope>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /**
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  appStorage?: Maybe<AppStorageMutation>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  applyPolarisProjectTemplate?: Maybe<ApplyPolarisProjectTemplatePayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  archivePolarisInsights?: Maybe<ArchivePolarisInsightsPayload>;
  assignIssueParent?: Maybe<AssignIssueParentOutput>;
  /**
   * This mutation is currently in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: boardCardMove` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  boardCardMove?: Maybe<MoveCardOutput>;
  /**
   * This API is currently in BETA. You must provide "X-ExperimentalApi:compass-beta" in your request header
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-beta` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  compass?: Maybe<CompassCatalogMutationApi>;
  completeSprint?: Maybe<CompleteSprintResponse>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  configurePolarisRefresh?: Maybe<ConfigurePolarisRefreshPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  copyPolarisInsights?: Maybe<CopyPolarisInsightsPayload>;
  /** Creates an application in Xen */
  createApp?: Maybe<CreateAppResponse>;
  createAppDeployment?: Maybe<CreateAppDeploymentResponse>;
  createAppDeploymentUrl?: Maybe<CreateAppDeploymentUrlResponse>;
  /**
   * Create multiple tunnels for an app
   *
   * This will allow api calls for this app to be tunnelled to a locally running
   * server to help with writing and debugging functions.
   *
   * This call covers both the FaaS tunnel as well as registering multiple Custom UI tunnels
   * that can then be used in the products instead of serving the usual CDN url.
   *
   * This call will fail if a tunnel already exists, unless the 'force' flag is set.
   *
   * Tunnels automatically expire after 30 minutes
   */
  createAppTunnels?: Maybe<CreateAppTunnelResponse>;
  /**
   * This mutation is in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: BacklogEpicPanel` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createCardParent?: Maybe<CardParentCreateOutput>;
  createColumn?: Maybe<CreateColumnOutput>;
  /**
   * Creates a new custom filter
   * This mutation is currently in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: createCustomFilter` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createCustomFilter?: Maybe<CustomFilterCreateOutput>;
  /** Create a DevOps Service */
  createDevOpsService?: Maybe<CreateDevOpsServicePayload>;
  /** Creates a relationships between a DevOps Service and a Jira project */
  createDevOpsServiceAndJiraProjectRelationship?: Maybe<
    CreateDevOpsServiceAndJiraProjectRelationshipPayload
  >;
  /**
   * Create a relationship between a DevOps Service and an Opsgenie team.
   *
   * A DevOps Service can be related to no more than one team. If you attempt to relate more than one team
   * with a DevOps Service, this mutation will fail with a SERVICE_AND_OPSGENIE_TEAM_RELATIONSHIP_TOO_MANY_TEAMS error.
   *
   * A team can be related to no more than 1,000 DevOps Services. If you attempt to relate too many services
   * with a team, this mutation will fail with a SERVICE_AND_OPSGENIE_TEAM_RELATIONSHIP_TOO_MANY_SERVICES error.
   */
  createDevOpsServiceAndOpsgenieTeamRelationship?: Maybe<
    CreateDevOpsServiceAndOpsgenieTeamRelationshipPayload
  >;
  /**
   * Create a relationship between a DevOps Service and a Repository.
   *
   * A single service may be associated with at most 300 repositories. If too many repositories are associated with a
   * DevOps Service, this mutation will fail with a SERVICE_AND_REPOSITORY_RELATIONSHIP_TOO_MANY_REPOSITORIES error.
   *
   * A single Repository may be associated with at most 300 DevOps Services. If too many DevOps Services are associated with a
   * Repository, this mutation will fail with a SERVICE_AND_REPOSITORY_RELATIONSHIP_TOO_MANY_SERVICES error.
   */
  createDevOpsServiceAndRepositoryRelationship?: Maybe<
    CreateDevOpsServiceAndRepositoryRelationshipPayload
  >;
  /** Create a DevOps Service Relationship */
  createDevOpsServiceRelationship?: Maybe<
    CreateDevOpsServiceRelationshipPayload
  >;
  createHostedResourceUploadUrl?: Maybe<CreateHostedResourceUploadUrlPayload>;
  /** Create a relationship between a Jira project and an Opsgenie team. */
  createJiraProjectAndOpsgenieTeamRelationship?: Maybe<
    CreateJiraProjectAndOpsgenieTeamRelationshipPayload
  >;
  /**
   * Create a relationship between a Jira project and a repository.
   *
   * A single Jira project may be associated with at most 100 repositories. If too many repositories are associated with a
   * Jira project, this mutation will fail with a TOO_MANY_EXPLICIT_REPOSITORY_RELATIONSHIPS_FOR_PROJECT error.
   *
   * A single Repository may be associated with at most 100 Jira projects. If too many Jira projects are associated with a
   * repository, this mutation will fail with a TOO_MANY_EXPLICIT_PROJECT_RELATIONSHIPS_FOR_REPOSITORY error.
   */
  createJiraProjectAndRepositoryRelationship?: Maybe<
    CreateJiraProjectAndRepositoryRelationshipPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisAnonymousVisitorHash?: Maybe<
    CreatePolarisAnonymousVisitorHashPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisCalculatedField?: Maybe<CreatePolarisCalculatedFieldPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisComment?: Maybe<CreatePolarisCommentPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisDecoration?: Maybe<CreatePolarisDecorationPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisInsight?: Maybe<CreatePolarisInsightPayload>;
  /**
   * Creates a new data point from a play contribution
   *
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisInsightFromPlayContribution?: Maybe<CreatePolarisInsightPayload>;
  /**
   * Creates a new play.  A play will manifest as a field, and play
   * contributions will manifest as insights (data points) with
   * snippets associated with the play.
   *
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisPlay?: Maybe<CreatePolarisPlayPayload>;
  /**
   * Creates or updates a contribution to a play.  The contribution
   * will manifest as an insight.  Returns an error if the contribution
   * is not acceptable to the parameters of the play, such as spending
   * more than the max amount in a BudgetAllocation ("$10 Game") play
   *
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisPlayContribution?: Maybe<CreatePolarisPlayContributionPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisStandardField?: Maybe<CreatePolarisStandardFieldPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisView?: Maybe<CreatePolarisViewPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  createPolarisViewSet?: Maybe<CreatePolarisViewSetPayload>;
  createSprint?: Maybe<CreateSprintResponse>;
  /**
   * Creates a webtrigger URL. If webtrigger url is already created for given `input` the old url will be returned
   * unless `forceCreate` flag is set to true - in that case new url will be always created.
   */
  createWebTriggerUrl?: Maybe<CreateWebTriggerUrlResponse>;
  /** This API is a wrapper for all CSP support Request mutations */
  customerSupport?: Maybe<SupportRequestCatalogMutationApi>;
  /** Deletes an application from Xen */
  deleteApp?: Maybe<DeleteAppResponse>;
  /**
   * Deletes a key-value pair for a given environment.
   *
   * This operation is idempotent.
   */
  deleteAppEnvironmentVariable?: Maybe<DeleteAppEnvironmentVariablePayload>;
  /**
   * Delete tunnels for an app
   *
   * All FaaS traffic for this app will return to invoking the deployed function
   * instead of the tunnel url.
   *
   * Same will be done for the Custom UI tunnels, where the normal CDN url will be
   * used instead of the tunnel url.
   */
  deleteAppTunnels?: Maybe<GenericMutationResponse>;
  deleteColumn?: Maybe<DeleteColumnOutput>;
  /**
   * Delete the custom filter with the specified custom filter ID
   * This mutation is currently in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: deleteCustomFilter` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deleteCustomFilter?: Maybe<GenericMutationResponse>;
  /** Remove arbitrary property keys associated with an entity (service or relationship) */
  deleteDevOpsContainerRelationshipEntityProperties?: Maybe<
    DeleteDevOpsContainerRelationshipEntityPropertiesPayload
  >;
  /** Delete a DevOps Service */
  deleteDevOpsService?: Maybe<DeleteDevOpsServicePayload>;
  /** Deletes the relationship between a DevOps Service and a Jira project */
  deleteDevOpsServiceAndJiraProjectRelationship?: Maybe<
    DeleteDevOpsServiceAndJiraProjectRelationshipPayload
  >;
  /** Delete a relationship between a DevOps Service and an Opsgenie team */
  deleteDevOpsServiceAndOpsgenieTeamRelationship?: Maybe<
    DeleteDevOpsServiceAndOpsgenieTeamRelationshipPayload
  >;
  /** Delete a relationship between a DevOps Service and a Repository */
  deleteDevOpsServiceAndRepositoryRelationship?: Maybe<
    DeleteDevOpsServiceAndRepositoryRelationshipPayload
  >;
  /** Remove arbitrary property keys associated with a DevOpsService */
  deleteDevOpsServiceEntityProperties?: Maybe<
    DeleteDevOpsServiceEntityPropertiesPayload
  >;
  /** Delete a DevOps Service Relationship */
  deleteDevOpsServiceRelationship?: Maybe<
    DeleteDevOpsServiceRelationshipPayload
  >;
  /** Delete a relationship between a Jira project and an Opsgenie team. */
  deleteJiraProjectAndOpsgenieTeamRelationship?: Maybe<
    DeleteJiraProjectAndOpsgenieTeamRelationshipPayload
  >;
  /** Delete a relationship between a Jira project and a repository. */
  deleteJiraProjectAndRepositoryRelationship?: Maybe<
    DeleteJiraProjectAndRepositoryRelationshipPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisAnonymousVisitorHash?: Maybe<
    DeletePolarisAnonymousVisitorHashPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisDecoration?: Maybe<DeletePolarisDecorationPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisField?: Maybe<DeletePolarisFieldPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisFieldOption?: Maybe<DeletePolarisFieldOptionPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisInsight?: Maybe<DeletePolarisInsightPayload>;
  /**
   * Deletes an existing contribution to a play.
   *
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisPlayContribution?: Maybe<DeletePolarisPlayContributionPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisView?: Maybe<DeletePolarisViewPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  deletePolarisViewSet?: Maybe<DeletePolarisViewSetPayload>;
  deleteSprint?: Maybe<MutationResponse>;
  /** Deletes a webtrigger URL. */
  deleteWebTriggerUrl?: Maybe<DeleteWebTriggerUrlResponse>;
  ecosystem?: Maybe<EcosystemMutation>;
  editSprint?: Maybe<SprintResponse>;
  /** Installs a given app + environment pair into a given installation context. */
  installApp?: Maybe<AppInstallationResponse>;
  /**
   * Invoke a function using the aux effects handling pipeline
   *
   * This includes some additional processing over normal invocations, including
   * validation and transformation, and expects functions to return payloads that
   * match the AUX effects spec.
   */
  invokeAuxEffects?: Maybe<InvokeAuxEffectsResponse>;
  /**
   * Invoke a function associated with a specific extension.
   *
   * This is intended to be the main way to interact with extension functions
   * created for apps
   */
  invokeExtension?: Maybe<InvokeExtensionResponse>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  invokePolarisObject?: Maybe<InvokePolarisObjectPayload>;
  /**
   * this field is added to enable self governed onboarding of Jira GraphQL types to AGG
   * see https://hello.atlassian.net/wiki/spaces/PSRV/pages/1010287708/Announcing+self+governed+APIs for more details
   */
  jira?: Maybe<JiraMutation>;
  jsw?: Maybe<JswMutation>;
  moveSprintDown?: Maybe<MoveSprintDownResponse>;
  moveSprintUp?: Maybe<MoveSprintUpResponse>;
  /**
   * This mutation is in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: BacklogEpicPanel` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  rankCardParent?: Maybe<GenericMutationResponse>;
  rankColumn?: Maybe<RankColumnOutput>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  refreshPolarisSnippets?: Maybe<RefreshPolarisSnippetsPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  resolvePolarisObject?: Maybe<ResolvePolarisObjectPayload>;
  /**
   * Sets a key-value pair for a given environment.
   *
   * It will optionally support encryption of the provided pair for sensitive variables.
   * This operation is an upsert.
   */
  setAppEnvironmentVariable?: Maybe<SetAppEnvironmentVariablePayload>;
  setColumnLimit?: Maybe<SetColumnLimitOutput>;
  setColumnName?: Maybe<SetColumnNameOutput>;
  /** Sets the estimation type for the board. Supported estimationTypes are STORY_POINTS and ORIGINAL_ESTIMATE */
  setEstimationType?: Maybe<GenericMutationResponse>;
  /**
   * Sets the outbound-auth service credentials in a specific environment for a given app.
   *
   * This makes the assumption that the environment (and hence container) was already created,
   * and the deploy containing the relevant outbound-auth service definition was already deployed.
   */
  setExternalAuthCredentials?: Maybe<SetExternalAuthCredentialsPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  setPolarisProjectOnboarded?: Maybe<SetPolarisProjectOnboardedPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  setPolarisSelectedDeliveryProject?: Maybe<
    SetPolarisSelectedDeliveryProjectPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  setPolarisSnippetPropertiesConfig?: Maybe<
    SetPolarisSnippetPropertiesConfigPayload
  >;
  /**
   * Sets the admin swimlane strategy for the board.  Use NONE is not using swimlanes.
   * Strategy effects everyone who views the board.
   */
  setSwimlaneStrategy?: Maybe<SetSwimlaneStrategyResponse>;
  /**
   * Sets the user swimlane strategy for the board.  Use NONE if not using swimlanes.
   * Strategy affects the current user alone.
   */
  setUserSwimlaneStrategy?: Maybe<SetSwimlaneStrategyResponse>;
  startSprint?: Maybe<SprintResponse>;
  subscribeToApp?: Maybe<AppSubscribePayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  unarchivePolarisInsights?: Maybe<UnarchivePolarisInsightsPayload>;
  unassignIssueParent?: Maybe<UnassignIssueParentOutput>;
  /** Uninstalls a given app + environment pair into a given installation context. */
  uninstallApp?: Maybe<AppUninstallationResponse>;
  unsubscribeFromApp?: Maybe<AppUnsubscribePayload>;
  /** Stop watching Marketplace App for updates */
  unwatchMarketplaceApp?: Maybe<UnwatchMarketplaceAppPayload>;
  updateAppDetails?: Maybe<UpdateAppDetailsResponse>;
  /** Update Atlassian OAuth Client details */
  updateAtlassianOAuthClient?: Maybe<UpdateAtlassianOAuthClientResponse>;
  /**
   * Update the custom filter with the specified custom filter ID
   * This mutation is currently in BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: updateCustomFilter` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updateCustomFilter?: Maybe<CustomFilterCreateOutput>;
  /** Add or change arbitrary (key, value) properties associated with an entity (service or relationship) */
  updateDevOpsContainerRelationshipEntityProperties?: Maybe<
    UpdateDevOpsContainerRelationshipEntityPropertiesPayload
  >;
  /** Update a DevOps Service */
  updateDevOpsService?: Maybe<UpdateDevOpsServicePayload>;
  /** Updates a relationship between a DevOps Service and a Jira project. */
  updateDevOpsServiceAndJiraProjectRelationship?: Maybe<
    UpdateDevOpsServiceAndJiraProjectRelationshipPayload
  >;
  /** Update description for a relationship between a DevOps Service and an Opsgenie team. */
  updateDevOpsServiceAndOpsgenieTeamRelationship?: Maybe<
    UpdateDevOpsServiceAndOpsgenieTeamRelationshipPayload
  >;
  /** Update a relationship between a DevOps Service and a repository */
  updateDevOpsServiceAndRepositoryRelationship?: Maybe<
    UpdateDevOpsServiceAndRepositoryRelationshipPayload
  >;
  /** Add or change arbitrary (key, value) properties associated with a DevOpsService */
  updateDevOpsServiceEntityProperties?: Maybe<
    UpdateDevOpsServiceEntityPropertiesPayload
  >;
  /** Update an DevOps Service Relationship */
  updateDevOpsServiceRelationship?: Maybe<
    UpdateDevOpsServiceRelationshipPayload
  >;
  /** Allows site admins to grant Forge log access to the app developer */
  updateDeveloperLogAccess?: Maybe<UpdateDeveloperLogAccessPayload>;
  /** Update a relationship between a Jira project and an Opsgenie team. */
  updateJiraProjectAndOpsgenieTeamRelationship?: Maybe<
    UpdateJiraProjectAndOpsgenieTeamRelationshipPayload
  >;
  /** Update a relationship between a Jira project and a repository. */
  updateJiraProjectAndRepositoryRelationship?: Maybe<
    UpdateJiraProjectAndRepositoryRelationshipPayload
  >;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisCalculatedField?: Maybe<UpdatePolarisCalculatedFieldPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisComment?: Maybe<UpdatePolarisCommentPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisDecoration?: Maybe<UpdatePolarisDecorationPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisFieldDescription?: Maybe<UpdatePolarisFieldDescriptionPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisFieldOptionWeight?: Maybe<UpdatePolarisFieldOptionWeightPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisIdea?: Maybe<UpdatePolarisIdeaPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisInsight?: Maybe<UpdatePolarisInsightPayload>;
  /**
   * Updates an existing contribution to a play.
   *
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisPlayContribution?: Maybe<UpdatePolarisPlayContributionPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisTermsConsent?: Maybe<UpdatePolarisTermsConsentPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisView?: Maybe<UpdatePolarisViewPayload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisViewRankV2?: Maybe<UpdatePolarisViewRankV2Payload>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  updatePolarisViewSet?: Maybe<UpdatePolarisViewSetPayload>;
  /** Upgrades a given app + environment pair into a given installation context. */
  upgradeApp?: Maybe<AppInstallationUpgradeResponse>;
  userAuthTokenForExtension: UserAuthTokenForExtensionResponse;
  /** Start watching Marketplace App for updates */
  watchMarketplaceApp?: Maybe<WatchMarketplaceAppPayload>;
};

export type MutationApplyPolarisProjectTemplateArgs = {
  input: ApplyPolarisProjectTemplateInput;
};

export type MutationArchivePolarisInsightsArgs = {
  containers?: Maybe<Array<Scalars['ID']>>;
  project: Scalars['ID'];
};

export type MutationAssignIssueParentArgs = {
  input?: Maybe<AssignIssueParentInput>;
};

export type MutationBoardCardMoveArgs = {
  input?: Maybe<BoardCardMoveInput>;
};

export type MutationCompleteSprintArgs = {
  input?: Maybe<CompleteSprintInput>;
};

export type MutationConfigurePolarisRefreshArgs = {
  input: ConfigurePolarisRefreshInput;
};

export type MutationCopyPolarisInsightsArgs = {
  input: CopyPolarisInsightsInput;
};

export type MutationCreateAppArgs = {
  input: CreateAppInput;
};

export type MutationCreateAppDeploymentArgs = {
  input: CreateAppDeploymentInput;
};

export type MutationCreateAppDeploymentUrlArgs = {
  input: CreateAppDeploymentUrlInput;
};

export type MutationCreateAppTunnelsArgs = {
  input: CreateAppTunnelsInput;
};

export type MutationCreateCardParentArgs = {
  input: CardParentCreateInput;
};

export type MutationCreateColumnArgs = {
  input?: Maybe<CreateColumnInput>;
};

export type MutationCreateCustomFilterArgs = {
  input?: Maybe<CreateCustomFilterInput>;
};

export type MutationCreateDevOpsServiceArgs = {
  input: CreateDevOpsServiceInput;
};

export type MutationCreateDevOpsServiceAndJiraProjectRelationshipArgs = {
  input: CreateDevOpsServiceAndJiraProjectRelationshipInput;
};

export type MutationCreateDevOpsServiceAndOpsgenieTeamRelationshipArgs = {
  input: CreateDevOpsServiceAndOpsgenieTeamRelationshipInput;
};

export type MutationCreateDevOpsServiceAndRepositoryRelationshipArgs = {
  input: CreateDevOpsServiceAndRepositoryRelationshipInput;
};

export type MutationCreateDevOpsServiceRelationshipArgs = {
  input: CreateDevOpsServiceRelationshipInput;
};

export type MutationCreateHostedResourceUploadUrlArgs = {
  input: CreateHostedResourceUploadUrlInput;
};

export type MutationCreateJiraProjectAndOpsgenieTeamRelationshipArgs = {
  input: CreateJiraProjectAndOpsgenieTeamRelationshipInput;
};

export type MutationCreateJiraProjectAndRepositoryRelationshipArgs = {
  input: CreateJiraProjectAndRepositoryRelationshipInput;
};

export type MutationCreatePolarisAnonymousVisitorHashArgs = {
  id: Scalars['ID'];
};

export type MutationCreatePolarisCalculatedFieldArgs = {
  input: CreatePolarisCalculatedField;
};

export type MutationCreatePolarisCommentArgs = {
  input: CreatePolarisCommentInput;
};

export type MutationCreatePolarisDecorationArgs = {
  input: CreatePolarisDecorationInput;
};

export type MutationCreatePolarisInsightArgs = {
  input: CreatePolarisInsightInput;
};

export type MutationCreatePolarisInsightFromPlayContributionArgs = {
  input?: Maybe<CreatePolarisInsightFromPlayContributionInput>;
};

export type MutationCreatePolarisPlayArgs = {
  input: CreatePolarisPlayInput;
};

export type MutationCreatePolarisPlayContributionArgs = {
  input: CreatePolarisPlayContribution;
};

export type MutationCreatePolarisStandardFieldArgs = {
  input: CreatePolarisStandardFieldInput;
};

export type MutationCreatePolarisViewArgs = {
  input: CreatePolarisViewInput;
};

export type MutationCreatePolarisViewSetArgs = {
  input: CreatePolarisViewSetInput;
};

export type MutationCreateSprintArgs = {
  input?: Maybe<CreateSprintInput>;
};

export type MutationCreateWebTriggerUrlArgs = {
  forceCreate?: Maybe<Scalars['Boolean']>;
  input: WebTriggerUrlInput;
};

export type MutationDeleteAppArgs = {
  input: DeleteAppInput;
};

export type MutationDeleteAppEnvironmentVariableArgs = {
  input: DeleteAppEnvironmentVariableInput;
};

export type MutationDeleteAppTunnelsArgs = {
  input: DeleteAppTunnelInput;
};

export type MutationDeleteColumnArgs = {
  input?: Maybe<DeleteColumnInput>;
};

export type MutationDeleteCustomFilterArgs = {
  input?: Maybe<DeleteCustomFilterInput>;
};

export type MutationDeleteDevOpsContainerRelationshipEntityPropertiesArgs = {
  input: DeleteDevOpsContainerRelationshipEntityPropertiesInput;
};

export type MutationDeleteDevOpsServiceArgs = {
  input: DeleteDevOpsServiceInput;
};

export type MutationDeleteDevOpsServiceAndJiraProjectRelationshipArgs = {
  input: DeleteDevOpsServiceAndJiraProjectRelationshipInput;
};

export type MutationDeleteDevOpsServiceAndOpsgenieTeamRelationshipArgs = {
  input: DeleteDevOpsServiceAndOpsgenieTeamRelationshipInput;
};

export type MutationDeleteDevOpsServiceAndRepositoryRelationshipArgs = {
  input: DeleteDevOpsServiceAndRepositoryRelationshipInput;
};

export type MutationDeleteDevOpsServiceEntityPropertiesArgs = {
  input: DeleteDevOpsServiceEntityPropertiesInput;
};

export type MutationDeleteDevOpsServiceRelationshipArgs = {
  input: DeleteDevOpsServiceRelationshipInput;
};

export type MutationDeleteJiraProjectAndOpsgenieTeamRelationshipArgs = {
  input: DeleteJiraProjectAndOpsgenieTeamRelationshipInput;
};

export type MutationDeleteJiraProjectAndRepositoryRelationshipArgs = {
  input: DeleteJiraProjectAndRepositoryRelationshipInput;
};

export type MutationDeletePolarisAnonymousVisitorHashArgs = {
  hash: Scalars['String'];
};

export type MutationDeletePolarisDecorationArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePolarisFieldArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePolarisFieldOptionArgs = {
  input: DeletePolarisFieldOptionInput;
};

export type MutationDeletePolarisInsightArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePolarisPlayContributionArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePolarisViewArgs = {
  id: Scalars['ID'];
};

export type MutationDeletePolarisViewSetArgs = {
  id: Scalars['ID'];
};

export type MutationDeleteSprintArgs = {
  input?: Maybe<DeleteSprintInput>;
};

export type MutationDeleteWebTriggerUrlArgs = {
  id: Scalars['ID'];
};

export type MutationEditSprintArgs = {
  input?: Maybe<EditSprintInput>;
};

export type MutationInstallAppArgs = {
  input: AppInstallationInput;
};

export type MutationInvokeAuxEffectsArgs = {
  input: InvokeAuxEffectsInput;
};

export type MutationInvokeExtensionArgs = {
  input: InvokeExtensionInput;
};

export type MutationInvokePolarisObjectArgs = {
  input: InvokePolarisObjectInput;
};

export type MutationMoveSprintDownArgs = {
  input?: Maybe<MoveSprintDownInput>;
};

export type MutationMoveSprintUpArgs = {
  input?: Maybe<MoveSprintUpInput>;
};

export type MutationRankCardParentArgs = {
  input: CardParentRankInput;
};

export type MutationRankColumnArgs = {
  input?: Maybe<RankColumnInput>;
};

export type MutationRefreshPolarisSnippetsArgs = {
  input: RefreshPolarisSnippetsInput;
};

export type MutationResolvePolarisObjectArgs = {
  input: ResolvePolarisObjectInput;
};

export type MutationSetAppEnvironmentVariableArgs = {
  input: SetAppEnvironmentVariableInput;
};

export type MutationSetColumnLimitArgs = {
  input?: Maybe<SetColumnLimitInput>;
};

export type MutationSetColumnNameArgs = {
  input?: Maybe<SetColumnNameInput>;
};

export type MutationSetEstimationTypeArgs = {
  input?: Maybe<SetEstimationTypeInput>;
};

export type MutationSetExternalAuthCredentialsArgs = {
  input: SetExternalAuthCredentialsInput;
};

export type MutationSetPolarisProjectOnboardedArgs = {
  input: SetPolarisProjectOnboardedInput;
};

export type MutationSetPolarisSelectedDeliveryProjectArgs = {
  input: SetPolarisSelectedDeliveryProjectInput;
};

export type MutationSetPolarisSnippetPropertiesConfigArgs = {
  input: SetPolarisSnippetPropertiesConfigInput;
};

export type MutationSetSwimlaneStrategyArgs = {
  input?: Maybe<SetSwimlaneStrategyInput>;
};

export type MutationSetUserSwimlaneStrategyArgs = {
  input?: Maybe<SetSwimlaneStrategyInput>;
};

export type MutationStartSprintArgs = {
  input?: Maybe<StartSprintInput>;
};

export type MutationSubscribeToAppArgs = {
  input: AppSubscribeInput;
};

export type MutationUnarchivePolarisInsightsArgs = {
  containers?: Maybe<Array<Scalars['ID']>>;
  project: Scalars['ID'];
};

export type MutationUnassignIssueParentArgs = {
  input?: Maybe<UnassignIssueParentInput>;
};

export type MutationUninstallAppArgs = {
  input: AppUninstallationInput;
};

export type MutationUnsubscribeFromAppArgs = {
  input: AppUnsubscribeInput;
};

export type MutationUnwatchMarketplaceAppArgs = {
  id: Scalars['ID'];
};

export type MutationUpdateAppDetailsArgs = {
  input: UpdateAppDetailsInput;
};

export type MutationUpdateAtlassianOAuthClientArgs = {
  input: UpdateAtlassianOAuthClientInput;
};

export type MutationUpdateCustomFilterArgs = {
  input?: Maybe<UpdateCustomFilterInput>;
};

export type MutationUpdateDevOpsContainerRelationshipEntityPropertiesArgs = {
  input: UpdateDevOpsContainerRelationshipEntityPropertiesInput;
};

export type MutationUpdateDevOpsServiceArgs = {
  input: UpdateDevOpsServiceInput;
};

export type MutationUpdateDevOpsServiceAndJiraProjectRelationshipArgs = {
  input: UpdateDevOpsServiceAndJiraProjectRelationshipInput;
};

export type MutationUpdateDevOpsServiceAndOpsgenieTeamRelationshipArgs = {
  input: UpdateDevOpsServiceAndOpsgenieTeamRelationshipInput;
};

export type MutationUpdateDevOpsServiceAndRepositoryRelationshipArgs = {
  input: UpdateDevOpsServiceAndRepositoryRelationshipInput;
};

export type MutationUpdateDevOpsServiceEntityPropertiesArgs = {
  input: UpdateDevOpsServiceEntityPropertiesInput;
};

export type MutationUpdateDevOpsServiceRelationshipArgs = {
  input: UpdateDevOpsServiceRelationshipInput;
};

export type MutationUpdateDeveloperLogAccessArgs = {
  input: UpdateDeveloperLogAccessInput;
};

export type MutationUpdateJiraProjectAndOpsgenieTeamRelationshipArgs = {
  input: UpdateJiraProjectAndOpsgenieTeamRelationshipInput;
};

export type MutationUpdateJiraProjectAndRepositoryRelationshipArgs = {
  input: UpdateJiraProjectAndRepositoryRelationshipInput;
};

export type MutationUpdatePolarisCalculatedFieldArgs = {
  input: UpdatePolarisCalculatedFieldInput;
};

export type MutationUpdatePolarisCommentArgs = {
  input: UpdatePolarisCommentInput;
};

export type MutationUpdatePolarisDecorationArgs = {
  delete?: Maybe<DeletePolarisDecorationInput>;
  id: Scalars['ID'];
  update?: Maybe<UpdatePolarisDecorationInput>;
};

export type MutationUpdatePolarisFieldDescriptionArgs = {
  input: UpdatePolarisFieldDescriptionInput;
};

export type MutationUpdatePolarisFieldOptionWeightArgs = {
  input: UpdatePolarisFieldOptionWeightInput;
};

export type MutationUpdatePolarisIdeaArgs = {
  idea: Scalars['ID'];
  project: Scalars['ID'];
  update: UpdatePolarisIdeaInput;
};

export type MutationUpdatePolarisInsightArgs = {
  id: Scalars['ID'];
  update: UpdatePolarisInsightInput;
};

export type MutationUpdatePolarisPlayContributionArgs = {
  id: Scalars['ID'];
  input: UpdatePolarisPlayContribution;
};

export type MutationUpdatePolarisTermsConsentArgs = {
  input: UpdatePolarisTermsConsentInput;
};

export type MutationUpdatePolarisViewArgs = {
  id: Scalars['ID'];
  input: UpdatePolarisViewInput;
};

export type MutationUpdatePolarisViewRankV2Args = {
  id: Scalars['ID'];
  input: UpdatePolarisViewRankInput;
};

export type MutationUpdatePolarisViewSetArgs = {
  input: UpdatePolarisViewSetInput;
};

export type MutationUpgradeAppArgs = {
  input: AppInstallationUpgradeInput;
};

export type MutationUserAuthTokenForExtensionArgs = {
  input: UserAuthTokenForExtensionInput;
};

export type MutationWatchMarketplaceAppArgs = {
  id: Scalars['ID'];
};

/** An error that has occurred in response to a mutation */
export type MutationError = {
  __typename?: 'MutationError';
  /** A list of extension properties to the error */
  extensions?: Maybe<MutationErrorExtension>;
  /** A human readable error message */
  message?: Maybe<Scalars['String']>;
};

/**
 * A error type that can be returned in response to a failed mutation
 *
 * This extension carries additional categorisation information about the error
 */
export type MutationErrorExtension = {
  /** Application specific error type */
  errorType?: Maybe<Scalars['String']>;
  /** A numerical code (such as a HTTP status code) representing the error category */
  statusCode?: Maybe<Scalars['Int']>;
};

/**
 * A mutation response interface.
 *
 * According to the Atlassian standards, all mutations should return a type which implements this interface.
 *
 * [Apollo GraphQL Documentation](https://www.apollographql.com/docs/apollo-server/essentials/schema#mutation-responses)
 */
export type MutationResponse = {
  /** A message for this mutation */
  message: Scalars['String'];
  /** A numerical code (such as a HTTP status code) representing the status of the mutation */
  statusCode: Scalars['Int'];
  /** Was this mutation successful */
  success: Scalars['Boolean'];
};

export type MyActivities = {
  __typename?: 'MyActivities';
  /**
   * get all activity for the currently logged in user
   * - filters - query filters for the activity stream
   * - first - show 1st <N> items of the response
   */
  all?: Maybe<ActivitiesConnection>;
  /**
   * get "viewed" activity for the currently logged in user
   * - filters - query filters for the activity stream
   * - first - show 1st <N> items of the response
   */
  viewed?: Maybe<ActivitiesConnection>;
  /**
   * get "worked on" activity for the currently logged in user
   * - filters - query filters for the activity stream
   * - first - show 1st <N> items of the response
   */
  workedOn?: Maybe<ActivitiesConnection>;
};

export type MyActivitiesAllArgs = {
  after?: Maybe<Scalars['String']>;
  filters?: Maybe<Array<ActivitiesFilter>>;
  first?: Maybe<Scalars['Int']>;
};

export type MyActivitiesViewedArgs = {
  after?: Maybe<Scalars['String']>;
  filters?: Maybe<Array<ActivitiesFilter>>;
  first?: Maybe<Scalars['Int']>;
};

export type MyActivitiesWorkedOnArgs = {
  after?: Maybe<Scalars['String']>;
  filters?: Maybe<Array<ActivitiesFilter>>;
  first?: Maybe<Scalars['Int']>;
};

/** This allows you to hydrate new values into fields */
export type NadelHydrationArgument = {
  name: Scalars['String'];
  value: Scalars['String'];
};

export type NewCardParent = {
  issueTypeId: Scalars['ID'];
  summary: Scalars['String'];
};

/**
 * From the [relay Node specification](https://relay.dev/graphql/objectidentification.htm#sec-Node-Interface)
 *
 * The server must provide an interface called `Node`. That interface must include
 * exactly one field, called `id` that returns a non-null `ID`.
 *
 * This `id` should be a globally unique identifier for this object, and given just
 * this `id`, the server should be able to refetch the object.
 */
export type Node = {
  id: Scalars['ID'];
};

export type OpsgenieAlertCountByPriority = {
  __typename?: 'OpsgenieAlertCountByPriority';
  countPerDay?: Maybe<Array<Maybe<OpsgenieAlertCountPerDay>>>;
  priority?: Maybe<Scalars['String']>;
};

export type OpsgenieAlertCountPerDay = {
  __typename?: 'OpsgenieAlertCountPerDay';
  count?: Maybe<Scalars['Int']>;
  day?: Maybe<Scalars['String']>;
};

export type OpsgenieQuery = {
  __typename?: 'OpsgenieQuery';
  allOpsgenieTeams?: Maybe<OpsgenieTeamConnection>;
  myOpsgenieSchedules?: Maybe<Array<Maybe<OpsgenieSchedule>>>;
  opsgenieTeam?: Maybe<OpsgenieTeam>;
  /** for hydration batching, restricted to 25. */
  opsgenieTeams?: Maybe<Array<Maybe<OpsgenieTeam>>>;
  opsgenieTeamsWithServiceModificationPermissions?: Maybe<
    OpsgenieTeamConnection
  >;
};

export type OpsgenieQueryAllOpsgenieTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type OpsgenieQueryMyOpsgenieSchedulesArgs = {
  cloudId: Scalars['ID'];
};

export type OpsgenieQueryOpsgenieTeamArgs = {
  id: Scalars['ID'];
};

export type OpsgenieQueryOpsgenieTeamsArgs = {
  ids: Array<Scalars['ID']>;
};

export type OpsgenieQueryOpsgenieTeamsWithServiceModificationPermissionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type OpsgenieSchedule = {
  __typename?: 'OpsgenieSchedule';
  enabled?: Maybe<Scalars['Boolean']>;
  finalTimeline?: Maybe<OpsgenieScheduleTimeline>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
};

export type OpsgenieScheduleFinalTimelineArgs = {
  endTime: Scalars['DateTime'];
  startTime: Scalars['DateTime'];
};

export type OpsgenieSchedulePeriod = {
  __typename?: 'OpsgenieSchedulePeriod';
  endDate?: Maybe<Scalars['DateTime']>;
  /**  Enum? */
  recipient?: Maybe<OpsgenieSchedulePeriodRecipient>;
  startDate?: Maybe<Scalars['DateTime']>;
  type?: Maybe<Scalars['String']>;
};

export type OpsgenieSchedulePeriodRecipient = {
  __typename?: 'OpsgenieSchedulePeriodRecipient';
  id?: Maybe<Scalars['ID']>;
  type?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export type OpsgenieScheduleRotation = {
  __typename?: 'OpsgenieScheduleRotation';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  order?: Maybe<Scalars['Int']>;
  periods?: Maybe<Array<Maybe<OpsgenieSchedulePeriod>>>;
};

export type OpsgenieScheduleTimeline = {
  __typename?: 'OpsgenieScheduleTimeline';
  endDate?: Maybe<Scalars['DateTime']>;
  rotations?: Maybe<Array<Maybe<OpsgenieScheduleRotation>>>;
  startDate?: Maybe<Scalars['DateTime']>;
};

export type OpsgenieTeam = Node & {
  __typename?: 'OpsgenieTeam';
  alertCounts?: Maybe<Array<Maybe<OpsgenieAlertCountByPriority>>>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  /** The connection entity for DevOps Service relationships for this Opsgenie team. */
  devOpsServiceRelationships?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationshipConnection
  >;
  id: Scalars['ID'];
  /** The connection entity for Jira project relationships for this Opsgenie team. */
  jiraProjectRelationships?: Maybe<
    JiraProjectAndOpsgenieTeamRelationshipConnection
  >;
  members?: Maybe<OpsgenieTeamMemberConnection>;
  /**  ARI */
  name?: Maybe<Scalars['String']>;
  schedules?: Maybe<Array<Maybe<OpsgenieSchedule>>>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['String']>;
};

export type OpsgenieTeamAlertCountsArgs = {
  endTime: Scalars['DateTime'];
  startTime: Scalars['DateTime'];
  tags?: Maybe<Array<Scalars['String']>>;
  timezone?: Maybe<Scalars['String']>;
};

export type OpsgenieTeamDevOpsServiceRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type OpsgenieTeamJiraProjectRelationshipsArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
};

export type OpsgenieTeamMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type OpsgenieTeamConnection = {
  __typename?: 'OpsgenieTeamConnection';
  edges?: Maybe<Array<Maybe<OpsgenieTeamEdge>>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

export type OpsgenieTeamEdge = {
  __typename?: 'OpsgenieTeamEdge';
  cursor: Scalars['String'];
  node?: Maybe<OpsgenieTeam>;
};

export type OpsgenieTeamMember = {
  __typename?: 'OpsgenieTeamMember';
  user?: Maybe<User>;
};

export type OpsgenieTeamMemberConnection = {
  __typename?: 'OpsgenieTeamMemberConnection';
  edges?: Maybe<Array<Maybe<OpsgenieTeamMemberEdge>>>;
  pageInfo: PageInfo;
};

export type OpsgenieTeamMemberEdge = {
  __typename?: 'OpsgenieTeamMemberEdge';
  cursor: Scalars['String'];
  node?: Maybe<OpsgenieTeamMember>;
};

export type OriginalEstimate = {
  __typename?: 'OriginalEstimate';
  value?: Maybe<Scalars['Float']>;
  valueAsText?: Maybe<Scalars['String']>;
};

/**
 * Relay-style PageInfo type.
 *
 * See [PageInfo specification](https://relay.dev/assets/files/connections-932f4f2cdffd79724ac76373deb30dc8.htm#sec-undefined.PageInfo)
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** endCursor must be the cursor corresponding to the last node in `edges`. */
  endCursor?: Maybe<Scalars['String']>;
  /**
   * `hasNextPage` is used to indicate whether more edges exist following the set
   * defined by the clients arguments. If the client is paginating
   * with `first` / `after`, then the server must return true if further edges
   * exist, otherwise false. If the client is paginating with `last` / `before`,
   * then the client may return true if edges further from before exist, if it can
   * do so efficiently, otherwise may return false.
   */
  hasNextPage: Scalars['Boolean'];
  /**
   * `hasPreviousPage` is used to indicate whether more edges exist prior to the
   * set defined by the clients arguments. If the client is paginating
   * with `last` / `before`, then the server must return true if prior edges exist,
   * otherwise false. If the client is paginating with `first` / `after`,
   * then the client may return true if edges prior to after exist, if it can do so efficiently, otherwise may return false.
   */
  hasPreviousPage: Scalars['Boolean'];
  /** startCursor must be the cursor corresponding to the first node in `edges`. */
  startCursor?: Maybe<Scalars['String']>;
};

/** The general shape of a mutation response. */
export type Payload = {
  /** A list of errors if the mutation was not successful */
  errors?: Maybe<Array<MutationError>>;
  /** Was this mutation successful */
  success: Scalars['Boolean'];
};

export type PolarisAnonymousVisitorHash = PolarisAnonymousVisitorViewHash;

export type PolarisAnonymousVisitorViewHash = {
  __typename?: 'PolarisAnonymousVisitorViewHash';
  cloudId: Scalars['String'];
  hash: Scalars['String'];
  projectId: Scalars['Int'];
  projectKey: Scalars['String'];
  viewId: Scalars['Int'];
};

export type PolarisComment = {
  __typename?: 'PolarisComment';
  aaid: Scalars['String'];
  account?: Maybe<User>;
  content: Scalars['JSON'];
  created: Scalars['String'];
  id: Scalars['ID'];
  kind: PolarisCommentKind;
  subject: Scalars['ID'];
  updated: Scalars['String'];
};

export enum PolarisCommentKind {
  PLAY_CONTRIBUTION = 'PLAY_CONTRIBUTION',
  VIEW = 'VIEW',
}

export type PolarisConnectApp = {
  __typename?: 'PolarisConnectApp';
  /**
   * appId is the CaaS app id.  Note that a single app may have
   * multiple oauth client ids, notably when deployed in different
   * environments such as staging and production
   */
  appId?: Maybe<Scalars['String']>;
  /** avatarUrl of CaaS app */
  avatarUrl: Scalars['String'];
  /**
   * the oauthClientId, which functions as the unique identifier id of CaaS app
   * for our purposes
   */
  id: Scalars['ID'];
  /** name of CaaS app */
  name: Scalars['String'];
  /** oauthClientId of CaaS app */
  oauthClientId: Scalars['String'];
  play?: Maybe<PolarisPlay>;
};

export type PolarisDecoration = {
  __typename?: 'PolarisDecoration';
  id: Scalars['ID'];
  /** The decoration to apply to a matched value. */
  valueDecoration: PolarisValueDecoration;
  /** The decoration can be applied when a value matches all rules in this array. */
  valueRules: Array<PolarisValueRule>;
};

export type PolarisDecorationScheme = {
  __typename?: 'PolarisDecorationScheme';
  fields: Array<PolarisIdeaField>;
  id: Scalars['ID'];
};

export type PolarisDelegationToken = {
  __typename?: 'PolarisDelegationToken';
  expires: Scalars['String'];
  token: Scalars['String'];
  url: Scalars['String'];
};

/** ##### Input ####### */
export enum PolarisFieldType {
  POLARISIDEADATEFIELD = 'PolarisIdeaDateField',
  POLARISIDEADATETIMEFIELD = 'PolarisIdeaDateTimeField',
  POLARISIDEALABELSFIELD = 'PolarisIdeaLabelsField',
  POLARISIDEANUMBERFIELD = 'PolarisIdeaNumberField',
  POLARISIDEAOPTIONFIELD = 'PolarisIdeaOptionField',
  POLARISIDEAOPTIONSFIELD = 'PolarisIdeaOptionsField',
  POLARISIDEAPLAYFIELD = 'PolarisIdeaPlayField',
  POLARISIDEASTRINGFIELD = 'PolarisIdeaStringField',
  POLARISIDEAUSERFIELD = 'PolarisIdeaUserField',
  POLARISIDEAUSERSFIELD = 'PolarisIdeaUsersField',
}

export type PolarisFilterInput = {
  jql?: Maybe<Scalars['String']>;
};

export type PolarisGroupValue = {
  __typename?: 'PolarisGroupValue';
  /**  a label value (which has no identity besides its string value) */
  id?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
};

export type PolarisGroupValueInput = {
  /**  a label value (which has no identity besides its string value) */
  id?: Maybe<Scalars['String']>;
  label?: Maybe<Scalars['String']>;
};

export type PolarisIdea = {
  __typename?: 'PolarisIdea';
  archived?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  lastCommentsViewedTimestamp?: Maybe<Scalars['String']>;
  lastInsightsViewedTimestamp?: Maybe<Scalars['String']>;
};

export type PolarisIdeaArchivedByField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaArchivedByField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaArchivedField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaArchivedField';
  archivedOption: PolarisIdeaFieldOption;
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaArchivedOnField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaArchivedOnField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaDateField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaDateField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaDateTimeField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaDateTimeField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaDocumentField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaDocumentField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

/**
 * An PolarisIdeaField is a unit of information that can be instantiated
 * for an PolarisIdea.
 */
export type PolarisIdeaField = {
  /**
   * An identifier for fields built in to Jira or Polaris.  For example, "Key" and
   * "Delivery progress" are builtin fields.
   */
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  /**
   * Values stored in this field can be decorated with visual elements
   * (emojis, colors, backgrounds) for distinction. For discrete types
   * such as Single/Multi select these will typically be exact matches
   * on the static values allowed by the field. For orderable types
   * such as strings, dates, numbers, etc decorations will more
   * commonly be applied using ranges.
   */
  decorations?: Maybe<Array<PolarisDecoration>>;
  /**
   * What is the default sort order?  This is the order you get on
   * "first click" of the column, and also the semantics of "ORDER BY"
   * without an ASC or DESC qualifier.
   */
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  /** Description */
  description?: Maybe<Scalars['String']>;
  /**
   * Are values in this field directly editable?  Some integrations
   * might bring in data that is not directly editable.
   */
  editable: Scalars['Boolean'];
  /**
   * A short identifier suitable for at least within this project,
   * but only supplied for fields that are returned via an PolarisIdea's fields
   * attribute.  If not present, this field represents a builtin field
   * on PolarisIdea.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Field no longer supported
   */
  fieldId?: Maybe<Scalars['Int']>;
  /**
   * The name of the field built in to PolarisIdea, if this field represents
   * a builtin field.
   *
   *
   * This field is **deprecated** and will be removed in the future
   * @deprecated Field no longer supported
   */
  fieldName?: Maybe<Scalars['String']>;
  /** The formula for calculated fields; null for regular (stored) fields */
  formula?: Maybe<Scalars['JSON']>;
  /**
   * Is this field suitable for grouping operations like Board view?
   * (i.e., may it appear in the groupBy field in a view?)
   */
  groupable: Scalars['Boolean'];
  /** The fully qualified globally unique id (ARI) for this field */
  id: Scalars['ID'];
  /**
   * The key of this field in the `fields` structure if it is a Jira
   * field.  Not set for things that don't appear in the fields section
   * of a Jira issue object, such as "key"
   */
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  /**
   * Is this field suitable for linear operations like plotting on an axis?
   * (i.e., may it appear in the x or y field in a view?)
   */
  linearizable: Scalars['Boolean'];
  /**
   * Refines how we should present the field.  For example, a number
   * field might be presented with a Rating picker.
   */
  presentation?: Maybe<PolarisPresentation>;
  /**
   * Can rows be sorted by this field?  Some fields are not commensurate
   * and hence can't be sorted.
   */
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaFieldOption = {
  __typename?: 'PolarisIdeaFieldOption';
  id: Scalars['ID'];
  label: Scalars['String'];
  weight: Scalars['Int'];
};

export type PolarisIdeaIssueCommentsField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaIssueCommentsField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaIssueIdField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaIssueIdField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  /**  null, since the issueid is not a jira field */
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaIssueTypeField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaIssueTypeField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaKeyField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaKeyField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  /**  null, since the key field is not a jira field */
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaLabelsField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaLabelsField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaLinkedIssuesField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaLinkedIssuesField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaLinkedIssuesProgressField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaLinkedIssuesProgressField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaNumberField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaNumberField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaOptionField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaOptionField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  options?: Maybe<Array<PolarisIdeaFieldOption>>;
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaOptionsField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaOptionsField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  options?: Maybe<Array<PolarisIdeaFieldOption>>;
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaPlayField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaPlayField';
  /**  the associated play */
  aspect?: Maybe<Scalars['String']>;
  /**  the aspect of the play does this field represent (null=default) */
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  /**  probably nothing here for now */
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  play?: Maybe<PolarisPlay>;
  /**  no formula support for now */
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeas = {
  __typename?: 'PolarisIdeas';
  ideas?: Maybe<Array<PolarisRestIdea>>;
  total: Scalars['Int'];
};

/**
 * this is obsolete, but needs to be removed in the opposite order of
 * being added (i.e., from JFE first, then AGG, and finally here)
 */
export type PolarisIdeaSpecialField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaSpecialField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
  specialType?: Maybe<Scalars['String']>;
};

export type PolarisIdeaStatusField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaStatusField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaStringField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaStringField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaType = {
  __typename?: 'PolarisIdeaType';
  description?: Maybe<Scalars['String']>;
  iconUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type PolarisIdeaUserField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaUserField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaUsersField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaUsersField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisIdeaVotesField = PolarisIdeaField & {
  __typename?: 'PolarisIdeaVotesField';
  builtin?: Maybe<BuiltinPolarisIdeaField>;
  decorations?: Maybe<Array<PolarisDecoration>>;
  defaultSortOrder?: Maybe<PolarisSortOrder>;
  description?: Maybe<Scalars['String']>;
  editable: Scalars['Boolean'];
  fieldId?: Maybe<Scalars['Int']>;
  fieldName?: Maybe<Scalars['String']>;
  formula?: Maybe<Scalars['JSON']>;
  groupable: Scalars['Boolean'];
  id: Scalars['ID'];
  jiraFieldKey?: Maybe<Scalars['String']>;
  label: Scalars['String'];
  linearizable: Scalars['Boolean'];
  presentation?: Maybe<PolarisPresentation>;
  sortable: Scalars['Boolean'];
};

export type PolarisInsight = {
  __typename?: 'PolarisInsight';
  /** AAID of the user who owns the insight */
  aaid: Scalars['String'];
  account?: Maybe<User>;
  /**
   * The ID of the object within the project which contains this data
   * point (nee insight), if any.  In the usual case, if not null, this
   * is an idea (issue) ARI
   */
  container?: Maybe<Scalars['ID']>;
  /**  if an insight is from a play, a link to the play */
  contribs?: Maybe<Array<PolarisPlayContribution>>;
  /** Creation time of data point in RFC3339 format */
  created: Scalars['String'];
  /**
   * Description in ADF format.  See
   * https://developer.atlassian.com/platform/atlassian-document-format/
   */
  description?: Maybe<Scalars['JSON']>;
  /**
   * ARI of the insight, for example:
   *
   *    `ari:cloud:cebeacbd-f85e-483c-96ac-fd432a12ad1c:polaris-insight/10004`
   */
  id: Scalars['ID'];
  play?: Maybe<PolarisPlay>;
  /** Array of snippets attached to this data point. */
  snippets: Array<PolarisSnippet>;
  /** Updated time of data point in RFC3339 format */
  updated: Scalars['String'];
};

export type PolarisIssueLinkType = {
  __typename?: 'PolarisIssueLinkType';
  datapoint: Scalars['Int'];
  delivery: Scalars['Int'];
  merge: Scalars['Int'];
};

export type PolarisPlay = {
  __typename?: 'PolarisPlay';
  contribution?: Maybe<PolarisPlayContribution>;
  /**  the parameters used to define the play */
  contributions?: Maybe<Array<PolarisPlayContribution>>;
  /**  if there is a specific view for this play */
  fields?: Maybe<Array<PolarisIdeaPlayField>>;
  id: Scalars['ID'];
  /**  the label for the play */
  kind: PolarisPlayKind;
  label: Scalars['String'];
  /**  if there are fields for this play */
  parameters?: Maybe<Scalars['JSON']>;
  /**  the kind of play this is */
  view?: Maybe<PolarisView>;
};

export type PolarisPlayContributionArgs = {
  id: Scalars['ID'];
};

export type PolarisPlayContribution = {
  __typename?: 'PolarisPlayContribution';
  /**  the item to which the contribution applies (the idea) */
  aaid: Scalars['String'];
  amount?: Maybe<Scalars['Int']>;
  /**  when this contribution was last updated */
  appearsIn?: Maybe<PolarisInsight>;
  /**  the author of the contribution */
  comment?: Maybe<PolarisComment>;
  created: Scalars['String'];
  id: Scalars['ID'];
  play: PolarisPlay;
  /**  the play that contains the contribution */
  subject: Scalars['ID'];
  /**  when this contribution was created */
  updated: Scalars['String'];
};

export enum PolarisPlayKind {
  POLARISBUDGETALLOCATIONPLAY = 'PolarisBudgetAllocationPlay',
}

export type PolarisPresentation = {
  __typename?: 'PolarisPresentation';
  parameters?: Maybe<Scalars['JSON']>;
  /**
   * The type of presentation.  Intended to select the UI control for this
   * field.
   */
  type: Scalars['String'];
};

export type PolarisPresentationInput = {
  parameters?: Maybe<Scalars['JSON']>;
  type: Scalars['String'];
};

export type PolarisProject = {
  __typename?: 'PolarisProject';
  /** Jira activation ID */
  activationId?: Maybe<Scalars['String']>;
  arjConfiguration: ArjConfiguration;
  arjHierarchyConfiguration?: Maybe<Array<ArjHierarchyConfigurationLevel>>;
  /** Project avatar URL */
  avatarUrls: ProjectAvatars;
  fields: Array<PolarisIdeaField>;
  /**
   * ARI of the project which is a polaris project, for example:
   *
   *    `ari:cloud:cebeacbd-f85e-483c-96ac-fd432a12ad1c:project/10004`
   */
  id: Scalars['ID'];
  /**
   * Initially only expect to have one idea type per project.  Defining
   * as a list here for future expandability.
   */
  ideaTypes: Array<PolarisIdeaType>;
  ideas: Array<PolarisIdea>;
  insights?: Maybe<Array<PolarisInsight>>;
  issueLinkType: PolarisIssueLinkType;
  /** Every Jira project has a key */
  key: Scalars['String'];
  /** Every Jira project has a name */
  name: Scalars['String'];
  onboarded: Scalars['Boolean'];
  play?: Maybe<PolarisPlay>;
  plays?: Maybe<Array<PolarisPlay>>;
  rankField?: Maybe<Scalars['ID']>;
  refreshing: PolarisRefreshStatus;
  selectedDeliveryProject?: Maybe<Scalars['ID']>;
  /**
   * OAuth clients (and potentially other data providers) that have access
   * to this project.
   */
  snippetProviders?: Maybe<Array<PolarisSnippetProvider>>;
  statusCategories?: Maybe<Array<PolarisStatusCategory>>;
  template?: Maybe<PolarisProjectTemplate>;
  views: Array<PolarisView>;
  /** The view sets associated with this project */
  viewsets?: Maybe<Array<PolarisViewSet>>;
};

export type PolarisProjectPlayArgs = {
  id: Scalars['ID'];
};

export type PolarisProjectTemplate = {
  __typename?: 'PolarisProjectTemplate';
  ideas?: Maybe<Scalars['JSON']>;
};

export enum PolarisRefreshError {
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  INVALID_SNIPPET = 'INVALID_SNIPPET',
  NEED_AUTH = 'NEED_AUTH',
  NOT_FOUND = 'NOT_FOUND',
}

export type PolarisRefreshInfo = {
  __typename?: 'PolarisRefreshInfo';
  /**  (timestamp) when will next be refreshed */
  autoSeconds?: Maybe<Scalars['Int']>;
  error?: Maybe<Scalars['String']>;
  /**  an error message */
  errorCode?: Maybe<Scalars['Int']>;
  /**  an error code */
  errorType?: Maybe<PolarisRefreshError>;
  /**  (timestamp) when it was queued */
  last?: Maybe<Scalars['String']>;
  /**  (timestamp) when was last refreshed */
  next?: Maybe<Scalars['String']>;
  /**  enum version of errorCode */
  queued?: Maybe<Scalars['String']>;
  /**  auto refresh interval in seconds */
  timeToLiveSeconds?: Maybe<Scalars['Int']>;
};

export type PolarisRefreshJob = {
  __typename?: 'PolarisRefreshJob';
  progress?: Maybe<PolarisRefreshJobProgress>;
  /**
   * If this is a synchronous refresh, we can return the newly refreshed snippets
   * directly.
   */
  refreshedSnippets?: Maybe<Array<PolarisSnippet>>;
};

export type PolarisRefreshJobProgress = {
  __typename?: 'PolarisRefreshJobProgress';
  errorCount: Scalars['Int'];
  pendingCount: Scalars['Int'];
};

export type PolarisRefreshStatus = {
  __typename?: 'PolarisRefreshStatus';
  count: Scalars['Int'];
  errors: Scalars['Int'];
  last?: Maybe<Scalars['String']>;
  pending: Scalars['Int'];
};

export enum PolarisResolvedObjectAuthType {
  API_KEY = 'API_KEY',
  OAUTH2 = 'OAUTH2',
}

export type PolarisRestIdea = {
  __typename?: 'PolarisRestIdea';
  fields: Scalars['JSON'];
  id: Scalars['String'];
  key: Scalars['String'];
};

export type PolarisSnippet = {
  __typename?: 'PolarisSnippet';
  appInfo?: Maybe<PolarisConnectApp>;
  /** Data in JSON format */
  data?: Maybe<Scalars['JSON']>;
  /**
   * ARI of the snippet, for example:
   *
   *    `ari:cloud:cebeacbd-f85e-483c-96ac-fd432a12ad1c:polaris-snippet/10004`
   */
  id: Scalars['ID'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String'];
  /** Snippet-level properties in JSON format. */
  properties?: Maybe<Scalars['JSON']>;
  /**
   * Information about the refreshing of this snippet.  Null if the snippet
   * is not refreshable.
   */
  refresh?: Maybe<PolarisRefreshInfo>;
  /** Timestamp of when the snippet was last updated */
  updated: Scalars['String'];
  /** Snippet url that is source of data */
  url?: Maybe<Scalars['String']>;
};

export type PolarisSnippetGroupDecl = {
  __typename?: 'PolarisSnippetGroupDecl';
  id: Scalars['ID'];
  key: Scalars['String'];
  /**  must be unique per PolarisSnippetProvider */
  label?: Maybe<Scalars['String']>;
  properties?: Maybe<Array<PolarisSnippetPropertyDecl>>;
};

export type PolarisSnippetPropertiesConfig = {
  __typename?: 'PolarisSnippetPropertiesConfig';
  config: Scalars['JSON'];
};

export type PolarisSnippetPropertyDecl = {
  __typename?: 'PolarisSnippetPropertyDecl';
  id: Scalars['ID'];
  key: Scalars['String'];
  kind?: Maybe<PolarisSnippetPropertyKind>;
  /**  must be unique per PolarisSnippetProvider */
  label?: Maybe<Scalars['String']>;
};

export enum PolarisSnippetPropertyKind {
  /**  1-5 integer rating */
  LABELS = 'LABELS',
  NUMBER = 'NUMBER',
  /**  generic number */
  RATING = 'RATING',
}

export type PolarisSnippetProvider = {
  __typename?: 'PolarisSnippetProvider';
  app?: Maybe<PolarisConnectApp>;
  groups?: Maybe<Array<PolarisSnippetGroupDecl>>;
  id: Scalars['ID'];
  properties?: Maybe<Array<PolarisSnippetPropertyDecl>>;
};

export type PolarisSortField = {
  __typename?: 'PolarisSortField';
  field: PolarisIdeaField;
  order?: Maybe<PolarisSortOrder>;
};

export type PolarisSortFieldInput = {
  field: Scalars['ID'];
  order?: Maybe<PolarisSortOrder>;
};

export enum PolarisSortOrder {
  ASC = 'ASC',
  DESC = 'DESC',
}

export type PolarisStatusCategory = {
  __typename?: 'PolarisStatusCategory';
  colorName: Scalars['String'];
  id: Scalars['Int'];
  key: Scalars['String'];
  name: Scalars['String'];
};

export type PolarisTermsConsent = {
  __typename?: 'PolarisTermsConsent';
  consented: Scalars['Boolean'];
  locale: Scalars['String'];
  requiresMarketingConsent: Scalars['Boolean'];
};

export type PolarisValueDecoration = {
  __typename?: 'PolarisValueDecoration';
  backgroundColor?: Maybe<Scalars['String']>;
  emoji?: Maybe<Scalars['String']>;
  highlightContainer?: Maybe<Scalars['Boolean']>;
};

export type PolarisValueDecorationInput = {
  backgroundColor?: Maybe<Scalars['String']>;
  emoji?: Maybe<Scalars['String']>;
  highlightContainer?: Maybe<Scalars['Boolean']>;
};

export enum PolarisValueOperator {
  EQ = 'EQ',
  GT = 'GT',
  GTE = 'GTE',
  LT = 'LT',
  LTE = 'LTE',
}

export type PolarisValueRule = {
  __typename?: 'PolarisValueRule';
  operator: PolarisValueOperator;
  value: Scalars['String'];
};

export type PolarisValueRuleInput = {
  operator: PolarisValueOperator;
  value: Scalars['String'];
};

export type PolarisView = {
  __typename?: 'PolarisView';
  /** A token for talking to pf-collab-service */
  collabServiceDelegation?: Maybe<PolarisDelegationToken>;
  /** The comment stream */
  comments?: Maybe<Array<PolarisComment>>;
  /** View contains archived ideas */
  containsArchived: Scalars['Boolean'];
  description?: Maybe<Scalars['JSON']>;
  /**  table column sizes per field */
  fields: Array<PolarisIdeaField>;
  filter?: Maybe<Array<PolarisViewFilter>>;
  groupBy?: Maybe<PolarisIdeaField>;
  groupValues?: Maybe<Array<PolarisGroupValue>>;
  hidden?: Maybe<Array<PolarisIdeaField>>;
  /**
   * ARI of the polaris view itself.  For example,
   *
   *    `ari:cloud:cebeacbd-f85e-483c-96ac-fd432a12ad1c:polaris-view/10003`
   */
  id: Scalars['ID'];
  /**
   * Can the view be changed in-place?  Immutable views can be the
   * source of a clone operation, but it is an error to try to update
   * one.
   */
  immutable?: Maybe<Scalars['Boolean']>;
  /**
   * The JQL that would produce the same set of issues as are returned by
   * the ideas connection
   */
  jql?: Maybe<Scalars['String']>;
  lastCommentsViewedTimestamp?: Maybe<Scalars['String']>;
  lastViewed?: Maybe<Array<Maybe<PolarisViewLastViewed>>>;
  name: Scalars['String'];
  projectId: Scalars['Int'];
  /** view rank / position */
  rank: Scalars['Int'];
  sort?: Maybe<Array<PolarisSortField>>;
  tableColumnSizes?: Maybe<Array<PolarisViewTableColumnSize>>;
  /** The user-supplied part of a JQL filter */
  userJql?: Maybe<Scalars['String']>;
  verticalGroupBy?: Maybe<PolarisIdeaField>;
  verticalGroupValues?: Maybe<Array<PolarisGroupValue>>;
  viewSetId: Scalars['ID'];
  /**
   * this is being flattened out from the visualization substructure;
   * these view attributes are all modelled as optional, and their
   * significance depends on the selected visualizationType
   */
  visualizationType: PolarisVisualizationType;
  x?: Maybe<PolarisIdeaField>;
  y?: Maybe<PolarisIdeaField>;
};

export type PolarisViewCommentsArgs = {
  limit?: Maybe<Scalars['Int']>;
};

export type PolarisViewJqlArgs = {
  filter?: Maybe<PolarisFilterInput>;
};

export type PolarisViewFilter = {
  __typename?: 'PolarisViewFilter';
  field?: Maybe<PolarisIdeaField>;
  kind: PolarisViewFilterKind;
  values: Array<PolarisViewFilterValue>;
};

export type PolarisViewFilterInput = {
  field?: Maybe<Scalars['ID']>;
  kind: PolarisViewFilterKind;
  values: Array<PolarisViewFilterValueInput>;
};

export enum PolarisViewFilterKind {
  FIELD_IDENTITY = 'FIELD_IDENTITY',
  /**  a field being matched by identity */
  FIELD_NUMERIC = 'FIELD_NUMERIC',
  /**  a field being matched by numeric comparison */
  TEXT = 'TEXT',
}

export enum PolarisViewFilterOperator {
  EQ = 'EQ',
  GT = 'GT',
  GTE = 'GTE',
  LT = 'LT',
  LTE = 'LTE',
  NEQ = 'NEQ',
}

export type PolarisViewFilterValue = {
  __typename?: 'PolarisViewFilterValue';
  numericValue?: Maybe<Scalars['Float']>;
  operator?: Maybe<PolarisViewFilterOperator>;
  stringValue?: Maybe<Scalars['String']>;
};

export type PolarisViewFilterValueInput = {
  operator?: Maybe<PolarisViewFilterOperator>;
  text?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
};

export type PolarisViewLastViewed = {
  __typename?: 'PolarisViewLastViewed';
  aaid: Scalars['String'];
  account?: Maybe<User>;
  timestamp: Scalars['String'];
};

export type PolarisViewSet = {
  __typename?: 'PolarisViewSet';
  /**
   * ARI of the polaris viewSet itself.  For example,
   *
   *    `ari:cloud:cebeacbd-f85e-483c-96ac-fd432a12ad1c:viewset/10001`
   */
  id: Scalars['ID'];
  name: Scalars['String'];
  /** view rank / position */
  rank: Scalars['Int'];
  type?: Maybe<PolarisViewSetType>;
  views: Array<PolarisView>;
  viewsets: Array<PolarisViewSet>;
};

export enum PolarisViewSetType {
  CAPTURE = 'CAPTURE',
  CUSTOM = 'CUSTOM',
  DELIVER = 'DELIVER',
  PRIORITIZE = 'PRIORITIZE',
  /**  for views that are used to manage the display of single ideas (e.g., Idea views) */
  SECTION = 'SECTION',
  SINGLE = 'SINGLE',
  SYSTEM = 'SYSTEM',
}

export type PolarisViewTableColumnSize = {
  __typename?: 'PolarisViewTableColumnSize';
  field: PolarisIdeaField;
  /**  polaris field */
  size: Scalars['Int'];
};

export type PolarisViewTableColumnSizeInput = {
  field: Scalars['ID'];
  /**  polaris field ID */
  size: Scalars['Int'];
};

export enum PolarisVisualizationType {
  BOARD = 'BOARD',
  TABLE = 'TABLE',
  TWOXTWO = 'TWOXTWO',
}

export type ProjectAvatars = {
  __typename?: 'ProjectAvatars';
  x16: Scalars['URL'];
  x24: Scalars['URL'];
  x32: Scalars['URL'];
  x48: Scalars['URL'];
};

export type Query = {
  __typename?: 'Query';
  /**
   * Get user activities.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __confluence:atlassian-external__
   * * __jira:atlassian-external__
   */
  activities?: Maybe<Activities>;
  app?: Maybe<App>;
  /**
   * Returns the list of active tunnels for a given app-id and environment-key.
   *
   * The tunnels are active for 30min by default, if not requested to be terminated.
   */
  appActiveTunnels?: Maybe<AppTunnelDefinitions>;
  appDeployment?: Maybe<AppDeployment>;
  /** Returns information about all the scopes from different Atlassian products */
  appHostServices?: Maybe<Array<AppHostService>>;
  appInstallationTask?: Maybe<AppInstallationTask>;
  /**
   * `appLogLines()` returns an object for paging over the contents of a single
   * invocation's log lines, given by the `invocation` parameter (an ID
   * returned from a `appLogs()` query).
   *
   * Each `AppLogLine` consists of a `timestamp`, an optional `message`,
   * an optional `level`, and an `other` field that contains any
   * additional JSON fields included in the log line.  (Since
   * the app itself can control the schema of this JSON, we can't
   * use native GraphQL capabilities to describe the fields here.)
   *
   * The returned objects use the Relay naming/nesting style of
   * `AppLogLineConnection` &rarr; `[AppLogLineEdge]` &rarr;  `AppLogLine`.
   */
  appLogLines?: Maybe<AppLogLineConnection>;
  /**
   * `appLogs()` returns an object for paging over AppLog objects, each of which
   * represents one invocation of a function.
   *
   * The returned objects use the Relay naming/nesting style of
   * `AppLogConnection` &rarr; `[AppLogEdge]` &rarr;  `AppLog`.
   *
   * It takes parameters (`query: LogQueryInput`) to narrow down the invocations
   * being searched, requiring at least an app and environment.
   */
  appLogs?: Maybe<AppLogConnection>;
  /**
   * Get an list of untyped entity in a specific context, optional query parameters where condition, first and after
   *
   * where condition to filter
   * returns the first N entities when queried. Should not exceed 20
   * this is a cursor after which (exclusive) the data should be fetched from
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  appStoredEntities?: Maybe<AppStoredEntityConnection>;
  /**
   * Get an list of untyped entity in a specific context, optional query parameters where condition, first and after
   * This endpoint should only be called by functions with cleanup: true, as it will be deprecated once a proper GDPR solution
   * is implemented.
   *
   * where condition to filter
   * returns the first N entities when queried. Should not exceed 100
   * this is a cursor after which (exclusive) the data should be fetched from
   *
   *
   * This field is **deprecated** and will be removed in the future
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   * @deprecated This query is a temporary solution that will be removed
   */
  appStoredEntitiesForCleanup?: Maybe<AppStoredEntityConnection>;
  /**
   * Get an untyped entity in a specific context given a key
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: AppEntityStorage` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  appStoredEntity?: Maybe<AppStoredEntity>;
  apps?: Maybe<AppConnection>;
  bitbucket?: Maybe<BitbucketQuery>;
  /**
   * For the specified cloudId, retrieve the available Bitbucket repositories to
   * link with a (new) service that has not been created yet.
   * If nameFilter is provided, only repositories with names containing this case-insensitive string will be returned.
   * With an existing service, the caller should use `devOpsService.bitbucketRepositoriesAvailableToLinkWith` field.
   */
  bitbucketRepositoriesAvailableToLinkWithNewDevOpsService?: Maybe<
    BitbucketRepositoryIdConnection
  >;
  boardScope?: Maybe<BoardScope>;
  codeInJira?: Maybe<CodeInJira>;
  /**
   * This API is currently in BETA. You must provide "X-ExperimentalApi:compass-beta" in your request header
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: compass-beta` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  compass?: Maybe<CompassCatalogQueryApi>;
  /** This API is a wrapper for all CSP support Request queries */
  customerSupport?: Maybe<SupportRequestCatalogQueryApi>;
  devOpsMetrics?: Maybe<DevOpsMetrics>;
  /** The DevOps Service with the specified ARI */
  devOpsService?: Maybe<DevOpsService>;
  /** Return the relationship between DevOps Service and Jira Project */
  devOpsServiceAndJiraProjectRelationship?: Maybe<
    DevOpsServiceAndJiraProjectRelationship
  >;
  /**
   * Returns the relationship between DevOps Service and Opsgenie team with the
   * specified id (graph service_and_opsgenie_team ARI)
   */
  devOpsServiceAndOpsgenieTeamRelationship?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationship
  >;
  /** Returns the relationship between DevOps Service and Repository */
  devOpsServiceAndRepositoryRelationship?: Maybe<
    DevOpsServiceAndRepositoryRelationship
  >;
  /** The DevOps Service Relationship with the specified ARI */
  devOpsServiceRelationship?: Maybe<DevOpsServiceRelationship>;
  /**
   * Return the connection entity for DevOps Service relationships for the specified Jira project, according to the specified
   * pagination, filtering and sorting.
   */
  devOpsServiceRelationshipsForJiraProject?: Maybe<
    DevOpsServiceAndJiraProjectRelationshipConnection
  >;
  /** Returns the service relationships linked to the Opsgenie team with the specified id (Opsgenie team ARI). */
  devOpsServiceRelationshipsForOpsgenieTeam?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationshipConnection
  >;
  /**
   * Returns the service relationships linked to the repository with the specified id.
   * The ID is either a Bitbucket repository ARI, or the ID of a third-party repository.
   */
  devOpsServiceRelationshipsForRepository?: Maybe<
    DevOpsServiceAndRepositoryRelationshipConnection
  >;
  /** Retrieve the list of DevOps Service Tiers for the specified site */
  devOpsServiceTiers?: Maybe<Array<DevOpsServiceTier>>;
  /** Retrieve all services for the site specified by cloudId. */
  devOpsServices?: Maybe<DevOpsServiceConnection>;
  /**
   * Retrieve DevOps Services for the specified ids, the ids can belong to different sites.
   * Services not found are simply not returned.
   * The maximum lookup limit is 100.
   */
  devOpsServicesById?: Maybe<Array<DevOpsService>>;
  /** Check if developer has access to logs */
  developerLogAccess?: Maybe<Array<Maybe<DeveloperLogAccessResult>>>;
  /**
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: IssueDevelopmentInformation` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  developmentInformation?: Maybe<IssueDevOpsDevelopmentInformation>;
  /**
   * This field will dump diagnostics information about currently executing graphql request.
   *
   * It is inspired in part by [https://httpbin.org/anything](https://httpbin.org/anything/)
   */
  diagnostics?: Maybe<Scalars['JSON']>;
  dvcs?: Maybe<DvcsQuery>;
  /** This field will echo back the word `echo`.  Its only useful for testing */
  echo?: Maybe<Scalars['String']>;
  ecosystem?: Maybe<EcosystemQuery>;
  extensionByKey?: Maybe<Extension>;
  extensionContexts?: Maybe<Array<ExtensionContext>>;
  extensionsEcho?: Maybe<Scalars['String']>;
  /** Return a list of installation contexts with forge logs access */
  installationContextsWithLogAccess?: Maybe<
    Array<InstallationContextWithLogAccess>
  >;
  /**
   * this field is added to enable self governed onboarding of Jira GraphQL types to AGG
   * see https://hello.atlassian.net/wiki/spaces/PSRV/pages/1010287708/Announcing+self+governed+APIs for more details
   */
  jira?: Maybe<JiraQuery>;
  /** Retrieve the specified Jira project and Opsgenie team relationship. */
  jiraProjectAndOpsgenieTeamRelationship?: Maybe<
    JiraProjectAndOpsgenieTeamRelationship
  >;
  /** The entity for the specified Jira project and repository relationship. */
  jiraProjectAndRepositoryRelationship?: Maybe<
    JiraProjectAndRepositoryRelationship
  >;
  /** Returns the Jira project relationships linked to the Opsgenie team with the specified id (Opsgenie team ARI). */
  jiraProjectRelationshipsForOpsgenieTeam?: Maybe<
    JiraProjectAndOpsgenieTeamRelationshipConnection
  >;
  /**
   * The connection entity for Jira project relationships for the specified repository, according to the specified
   * pagination, filtering and sorting.
   * The ID is either a Bitbucket repository ARI, or the ID of a third-party repository.
   */
  jiraProjectRelationshipsForRepository?: Maybe<
    JiraProjectAndRepositoryRelationshipConnection
  >;
  /**
   * Return the connection entity for Jira Project relationships for the specified DevOps Service, according to the specified
   * pagination, filtering and sorting.
   */
  jiraProjectRelationshipsForService?: Maybe<
    DevOpsServiceAndJiraProjectRelationshipConnection
  >;
  /**
   * Namespace for fields relating to issue releases in Jira.
   *
   * A "release" in this context can refer to a code deployment or a feature flag change.
   *
   * This field is currently in BETA.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: jira-releases-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  jiraReleases?: Maybe<JiraReleases>;
  /** Get MarketplaceApp by appId. */
  marketplaceApp?: Maybe<MarketplaceApp>;
  /** Get MarketplaceApp by cloud app's Id. */
  marketplaceAppByCloudAppId?: Maybe<MarketplaceApp>;
  /** Get MarketplaceApp by appKey */
  marketplaceAppByKey?: Maybe<MarketplaceApp>;
  /** Get MarketplacePartner by id. */
  marketplacePartner?: Maybe<MarketplacePartner>;
  /** Get Pricing Plan for a marketplace entity */
  marketplacePricingPlan?: Maybe<MarketplacePricingPlan>;
  /** Get Atlassian marketplace user details */
  marketplaceUser?: Maybe<MarketplaceUser>;
  /**
   * This returns information about the currently logged in user.  If there is no logged in user
   * then there really wont be much information to show.
   */
  me: AuthenticationContext;
  movie?: Maybe<TestingMovie>;
  /** Relay-style lookup-individual-node-by-global-ID. */
  node?: Maybe<Node>;
  opsgenie?: Maybe<OpsgenieQuery>;
  /** Returns the Opsgenie Team relationship linked to the DevOps Service with the specified id (service ARI). */
  opsgenieTeamRelationshipForDevOpsService?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationship
  >;
  /** Returns the Opsgenie team relationships linked to the Jira project with the specified id (Jira project ARI). */
  opsgenieTeamRelationshipsForJiraProject?: Maybe<
    JiraProjectAndOpsgenieTeamRelationshipConnection
  >;
  polarisAPIVersion?: Maybe<Scalars['String']>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisAnonymousVisitorHash?: Maybe<PolarisAnonymousVisitorHash>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisAnonymousVisitorHashByID?: Maybe<PolarisAnonymousVisitorHash>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisCollabToken?: Maybe<PolarisDelegationToken>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisConnectAppByClientID?: Maybe<PolarisConnectApp>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisIdeas?: Maybe<PolarisIdeas>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisInsight?: Maybe<PolarisInsight>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisInsights?: Maybe<Array<PolarisInsight>>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisInsightsWithErrors?: Maybe<Array<PolarisInsight>>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisLabels?: Maybe<Array<LabelUsage>>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisLinkedDeliveryTickets?: Maybe<Array<Maybe<Scalars['JSON']>>>;
  /**
   * THIS QUERY IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisProject?: Maybe<PolarisProject>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisSnippetPropertiesConfig?: Maybe<PolarisSnippetPropertiesConfig>;
  /**
   * THIS OPERATION IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisTermsConsent?: Maybe<PolarisTermsConsent>;
  /**
   * THIS QUERY IS IN BETA
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: polaris-v0` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  polarisView?: Maybe<PolarisView>;
  /** Returns the repository relationships linked to the service with the specified id (service ARI). */
  repositoryRelationshipsForDevOpsService?: Maybe<
    DevOpsServiceAndRepositoryRelationshipConnection
  >;
  /**
   * The connection entity for repository relationships for the specified Jira project, according to the specified
   * pagination, filtering and sorting.
   */
  repositoryRelationshipsForJiraProject?: Maybe<
    JiraProjectAndRepositoryRelationshipConnection
  >;
  /**
   * Query for grouping the roadmap queries
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: RoadmapsQuery` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  roadmaps?: Maybe<RoadmapsQuery>;
  /**
   * The search method serves as an entry point to the various results across multiple Atlassian products.
   * This method proxy to Search Platform's API xpsearch-aggregator.
   * It supports multi tenant search with product specific filtering.
   */
  search?: Maybe<SearchQueryApi>;
  team?: Maybe<TeamQuery>;
  /**
   * A Jira or Confluence cloud instance, such as `hello.atlassian.net` has a backing
   * cloud ID such as `0ee6b491-5425-4f19-a71e-2486784ad694`
   *
   * This field allows you to look up the cloud IDs or host names of tenanted applications
   * such as Jira or Confluence.
   *
   * You MUST provide a list of cloud IDs or a list of host names to look up but not both
   * otherwise an error will be returned
   */
  tenantContexts?: Maybe<Array<Maybe<TenantContext>>>;
  /**
   * This field is useful for testing the graphql API.  In fact here at Atlassian we run synthetic checks
   * using this field ot help us ensure the graphql API is working as expected.
   */
  testing?: Maybe<Testing>;
  townsquare?: Maybe<TownsquareQueryApi>;
  /**
   * Given an account id this will return user profile information with applied privacy controls of the caller.
   *
   * Its important to remember that privacy controls are applied in terms of the caller.  A user with
   * a certain accountId may exist but the current caller may not have the right to view their details.
   */
  user?: Maybe<User>;
  /**
   * Given a list of account ids this will return user profile information with applied privacy controls of the caller.
   *
   * Its important to remember that privacy controls are applied in terms of the caller.  A user with
   * a certain accountId may exist but the current caller may not have the right to view their details.
   *
   * A maximum of 90 `accountIds` can be asked for at the one time.
   */
  users: Array<User>;
  /** Gets all webtrigger URLs for an application in a specified context. */
  webTriggerUrlsByAppContext?: Maybe<Array<WebTriggerUrl>>;
};

export type QueryAppArgs = {
  id: Scalars['ID'];
};

export type QueryAppActiveTunnelsArgs = {
  appId: Scalars['ID'];
  environmentId: Scalars['ID'];
};

export type QueryAppDeploymentArgs = {
  appId: Scalars['ID'];
  environmentKey: Scalars['String'];
  id: Scalars['ID'];
};

export type QueryAppHostServicesArgs = {
  filter?: Maybe<AppServicesFilter>;
};

export type QueryAppInstallationTaskArgs = {
  id: Scalars['ID'];
};

export type QueryAppLogLinesArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  invocation: Scalars['ID'];
};

export type QueryAppLogsArgs = {
  after?: Maybe<Scalars['String']>;
  appId: Scalars['ID'];
  before?: Maybe<Scalars['String']>;
  environmentId: Array<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<LogQueryInput>;
};

export type QueryAppStoredEntitiesArgs = {
  after?: Maybe<Scalars['String']>;
  contextAri: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  where?: Maybe<Array<AppStoredEntityFilter>>;
};

export type QueryAppStoredEntitiesForCleanupArgs = {
  after?: Maybe<Scalars['String']>;
  contextAri: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  where?: Maybe<Array<AppStoredEntityFilter>>;
};

export type QueryAppStoredEntityArgs = {
  contextAri: Scalars['ID'];
  encrypted?: Maybe<Scalars['Boolean']>;
  key: Scalars['ID'];
};

export type QueryAppsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filter?: Maybe<AppsFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type QueryBitbucketRepositoriesAvailableToLinkWithNewDevOpsServiceArgs = {
  after?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  nameFilter?: Maybe<Scalars['String']>;
};

export type QueryBoardScopeArgs = {
  boardId: Scalars['ID'];
};

export type QueryCodeInJiraArgs = {
  cloudId: Scalars['ID'];
};

export type QueryDevOpsServiceArgs = {
  id: Scalars['ID'];
};

export type QueryDevOpsServiceAndJiraProjectRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryDevOpsServiceAndOpsgenieTeamRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryDevOpsServiceAndRepositoryRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryDevOpsServiceRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryDevOpsServiceRelationshipsForJiraProjectArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndJiraProjectRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

export type QueryDevOpsServiceRelationshipsForOpsgenieTeamArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

export type QueryDevOpsServiceRelationshipsForRepositoryArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  sort?: Maybe<DevOpsServiceAndRepositoryRelationshipSort>;
};

export type QueryDevOpsServiceTiersArgs = {
  cloudId: Scalars['String'];
};

export type QueryDevOpsServicesArgs = {
  after?: Maybe<Scalars['String']>;
  cloudId: Scalars['String'];
  filter?: Maybe<DevOpsServicesFilterInput>;
  first?: Maybe<Scalars['Int']>;
};

export type QueryDevOpsServicesByIdArgs = {
  ids: Array<Scalars['ID']>;
};

export type QueryDeveloperLogAccessArgs = {
  appId: Scalars['ID'];
  contextIds: Array<Scalars['ID']>;
  environmentType: AppEnvironmentType;
};

export type QueryDevelopmentInformationArgs = {
  issueId: Scalars['ID'];
};

export type QueryExtensionByKeyArgs = {
  contextId: Scalars['ID'];
  definitionId: Scalars['ID'];
  extensionKey: Scalars['String'];
};

export type QueryExtensionContextsArgs = {
  contextIds: Array<Scalars['ID']>;
};

export type QueryExtensionsEchoArgs = {
  text: Scalars['String'];
};

export type QueryInstallationContextsWithLogAccessArgs = {
  appId: Scalars['ID'];
};

export type QueryJiraProjectAndOpsgenieTeamRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryJiraProjectAndRepositoryRelationshipArgs = {
  id: Scalars['ID'];
};

export type QueryJiraProjectRelationshipsForOpsgenieTeamArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

export type QueryJiraProjectRelationshipsForRepositoryArgs = {
  after?: Maybe<Scalars['String']>;
  cloudId: Scalars['ID'];
  filter?: Maybe<JiraProjectAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  sort?: Maybe<JiraProjectAndRepositoryRelationshipSort>;
};

export type QueryJiraProjectRelationshipsForServiceArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndJiraProjectRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

export type QueryMarketplaceAppArgs = {
  appId: Scalars['ID'];
};

export type QueryMarketplaceAppByCloudAppIdArgs = {
  cloudAppId: Scalars['ID'];
};

export type QueryMarketplaceAppByKeyArgs = {
  appKey: Scalars['String'];
};

export type QueryMarketplacePartnerArgs = {
  id: Scalars['ID'];
};

export type QueryMarketplacePricingPlanArgs = {
  appId: Scalars['ID'];
  hostingType: AtlassianProductHostingType;
  pricingPlanOptions?: Maybe<MarketplacePricingPlanOptions>;
};

export type QueryMovieArgs = {
  id: Scalars['ID'];
};

export type QueryNodeArgs = {
  id: Scalars['ID'];
};

export type QueryOpsgenieTeamRelationshipForDevOpsServiceArgs = {
  id: Scalars['ID'];
};

export type QueryOpsgenieTeamRelationshipsForJiraProjectArgs = {
  after?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

export type QueryPolarisAnonymousVisitorHashArgs = {
  hash: Scalars['String'];
};

export type QueryPolarisAnonymousVisitorHashByIdArgs = {
  id: Scalars['ID'];
};

export type QueryPolarisCollabTokenArgs = {
  viewID: Scalars['ID'];
};

export type QueryPolarisConnectAppByClientIdArgs = {
  oauthClientID: Scalars['ID'];
};

export type QueryPolarisIdeasArgs = {
  expand?: Maybe<Array<Scalars['String']>>;
  fieldKeys?: Maybe<Array<Scalars['String']>>;
  jql?: Maybe<Scalars['String']>;
  project: Scalars['ID'];
};

export type QueryPolarisInsightArgs = {
  id: Scalars['ID'];
};

export type QueryPolarisInsightsArgs = {
  container?: Maybe<Scalars['ID']>;
  project: Scalars['ID'];
};

export type QueryPolarisInsightsWithErrorsArgs = {
  project: Scalars['ID'];
};

export type QueryPolarisLabelsArgs = {
  projectID: Scalars['ID'];
};

export type QueryPolarisLinkedDeliveryTicketsArgs = {
  issueIds?: Maybe<Array<Scalars['Int']>>;
  project: Scalars['ID'];
};

export type QueryPolarisProjectArgs = {
  id: Scalars['ID'];
  skipRefresh?: Maybe<Scalars['Boolean']>;
};

export type QueryPolarisSnippetPropertiesConfigArgs = {
  groupId: Scalars['String'];
  oauthClientId: Scalars['String'];
  project: Scalars['ID'];
};

export type QueryPolarisTermsConsentArgs = {
  cloudID: Scalars['ID'];
};

export type QueryPolarisViewArgs = {
  id: Scalars['ID'];
};

export type QueryRepositoryRelationshipsForDevOpsServiceArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<DevOpsServiceAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  sort?: Maybe<DevOpsServiceAndRepositoryRelationshipSort>;
};

export type QueryRepositoryRelationshipsForJiraProjectArgs = {
  after?: Maybe<Scalars['String']>;
  filter?: Maybe<JiraProjectAndRepositoryRelationshipFilter>;
  first?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  sort?: Maybe<JiraProjectAndRepositoryRelationshipSort>;
};

export type QueryTenantContextsArgs = {
  cloudIds?: Maybe<Array<Scalars['ID']>>;
  hostNames?: Maybe<Array<Scalars['String']>>;
};

export type QueryUserArgs = {
  accountId: Scalars['ID'];
};

export type QueryUsersArgs = {
  accountIds: Array<Scalars['ID']>;
};

export type QueryWebTriggerUrlsByAppContextArgs = {
  appId: Scalars['ID'];
  contextId: Scalars['ID'];
  envId: Scalars['ID'];
};

export type QueryError = {
  __typename?: 'QueryError';
  /** Contains extra data describing the error. */
  extensions?: Maybe<Array<QueryErrorExtension>>;
  /** The ID of the requested object, or null when the ID is not available. */
  identifier?: Maybe<Scalars['ID']>;
  /** A message describing the error. */
  message?: Maybe<Scalars['String']>;
};

export type QueryErrorExtension = {
  /** A code representing the type of error. See the CompassErrorType enum for possible values. */
  errorType?: Maybe<Scalars['String']>;
  /** A numerical code (such as an HTTP status code) representing the error category. */
  statusCode?: Maybe<Scalars['Int']>;
};

export type RankColumnInput = {
  boardId: Scalars['ID'];
  columnId: Scalars['ID'];
  position: Scalars['Int'];
};

export type RankColumnOutput = MutationResponse & {
  __typename?: 'RankColumnOutput';
  columns?: Maybe<Array<Column>>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export enum RateLimitingCurrency {
  TESTING_SERVICE = 'TESTING_SERVICE',
}

export type RefreshPolarisSnippetsInput = {
  project: Scalars['ID'];
  /**
   * Specifies a set of snippets to be refreshed for finer-grain control than
   * at the project level (a required property for this API).  This field
   * is optional, and if specified must refer to either an issue, an
   * insight, or a snippet.
   */
  subject?: Maybe<Scalars['ID']>;
  /**
   * An optional flag indicating whether or not the refresh should be performed
   * synchronously.  By default (if this flag is not included, or if its value
   * is false), the refresh is performed asynchronously.
   */
  synchronous?: Maybe<Scalars['Boolean']>;
};

export type RefreshPolarisSnippetsPayload = Payload & {
  __typename?: 'RefreshPolarisSnippetsPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisRefreshJob>;
  success: Scalars['Boolean'];
};

export type RefreshToken = {
  __typename?: 'RefreshToken';
  refreshTokenRotation: Scalars['Boolean'];
};

export type RefreshTokenInput = {
  refreshTokenRotation: Scalars['Boolean'];
};

/** Accepts input for removing labels from a component. */
export type RemoveCompassComponentLabelsInput = {
  /** The ID of the component to remove the labels from. */
  componentId: Scalars['ID'];
  /** The collection of labels to remove from the component. */
  labelNames: Array<Scalars['String']>;
};

/** The payload returned after removing labels from a component. */
export type RemoveCompassComponentLabelsPayload = Payload & {
  __typename?: 'RemoveCompassComponentLabelsPayload';
  /** The details of the component that was mutated. */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** The collection of labels that were removed from the component. */
  removedLabelNames?: Maybe<Array<Scalars['String']>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** The payload returned from removing a scorecard from a component. */
export type RemoveCompassScorecardFromComponentPayload = Payload & {
  __typename?: 'RemoveCompassScorecardFromComponentPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type RemovePolarisColumnInput = {
  /** The column position to be removed */
  column: Scalars['ID'];
};

/** Data for the reports overview page */
export type ReportsOverview = {
  __typename?: 'ReportsOverview';
  metadata: Array<Maybe<SoftwareReport>>;
};

export type ResolvedPolarisObject = {
  __typename?: 'ResolvedPolarisObject';
  auth?: Maybe<ResolvedPolarisObjectAuth>;
  body?: Maybe<Scalars['JSON']>;
  externalAuth?: Maybe<Array<ResolvedPolarisObjectExternalAuth>>;
  oauthClientId?: Maybe<Scalars['String']>;
  statusCode: Scalars['Int'];
};

export type ResolvedPolarisObjectAuth = {
  __typename?: 'ResolvedPolarisObjectAuth';
  hint?: Maybe<Scalars['String']>;
  type: PolarisResolvedObjectAuthType;
};

export type ResolvedPolarisObjectExternalAuth = {
  __typename?: 'ResolvedPolarisObjectExternalAuth';
  displayName: Scalars['String'];
  key: Scalars['String'];
  url: Scalars['String'];
};

export type ResolvePolarisObjectInput = {
  /** Custom auth token that will be used in unfurl request and saved if request was successful */
  authToken?: Maybe<Scalars['String']>;
  /** Issue ARI */
  issue: Scalars['ID'];
  /** Project ARI */
  project: Scalars['ID'];
  /** Resource url that will be used to unfurl data */
  resourceUrl: Scalars['String'];
};

export type ResolvePolarisObjectPayload = Payload & {
  __typename?: 'ResolvePolarisObjectPayload';
  errors?: Maybe<Array<MutationError>>;
  response?: Maybe<ResolvedPolarisObject>;
  success: Scalars['Boolean'];
};

/** Board specific configuration for a Roadmap */
export type RoadmapBoardConfiguration = {
  __typename?: 'RoadmapBoardConfiguration';
  /** Is the board's jql filtering out epics */
  isBoardJqlFilteringOutEpics?: Maybe<Scalars['Boolean']>;
  /** Is the sprints feature enabled on the board */
  isSprintsFeatureEnabled?: Maybe<Scalars['Boolean']>;
  /** Is the current user a board admin */
  isUserBoardAdmin?: Maybe<Scalars['Boolean']>;
  /** The board's JQL */
  jql?: Maybe<Scalars['String']>;
  /** Sprints owned by the board associated to the roadmap */
  sprints?: Maybe<Array<RoadmapSprint>>;
};

export type RoadmapConfiguration = {
  __typename?: 'RoadmapConfiguration';
  /** Configuration specific to a board */
  boardConfiguration?: Maybe<RoadmapBoardConfiguration>;
  /** Dependency configuration for this roadmap */
  dependencies?: Maybe<RoadmapDependencyConfiguration>;
  /** External configuration details */
  externalConfiguration?: Maybe<RoadmapExternalConfiguration>;
  /** Is this roadmap cross project */
  isCrossProject: Scalars['Boolean'];
  /** Project information */
  projectConfigurations: Array<RoadmapProjectConfiguration>;
  /** Is the board backed with jql with Rank ASC in order by clause */
  rankIssuesSupported: Scalars['Boolean'];
  /** Is the roadmap feature enabled for this roadmap */
  roadmapFeatureEnabled: Scalars['Boolean'];
  /** Details of status categories */
  statusCategories: Array<RoadmapStatusCategory>;
  /** Configuration specific to the current user */
  userConfiguration?: Maybe<RoadmapUserConfiguration>;
};

export type RoadmapCreationPreferences = {
  __typename?: 'RoadmapCreationPreferences';
  projectId?: Maybe<Scalars['Long']>;
};

/** Details about dependency configuration for roadmaps */
export type RoadmapDependencyConfiguration = {
  __typename?: 'RoadmapDependencyConfiguration';
  /** The description to apply for inbound dependencies */
  inwardDependencyDescription?: Maybe<Scalars['String']>;
  /** Are dependencies enabled */
  isDependenciesEnabled: Scalars['Boolean'];
  /** The description to apply for outbound dependencies */
  outwardDependencyDescription?: Maybe<Scalars['String']>;
};

/** Details of a roadmap */
export type RoadmapDetails = {
  __typename?: 'RoadmapDetails';
  /** meta information surrounding the roadmap, such as issue limit breaches */
  metadata?: Maybe<RoadmapMetadata>;
  /** The configuration for this roadmap */
  roadmapConfiguration?: Maybe<RoadmapConfiguration>;
  /** The items in the roadmap */
  roadmapItems?: Maybe<RoadmapItemConnection>;
};

/** Configuration values for the external system(s) behind the roadmap data */
export type RoadmapExternalConfiguration = {
  __typename?: 'RoadmapExternalConfiguration';
  /** The identifier for the 'field' that represents color in the external system */
  colorFields?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** The identifier for the 'field' that represents due date in the external system */
  dueDateField?: Maybe<Scalars['ID']>;
  /** The identifier for the 'field' that represents epic link in the external system */
  epicLinkField?: Maybe<Scalars['ID']>;
  /** The identifier for the 'field' that represents epic name in the external system */
  epicNameField?: Maybe<Scalars['ID']>;
  /** ID of external system */
  externalSystem: Scalars['ID'];
  /** The identifier for the 'field' that represents rank in the external system */
  rankField?: Maybe<Scalars['ID']>;
  /** The identifier for the 'field' that represents sprint in the external system */
  sprintField?: Maybe<Scalars['ID']>;
  /** The identifier for the 'field' that represents start date in the external system */
  startDateField?: Maybe<Scalars['ID']>;
};

/** The roadmap item data */
export type RoadmapItem = {
  __typename?: 'RoadmapItem';
  /** The assignee of this item */
  assignee?: Maybe<User>;
  /** What color should be shown for this item */
  color?: Maybe<RoadmapPaletteColor>;
  /** When this item was created */
  createdDate?: Maybe<Scalars['DateTime']>;
  /** IDs of RoadmapItem dependencies for this item */
  dependencies?: Maybe<Array<Scalars['ID']>>;
  /** When this item is due, note this is a Date with no TZ */
  dueDate?: Maybe<Scalars['DateTime']>;
  /** The ID of this item */
  id: Scalars['ID'];
  /** The due date inferred from any child items, note this is a Date with no TZ */
  inferredDueDate?: Maybe<Scalars['Date']>;
  /** The start date inferred from any child items, note this is a Date with no TZ */
  inferredStartDate?: Maybe<Scalars['Date']>;
  /** The type of this item */
  itemType: RoadmapItemType;
  /** The key of this item */
  key: Scalars['String'];
  /** List of labels on this item */
  labels?: Maybe<Array<Scalars['String']>>;
  /** The ID of the parent */
  parentId?: Maybe<Scalars['ID']>;
  /** The id of the project for this item */
  projectId: Scalars['ID'];
  /** Lexorank value for the issue (used to determine issues ranking when receiving update events) */
  rank?: Maybe<Scalars['String']>;
  /** When this item was resolved */
  resolutionDate?: Maybe<Scalars['DateTime']>;
  /** List of sprint ids that exist on the item */
  sprintIds?: Maybe<Array<Scalars['ID']>>;
  /** When this item is set to start, note this is a Date with no TZ */
  startDate?: Maybe<Scalars['DateTime']>;
  /** The status of this item */
  status?: Maybe<RoadmapItemStatus>;
  /** The status category of this item */
  statusCategory?: Maybe<RoadmapItemStatusCategory>;
  /** The summary of this item */
  summary?: Maybe<Scalars['String']>;
  /** List of ids of the versions on this item */
  versionIds?: Maybe<Array<Scalars['ID']>>;
};

/** Relay connection definition for a roadmap item */
export type RoadmapItemConnection = {
  __typename?: 'RoadmapItemConnection';
  /** The edges for this connection */
  edges?: Maybe<Array<Maybe<RoadmapItemEdge>>>;
  /** The nodes for this connection */
  nodes: Array<Maybe<RoadmapItem>>;
  /** Details about this page */
  pageInfo: PageInfo;
};

/** Relay edge definition for a roadmap item */
export type RoadmapItemEdge = {
  __typename?: 'RoadmapItemEdge';
  /** Cursor position for this edge */
  cursor: Scalars['String'];
  /** The roadmap item for this edge */
  node?: Maybe<RoadmapItem>;
};

/** Details of the status an item has */
export type RoadmapItemStatus = {
  __typename?: 'RoadmapItemStatus';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  statusCategory?: Maybe<RoadmapItemStatusCategory>;
};

/** Details of the category that a status belongs to */
export type RoadmapItemStatusCategory = {
  __typename?: 'RoadmapItemStatusCategory';
  id: Scalars['ID'];
  key: Scalars['String'];
  name?: Maybe<Scalars['String']>;
};

/** Information about the type of a roadmap Item */
export type RoadmapItemType = {
  __typename?: 'RoadmapItemType';
  /** The avatar for this item type */
  avatarId?: Maybe<Scalars['ID']>;
  /** A description of this item type */
  description?: Maybe<Scalars['String']>;
  /** The url for the icon of the item type */
  iconUrl?: Maybe<Scalars['String']>;
  /** The identifier of this item type */
  id: Scalars['ID'];
  /** The display name of the item type */
  name?: Maybe<Scalars['String']>;
  /** Fields that are required for this item type */
  requiredFieldIds?: Maybe<Array<Scalars['ID']>>;
  /** Whether this item type represents a subtask */
  subtask: Scalars['Boolean'];
};

export type RoadmapMetadata = {
  __typename?: 'RoadmapMetadata';
  /** how many corrupted issues have we found while loading the roadmap */
  corruptedIssueCount: Scalars['Int'];
  /** has the roadmap exceeded the epic limit */
  hasExceededEpicLimit: Scalars['Boolean'];
  /** has the roadmap exceeded the overall limit of issues (epic + issues) */
  hasExceededIssueLimit: Scalars['Boolean'];
};

/** Supported colors in the Palette */
export enum RoadmapPaletteColor {
  BLUE = 'BLUE',
  DARK_BLUE = 'DARK_BLUE',
  DARK_GREEN = 'DARK_GREEN',
  DARK_GREY = 'DARK_GREY',
  DARK_ORANGE = 'DARK_ORANGE',
  DARK_PURPLE = 'DARK_PURPLE',
  DARK_TEAL = 'DARK_TEAL',
  DARK_YELLOW = 'DARK_YELLOW',
  GREEN = 'GREEN',
  GREY = 'GREY',
  ORANGE = 'ORANGE',
  PURPLE = 'PURPLE',
  TEAL = 'TEAL',
  YELLOW = 'YELLOW',
}

/** Details of a project for a roadmap */
export type RoadmapProject = {
  __typename?: 'RoadmapProject';
  /** Does this project support dependencies between issues */
  areDependenciesSupported: Scalars['Boolean'];
  /** Color custom field ID; used to resolve raw fields data in Bento optimistic updates */
  colorCustomFieldId?: Maybe<Scalars['ID']>;
  /** The description of the project */
  description?: Maybe<Scalars['String']>;
  /** The issue type for epic, in future this will be replaced by using the hierarchy structures directly */
  epicIssueTypeId?: Maybe<Scalars['ID']>;
  /** Has the current user completed onboarding */
  hasCompletedOnboarding: Scalars['Boolean'];
  /** The identifier of the project */
  id: Scalars['ID'];
  /** The description for inward dependency links */
  inwardDependencyDescription?: Maybe<Scalars['String']>;
  /** The types of items that this project has */
  itemTypes?: Maybe<Array<RoadmapItemType>>;
  /** The short key of the project i.e. ABC */
  key?: Maybe<Scalars['String']>;
  /** The user who is leading the project */
  lead?: Maybe<User>;
  /** Lexo rank custom field ID; used in all ranking operations, in future should be replaced by mutations */
  lexoRankCustomFieldId?: Maybe<Scalars['ID']>;
  /** The display name of the project */
  name?: Maybe<Scalars['String']>;
  /** The description for outward dependency links */
  outwardDependencyDescription?: Maybe<Scalars['String']>;
  /** Permissions for the project */
  permissions?: Maybe<RoadmapProjectPermissions>;
  /** Start date custom field ID; used to resolve raw fields data in Bento optimistic updates */
  startDateCustomFieldId?: Maybe<Scalars['ID']>;
  /** Validation details for the project */
  validation?: Maybe<RoadmapProjectValidation>;
};

/** Configuration details specific to a project */
export type RoadmapProjectConfiguration = {
  __typename?: 'RoadmapProjectConfiguration';
  /** The item types at the child level */
  childItemTypes: Array<RoadmapItemType>;
  /** The id of the default item type */
  defaultItemTypeId?: Maybe<Scalars['String']>;
  /** The item types at the parent level */
  parentItemTypes: Array<RoadmapItemType>;
  /** Permission details for this project */
  permissions?: Maybe<RoadmapProjectPermissions>;
  /** The identifier of the project */
  projectId: Scalars['ID'];
  /** The short key of the project i.e. ABC */
  projectKey?: Maybe<Scalars['String']>;
  /** The name of the project i.e. ABC project */
  projectName?: Maybe<Scalars['String']>;
  /** Validation information for this project */
  validation?: Maybe<RoadmapProjectValidation>;
  /** List of versions for this project */
  versions?: Maybe<Array<RoadmapVersion>>;
};

/** Information about the permissions available for the roadmap project for the current user */
export type RoadmapProjectPermissions = {
  __typename?: 'RoadmapProjectPermissions';
  /** can the project be administered */
  canAdministerProjects: Scalars['Boolean'];
  /** can issues be created */
  canCreateIssues: Scalars['Boolean'];
  /** can issues be edited */
  canEditIssues: Scalars['Boolean'];
  /** can issues be scheduled */
  canScheduleIssues: Scalars['Boolean'];
};

/** Details about how valid the roadmap project is */
export type RoadmapProjectValidation = {
  __typename?: 'RoadmapProjectValidation';
  /** Are all the field associations correct for the project */
  hasAllFieldAssociations: Scalars['Boolean'];
  /** Has the epic issue type been setup */
  hasEpicIssueType: Scalars['Boolean'];
  /** Is the hierarchy for the project in a valid state */
  hasValidHierarchy: Scalars['Boolean'];
};

/** Details of a roadmap sprint */
export type RoadmapSprint = {
  __typename?: 'RoadmapSprint';
  /** The end date of the sprint, note this is a Date with no TZ */
  endDate: Scalars['String'];
  /** A unique identifier for the sprint */
  id: Scalars['ID'];
  /** The name of the sprint */
  name: Scalars['String'];
  /** The start date of the sprint, note this is a Date with no TZ */
  startDate: Scalars['String'];
  /** The state of the sprint */
  state: RoadmapSprintState;
};

/** States that a sprint can be in */
export enum RoadmapSprintState {
  /** A current sprint */
  ACTIVE = 'ACTIVE',
  /** A sprint that was completed in the past */
  CLOSED = 'CLOSED',
  /** A sprint that is planned for the future */
  FUTURE = 'FUTURE',
}

/** Top level grouping of potential roadmap queries */
export type RoadmapsQuery = {
  __typename?: 'RoadmapsQuery';
  /** Lookup details of a roadmap. */
  roadmapForSource?: Maybe<RoadmapDetails>;
  /** Get multiple items. */
  roadmapItemByIds?: Maybe<Array<Maybe<RoadmapItem>>>;
};

/** Top level grouping of potential roadmap queries */
export type RoadmapsQueryRoadmapForSourceArgs = {
  locationARI?: Maybe<Scalars['ID']>;
  sourceARI: Scalars['ID'];
};

/** Top level grouping of potential roadmap queries */
export type RoadmapsQueryRoadmapItemByIdsArgs = {
  ids: Array<Scalars['ID']>;
  sourceARI: Scalars['ID'];
};

/** Details of the roadmap status category */
export type RoadmapStatusCategory = {
  __typename?: 'RoadmapStatusCategory';
  id: Scalars['ID'];
  key: Scalars['String'];
  name: Scalars['String'];
};

/** Defines the available timeline modes */
export enum RoadmapTimelineMode {
  /** Months */
  MONTHS = 'MONTHS',
  /** Quarters */
  QUARTERS = 'QUARTERS',
  /** Weeks */
  WEEKS = 'WEEKS',
}

/** Any user specific configuration for the roadmap */
export type RoadmapUserConfiguration = {
  __typename?: 'RoadmapUserConfiguration';
  /** Issue Creation Preferences */
  creationPreferences: RoadmapCreationPreferences;
  /** Epic View - ALL, COMPLETED, INCOMPLETE */
  epicView: EpicView;
  /** Has the current user completed onboarding */
  hasCompletedOnboarding: Scalars['Boolean'];
  /** Should dependencies be visible in Roadmaps UI */
  isDependenciesVisible: Scalars['Boolean'];
  /** Should progress be visible in Roadmaps UI */
  isProgressVisible: Scalars['Boolean'];
  /** List Component width in UI */
  listWidth: Scalars['Long'];
  /** Timeline View - WEEKS, MONTHS or QUARTERS */
  timelineMode: RoadmapTimelineMode;
};

/** Details of a version */
export type RoadmapVersion = {
  __typename?: 'RoadmapVersion';
  /** A unique identifier for the version */
  id: Scalars['ID'];
  /** The name of the version */
  name: Scalars['String'];
  /** The status of the version */
  status: RoadmapVersionStatus;
};

/** Avaliable version statuses */
export enum RoadmapVersionStatus {
  /** version has been archived */
  ARCHIVED = 'ARCHIVED',
  /** version has been released */
  RELEASED = 'RELEASED',
  /** version has not been released */
  UNRELEASED = 'UNRELEASED',
}

export type ScanPolarisProjectInput = {
  project: Scalars['ID'];
  refresh?: Maybe<Scalars['Boolean']>;
};

export enum Scope {
  /** outbound-auth */
  ADMIN_CONTAINER = 'ADMIN_CONTAINER',
  AUTH_CONFLUENCE_USER = 'AUTH_CONFLUENCE_USER',
  /** confluence */
  CONFLUENCE_ATLASSIAN_EXTERNAL = 'CONFLUENCE_ATLASSIAN_EXTERNAL',
  IDENTITY_ATLASSIAN_EXTERNAL = 'IDENTITY_ATLASSIAN_EXTERNAL',
  JIRA_ATLASSIAN_EXTERNAL = 'JIRA_ATLASSIAN_EXTERNAL',
  /** ecosystem */
  MANAGE_APP = 'MANAGE_APP',
  MANAGE_CONFLUENCE_CONFIGURATION = 'MANAGE_CONFLUENCE_CONFIGURATION',
  MANAGE_DIRECTORY = 'MANAGE_DIRECTORY',
  MANAGE_JIRA_CONFIGURATION = 'MANAGE_JIRA_CONFIGURATION',
  MANAGE_JIRA_DATA_PROVIDER = 'MANAGE_JIRA_DATA_PROVIDER',
  MANAGE_JIRA_PROJECT = 'MANAGE_JIRA_PROJECT',
  /** identity */
  MANAGE_ORG = 'MANAGE_ORG',
  MANAGE_SERVICEDESK_CUSTOMER = 'MANAGE_SERVICEDESK_CUSTOMER',
  /** platform */
  MIGRATE_CONFLUENCE = 'MIGRATE_CONFLUENCE',
  /** compass */
  READ_COMPASS_COMPONENT = 'READ_COMPASS_COMPONENT',
  READ_COMPASS_EVENT = 'READ_COMPASS_EVENT',
  READ_COMPASS_SCORECARD = 'READ_COMPASS_SCORECARD',
  READ_CONFLUENCE_CONTENT_ALL = 'READ_CONFLUENCE_CONTENT_ALL',
  READ_CONFLUENCE_CONTENT_PERMISSION = 'READ_CONFLUENCE_CONTENT_PERMISSION',
  READ_CONFLUENCE_CONTENT_SUMMARY = 'READ_CONFLUENCE_CONTENT_SUMMARY',
  READ_CONFLUENCE_GROUPS = 'READ_CONFLUENCE_GROUPS',
  READ_CONFLUENCE_PROPS = 'READ_CONFLUENCE_PROPS',
  READ_CONFLUENCE_SPACE_SUMMARY = 'READ_CONFLUENCE_SPACE_SUMMARY',
  READ_CONFLUENCE_USER = 'READ_CONFLUENCE_USER',
  READ_CONTAINER = 'READ_CONTAINER',
  /** jira */
  READ_JIRA_USER = 'READ_JIRA_USER',
  READ_JIRA_WORK = 'READ_JIRA_WORK',
  READ_ME = 'READ_ME',
  /** notification-log */
  READ_NOTIFICATIONS = 'READ_NOTIFICATIONS',
  /** jira-servicedesk */
  READ_SERVICEDESK_REQUEST = 'READ_SERVICEDESK_REQUEST',
  SEARCH_CONFLUENCE_ = 'SEARCH_CONFLUENCE_',
  STORAGE_APP = 'STORAGE_APP',
  VIEW_USERPROFILE = 'VIEW_USERPROFILE',
  WRITE_COMPASS_COMPONENT = 'WRITE_COMPASS_COMPONENT',
  WRITE_COMPASS_EVENT = 'WRITE_COMPASS_EVENT',
  WRITE_COMPASS_SCORECARD = 'WRITE_COMPASS_SCORECARD',
  WRITE_CONFLUENCE_CONTENT = 'WRITE_CONFLUENCE_CONTENT',
  WRITE_CONFLUENCE_FILE = 'WRITE_CONFLUENCE_FILE',
  WRITE_CONFLUENCE_GROUPS = 'WRITE_CONFLUENCE_GROUPS',
  WRITE_CONFLUENCE_PROPS = 'WRITE_CONFLUENCE_PROPS',
  WRITE_CONFLUENCE_SPACE = 'WRITE_CONFLUENCE_SPACE',
  WRITE_CONTAINER = 'WRITE_CONTAINER',
  WRITE_JIRA_WORK = 'WRITE_JIRA_WORK',
  WRITE_NOTIFICATIONS = 'WRITE_NOTIFICATIONS',
  WRITE_SERVICEDESK_REQUEST = 'WRITE_SERVICEDESK_REQUEST',
}

export type ScopeSprintIssue = {
  __typename?: 'ScopeSprintIssue';
  /** the estimate on the issue */
  estimate: Scalars['Float'];
  /** issue key */
  issueKey: Scalars['String'];
  /** issue description */
  issueSummary: Scalars['String'];
};

/** Metadata on any analytics related fields, these do not affect the search */
export type SearchAnalyticsInput = {
  queryVersion?: Maybe<Scalars['Int']>;
  searchSessionId?: Maybe<Scalars['String']>;
  searchReferrerId?: Maybe<Scalars['String']>;
};

export type SearchConfluenceFilter = {
  /** Space keys from which the results are desired. */
  spacesFilter?: Maybe<Array<Scalars['String']>>;
  /** AccountIds of the users. */
  contributorsFilter?: Maybe<Array<Scalars['String']>>;
  /** AccountIds of the users. */
  creatorsFilter?: Maybe<Array<Scalars['String']>>;
  /** Labels which must be present on the page or blogpost. */
  labelsFilter?: Maybe<Array<Scalars['String']>>;
  /** Id of the pages which must be parent of the result. */
  ancestorIdsFilter?: Maybe<Array<Scalars['String']>>;
  range?: Maybe<Array<Maybe<SearchConfluenceRangeFilter>>>;
  containerStatus?: Maybe<Array<Maybe<SearchContainerStatus>>>;
};

/**
 * Add only product specific properties below. Generic properties must be in the SearchResult
 *
 * CONFLUENCE
 */
export type SearchConfluencePageBlogAttachment = SearchResult & {
  __typename?: 'SearchConfluencePageBlogAttachment';
  id: Scalars['ID'];
  title: Scalars['String'];
  url: Scalars['URL'];
  iconUrl: Scalars['URL'];
  type: Scalars['String'];
  description: Scalars['String'];
  lastModifiedDate?: Maybe<Scalars['DateTime']>;
  space?: Maybe<SearchSpace>;
};

export enum SearchConfluenceRangeField {
  LASTMODIFIED = 'LASTMODIFIED',
  CREATED = 'CREATED',
}

export type SearchConfluenceRangeFilter = {
  /** The field to use to calculate the range */
  field: SearchConfluenceRangeField;
  /** Specify the timestamp that the field should be greater than */
  gt?: Maybe<Scalars['String']>;
  /** Specify the timestamp that the field should be less than */
  lt?: Maybe<Scalars['String']>;
};

export type SearchConfluenceSpace = SearchResult & {
  __typename?: 'SearchConfluenceSpace';
  id: Scalars['ID'];
  title: Scalars['String'];
  url: Scalars['URL'];
  iconUrl: Scalars['URL'];
  type: Scalars['String'];
  description: Scalars['String'];
  lastModifiedDate?: Maybe<Scalars['DateTime']>;
};

export enum SearchContainerStatus {
  ARCHIVED = 'ARCHIVED',
  CURRENT = 'CURRENT',
}

export type SearchDefaultResult = SearchResult & {
  __typename?: 'SearchDefaultResult';
  id: Scalars['ID'];
  title: Scalars['String'];
  url: Scalars['URL'];
  iconUrl: Scalars['URL'];
  type: Scalars['String'];
  description: Scalars['String'];
  lastModifiedDate?: Maybe<Scalars['DateTime']>;
};

/** Filters to apply to a search */
export type SearchFilterInput = {
  /** ATI strings of which entities to search for */
  entities: Array<Scalars['String']>;
  /** ARIs of which workspaces, cloudIds or orgs to search in */
  locations: Array<Scalars['String']>;
  /** Confluence specific filters */
  confluenceFilters?: Maybe<SearchConfluenceFilter>;
};

export type SearchItemConnection = {
  __typename?: 'SearchItemConnection';
  /** The search result items as per pagination specs */
  edges: Array<SearchResultItemEdge>;
  /** The page info as per pagination specs */
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']>;
};

/** Entry point for all searches */
export type SearchQueryApi = {
  __typename?: 'SearchQueryAPI';
  /** Searches for some entities */
  search: SearchItemConnection;
};

/** Entry point for all searches */
export type SearchQueryApiSearchArgs = {
  query?: Maybe<Scalars['String']>;
  filters?: Maybe<SearchFilterInput>;
  analytics?: Maybe<SearchAnalyticsInput>;
  experience: Scalars['String'];
  first?: Maybe<Scalars['Int']>;
};

/** Search Result type */
export type SearchResult = {
  id: Scalars['ID'];
  title: Scalars['String'];
  url: Scalars['URL'];
  iconUrl: Scalars['URL'];
  type: Scalars['String'];
  description: Scalars['String'];
  lastModifiedDate?: Maybe<Scalars['DateTime']>;
};

export type SearchResultItemEdge = {
  __typename?: 'SearchResultItemEdge';
  /**
   * The search result object, this is a union type of all possible search result types.
   * A different definition will be provided for all entities supported by Atlassian
   */
  node?: Maybe<SearchResult>;
  /** Opaque string containing the cursor for this edge */
  cursor?: Maybe<Scalars['String']>;
};

export type SearchSpace = {
  __typename?: 'SearchSpace';
  key: Scalars['String'];
  iconUrl: Scalars['URL'];
};

export type SetAppEnvironmentVariableInput = {
  environment: AppEnvironmentInput;
  /** The input identifying the environment variable to insert */
  environmentVariable: AppEnvironmentVariableInput;
};

export type SetAppEnvironmentVariablePayload = Payload & {
  __typename?: 'SetAppEnvironmentVariablePayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type SetAppStoredEntityMutationInput = {
  /** The ARI to store this entity within */
  contextAri: Scalars['ID'];
  /** Specify whether value should be encrypted */
  encrypted?: Maybe<Scalars['Boolean']>;
  /**
   * The identifier for the entity
   *
   * Keys must be between 1-100 characters long and must match the following pattern /^[a-zA-Z0-9:._\s-]+$/
   */
  key: Scalars['ID'];
  /**
   * Entities may be up to 2000 bytes long. Note that size within ESS may differ from
   * the size of the entity sent to this service. The entity size is counted within this service.
   */
  value: Scalars['JSON'];
};

/** Generic implementation of MutationResponse for responses that don't need any extra data */
export type SetAppStoredEntityPayload = Payload & {
  __typename?: 'SetAppStoredEntityPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type SetColumnLimitInput = {
  boardId: Scalars['ID'];
  columnId: Scalars['ID'];
  limit?: Maybe<Scalars['Int']>;
};

export type SetColumnLimitOutput = MutationResponse & {
  __typename?: 'SetColumnLimitOutput';
  columns?: Maybe<Array<Column>>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export type SetColumnNameInput = {
  boardId: Scalars['ID'];
  columnId: Scalars['ID'];
  columnName: Scalars['String'];
};

export type SetColumnNameOutput = MutationResponse & {
  __typename?: 'SetColumnNameOutput';
  column?: Maybe<Column>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Estimation Mutation */
export type SetEstimationTypeInput = {
  boardId: Scalars['ID'];
  estimationType: Scalars['String'];
};

export type SetExternalAuthCredentialsInput = {
  /** An object representing the credentials to set */
  credentials: ExternalAuthCredentialsInput;
  /** The input identifying what environment to set credentials for */
  environment: AppEnvironmentInput;
  /** The key for the service we're setting the credentials for (must already exist via previous deployment) */
  serviceKey: Scalars['String'];
};

export type SetExternalAuthCredentialsPayload = Payload & {
  __typename?: 'SetExternalAuthCredentialsPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type SetPolarisProjectOnboardedInput = {
  projectId: Scalars['ID'];
  value: Scalars['Boolean'];
};

export type SetPolarisProjectOnboardedPayload = Payload & {
  __typename?: 'SetPolarisProjectOnboardedPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type SetPolarisSelectedDeliveryProjectInput = {
  projectId: Scalars['ID'];
  selectedDeliveryProjectId: Scalars['ID'];
};

export type SetPolarisSelectedDeliveryProjectPayload = Payload & {
  __typename?: 'SetPolarisSelectedDeliveryProjectPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type SetPolarisSnippetPropertiesConfigInput = {
  /** Config */
  config?: Maybe<Scalars['JSON']>;
  /** Snippet group id */
  groupId: Scalars['String'];
  /** OauthClientId of CaaS app */
  oauthClientId: Scalars['String'];
  /** project ARI */
  project: Scalars['ID'];
};

export type SetPolarisSnippetPropertiesConfigPayload = Payload & {
  __typename?: 'SetPolarisSnippetPropertiesConfigPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Swimlane Mutations */
export type SetSwimlaneStrategyInput = {
  boardId: Scalars['ID'];
  strategy: SwimlaneStrategy;
};

export type SetSwimlaneStrategyResponse = MutationResponse & {
  __typename?: 'SetSwimlaneStrategyResponse';
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  strategy: SwimlaneStrategy;
  success: Scalars['Boolean'];
};

export type SoftwareBoard = {
  __typename?: 'SoftwareBoard';
  /** List of the assignees of all cards currently displayed on the board */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** All issue children which are linked to the cards on the board */
  cardChildren?: Maybe<Array<Maybe<SoftwareCard>>>;
  /** Configuration for showing media previews on cards */
  cardMedia?: Maybe<CardMediaConfig>;
  /** [CardType]s which can be created in this column _outside of a swimlane_ (if any) */
  cardTypes: Array<Maybe<CardType>>;
  /** All cards on the board, optionally filtered by ID */
  cards?: Maybe<Array<Maybe<SoftwareCard>>>;
  /** The list of columns on the board */
  columns?: Maybe<Array<Maybe<Column>>>;
  /**
   * Board edit config. Contains properties which dictate how to mutate the board
   * data, e.g support for inline issue or column creation
   */
  editConfig?: Maybe<BoardEditConfig>;
  /** Whether any cards on the board are hidden due to board clearing logic (e.g. old cards in the done column are hidden) */
  hasClearedCards?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['ID']>;
  /** Configuration for showing inline card create */
  inlineCardCreate?: Maybe<InlineCardCreateConfig>;
  /** List of all labels on all cards current displayed on the board */
  labels?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Name of the board */
  name?: Maybe<Scalars['String']>;
  /** Temporarily needed to support legacy write API */
  rankCustomFieldId?: Maybe<Scalars['String']>;
  /**
   * The current swimlane strategy for the board.  This is a board (not user) property.
   * All users of the board get the same strategy.
   */
  swimlaneStrategy?: Maybe<SwimlaneStrategy>;
  /**
   * Swimlanes on the board.  If swimlanes are set to "NONE" then this there will be a single swimlane object containing
   *  all cards on the board.
   */
  swimlanes: Array<Maybe<Swimlane>>;
  /**
   * User Swimlanes on the board.  If swimlanes are set to "NONE" then this there will be a single swimlane object containing
   *  all cards on the board.
   */
  userSwimlanes: Array<Maybe<Swimlane>>;
};

export type SoftwareBoardCardsArgs = {
  cardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

/** A card on the board */
export type SoftwareCard = {
  __typename?: 'SoftwareCard';
  assignee?: Maybe<User>;
  /** Child cards metadata */
  childCardsMetadata?: Maybe<ChildCardsMetadata>;
  /** List of children IDs for a card */
  childrenIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
  /** Details of the media to show on this card, null if the card has no media */
  coverMedia?: Maybe<CardCoverMedia>;
  /** Dev Status information for the card */
  devStatus?: Maybe<DevStatus>;
  /** Whether or not this card is considered done */
  done?: Maybe<Scalars['Boolean']>;
  /** Due date */
  dueDate?: Maybe<Scalars['String']>;
  /** Estimate of size of a card */
  estimate?: Maybe<Estimate>;
  /** IDs of the fix versions that this issue is related to */
  fixVersionsIds: Array<Scalars['ID']>;
  /** Whether or not this card is flagged */
  flagged?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['ID']>;
  key?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** ID of parent card */
  parentId?: Maybe<Scalars['ID']>;
  /** Card priority */
  priority?: Maybe<CardPriority>;
  status?: Maybe<CardStatus>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<CardType>;
};

export type SoftwareCardChildrenInfo = {
  __typename?: 'SoftwareCardChildrenInfo';
  doneStats?: Maybe<SoftwareCardChildrenInfoStats>;
  inProgressStats?: Maybe<SoftwareCardChildrenInfoStats>;
  lastColumnIssueStats?: Maybe<SoftwareCardChildrenInfoStats>;
  todoStats?: Maybe<SoftwareCardChildrenInfoStats>;
};

export type SoftwareCardChildrenInfoStats = {
  __typename?: 'SoftwareCardChildrenInfoStats';
  cardCount?: Maybe<Scalars['Int']>;
};

export type SoftwareCardsDestination = {
  destination?: Maybe<SoftwareCardsDestinationEnum>;
  sprintId?: Maybe<Scalars['ID']>;
};

export enum SoftwareCardsDestinationEnum {
  BACKLOG = 'BACKLOG',
  EXISTING_SPRINT = 'EXISTING_SPRINT',
  NEW_SPRINT = 'NEW_SPRINT',
}

/** Represents a specific transition between statuses that a card can make. */
export type SoftwareCardTransition = {
  __typename?: 'SoftwareCardTransition';
  /** Card type that this transition applies to */
  cardType: CardType;
  /** true if the transition has conditions */
  hasConditions?: Maybe<Scalars['Boolean']>;
  /** Identifier for the card's column in swimlane position, to be used as a target for card transitions */
  id?: Maybe<Scalars['ID']>;
  /** true if global transition (anything status can move to this location). */
  isGlobal?: Maybe<Scalars['Boolean']>;
  /** true if the transition is initial */
  isInitial?: Maybe<Scalars['Boolean']>;
  /** Name of the transition, as set in the workflow editor */
  name: Scalars['String'];
  /** statuses which can move to this location, null if global transition. */
  originStatus?: Maybe<CardStatus>;
  /** The status the card's issue will end up in after executing this CardTransition */
  status?: Maybe<CardStatus>;
};

export type SoftwareCardTypeTransition = {
  __typename?: 'SoftwareCardTypeTransition';
  /** Card type that this transition applies to */
  cardType: CardType;
  /** true if the transition has conditions */
  hasConditions?: Maybe<Scalars['Boolean']>;
  /** true if global transition (anything status can move to this location). */
  isGlobal?: Maybe<Scalars['Boolean']>;
  /** true if the transition is initial */
  isInitial?: Maybe<Scalars['Boolean']>;
  /** Name of the transition, as set in the workflow editor */
  name: Scalars['String'];
  /** statuses which can move to this location, null if global transition. */
  originStatus?: Maybe<CardStatus>;
  /** The status the card's issue will end up in after executing this SoftwareCardTypeTransition */
  status?: Maybe<CardStatus>;
  /** Non unique ID of the transition used as a target for card transitions */
  transitionId?: Maybe<Scalars['ID']>;
};

export type SoftwareOperation = {
  __typename?: 'SoftwareOperation';
  icon?: Maybe<Icon>;
  name?: Maybe<Scalars['String']>;
  styleClass?: Maybe<Scalars['String']>;
  tooltip?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

export type SoftwareProject = {
  __typename?: 'SoftwareProject';
  /**
   * List of card types available in the project
   * When on the board, these will NOT include Epics or Subtasks, but when in boardScope they will
   */
  cardTypes?: Maybe<Array<Maybe<CardType>>>;
  /** Project id */
  id?: Maybe<Scalars['ID']>;
  /** Project key */
  key?: Maybe<Scalars['String']>;
  /** Project name */
  name?: Maybe<Scalars['String']>;
};

export type SoftwareProjectCardTypesArgs = {
  hierarchyLevelType?: Maybe<CardHierarchyLevelEnumType>;
};

export type SoftwareReport = {
  __typename?: 'SoftwareReport';
  /** Which group this report should be shown in */
  group: Scalars['String'];
  id: Scalars['ID'];
  /** uri of the report's icon */
  imageUri: Scalars['String'];
  /** if not applicable - localised text as to why */
  inapplicableDescription?: Maybe<Scalars['String']>;
  /** if not applicable - localised text as to why */
  inapplicableReason?: Maybe<Scalars['String']>;
  /** whether or not this report is applicable (is enabled for) this board */
  isApplicable: Scalars['Boolean'];
  /** unique key identifying the report */
  key: Scalars['String'];
  /** the name of the report in the user's language */
  localisedDescription: Scalars['String'];
  /** the name of the report in the user's language */
  localisedName: Scalars['String'];
  /**
   * suffix to apply to the reports url to load this report.
   * e.g. https://tenant.com/secure/RapidBoard.jspa?rapidView=*boardId*&view=reports&report=*urlName*
   */
  urlName: Scalars['String'];
};

/** Node for querying any report page's data */
export type SoftwareReports = {
  __typename?: 'SoftwareReports';
  /** Data for the burndown chart report */
  burndownChart: BurndownChart;
  /** Data for the cumulative flow diagram report */
  cumulativeFlowDiagram?: Maybe<CumulativeFlowDiagram>;
  /** Data for the reports list overview */
  overview?: Maybe<ReportsOverview>;
};

export type SoftwareSprintMetadata = {
  __typename?: 'SoftwareSprintMetadata';
  /**  Number of Completed Issues in Sprint */
  numCompletedIssues?: Maybe<Scalars['Int']>;
  /**  Number of Open Issues in Sprint */
  numOpenIssues?: Maybe<Scalars['Int']>;
  /**  Keys of Unresolved Cards */
  top100CompletedCardKeysWithIncompleteChildren?: Maybe<
    Array<Maybe<Scalars['String']>>
  >;
};

/** The sort direction of the collection */
export enum SortDirection {
  /** Sort in ascending order */
  ASC = 'ASC',
  /** Sort in descending order */
  DESC = 'DESC',
}

export type Sprint = {
  __typename?: 'Sprint';
  cards: Array<Maybe<SoftwareCard>>;
  /** The number of days remaining */
  daysRemaining?: Maybe<Scalars['Int']>;
  /** The end date of the sprint, in ISO 8601 format */
  endDate?: Maybe<Scalars['DateTime']>;
  /** The sprint's goal, null if no goal is set */
  goal?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  /** The sprint's name */
  name?: Maybe<Scalars['String']>;
  sprintMetadata?: Maybe<SoftwareSprintMetadata>;
  sprintState: SprintState;
  /** The start date of the sprint, in ISO 8601 format */
  startDate?: Maybe<Scalars['DateTime']>;
};

export type SprintCardsArgs = {
  cardIds?: Maybe<Array<Maybe<Scalars['ID']>>>;
};

export type SprintEndData = {
  __typename?: 'SprintEndData';
  /** list of all issues that are in the sprint with their estimates */
  issueList: Array<Maybe<ScopeSprintIssue>>;
  /** scope remaining at the end of the sprint */
  remainingEstimate: Scalars['Float'];
  /** timestamp of when sprint was completed */
  timestamp: Scalars['DateTime'];
};

export enum SprintReportsEstimationStatisticType {
  ISSUE_COUNT = 'ISSUE_COUNT',
  ORIGINAL_ESTIMATE = 'ORIGINAL_ESTIMATE',
  STORY_POINTS = 'STORY_POINTS',
}

export type SprintReportsFilters = {
  __typename?: 'SprintReportsFilters';
  /** Possible statistic that we want to track */
  estimationStatistic: Array<Maybe<SprintReportsEstimationStatisticType>>;
  /** List of sprints to select from */
  sprints: Array<Maybe<Sprint>>;
};

export type SprintResponse = MutationResponse & {
  __typename?: 'SprintResponse';
  message: Scalars['String'];
  sprint?: Maybe<Sprint>;
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

export type SprintScopeChangeData = {
  __typename?: 'SprintScopeChangeData';
  /** amount completed of the esimtation statistic */
  completion: Scalars['Float'];
  /** estimation of the issue after this change */
  estimate?: Maybe<Scalars['Float']>;
  /** type of event */
  eventType: Scalars['SprintScopeChangeEventType'];
  /** the issue involved in the change */
  issueKey: Scalars['String'];
  /** the issue description */
  issueSummary: Scalars['String'];
  /** the previous completed amount before this change */
  prevCompletion: Scalars['Float'];
  /** the previous estimation before this change */
  prevEstimate?: Maybe<Scalars['Float']>;
  /** the previous remaining amount before this change */
  prevRemaining: Scalars['Float'];
  /** the sprint scope before the change */
  prevScope: Scalars['Float'];
  /** amount remaining of the estimation statistic */
  remaining: Scalars['Float'];
  /** sprint scope after this change */
  scope: Scalars['Float'];
  /** timestamp of change */
  timestamp: Scalars['DateTime'];
};

export type SprintStartData = {
  __typename?: 'SprintStartData';
  /** list of all issues that are in the sprint with their estimates */
  issueList: Array<Maybe<ScopeSprintIssue>>;
  /** scope estimate for start of sprint */
  scopeEstimate: Scalars['Float'];
  timestamp: Scalars['DateTime'];
};

export enum SprintState {
  ACTIVE = 'ACTIVE',
  CLOSED = 'CLOSED',
  FUTURE = 'FUTURE',
}

/** Start sprint */
export type StartSprintInput = {
  boardId: Scalars['ID'];
  endDate: Scalars['String'];
  goal?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  sprintId: Scalars['ID'];
  startDate: Scalars['String'];
};

export type SupportRequest = SupportRequestCommonRequest & {
  __typename?: 'SupportRequest';
  /** The comments that should be obtained for this request. */
  comments: SupportRequestComments;
  /** The date that the request was created in the format 'yyyy-MM-dd'T'HH:mm:ss.SSSX', for example 2019-10-10T10:10:10.1000Z. */
  createdDate: SupportRequestDisplayableDateTime;
  /** The full description for this request in wiki markup format (Jira format). */
  description: Scalars['String'];
  /**
   * The public facing fields that are relevant to this request. There may be other
   * fields internally that are not being exposed here.
   */
  fields: Array<SupportRequestField>;
  /**
   * The unique identifier for this request. It will make it unique across multiple
   * systems, for example 'GSAC-CA-1000' for GSAC requests.
   */
  id: Scalars['ID'];
  /** The users that are participants for this request */
  participants: Array<SupportRequestUser>;
  /** The public facing name for the project that this request is in, for example Customer Advocates. */
  projectName: Scalars['String'];
  /** The user that reported this request. This value can be null if the reporter has been removed from the request. */
  reporter: SupportRequestUser;
  /** The public facing name for this request type, for example Support Request. */
  requestTypeName: Scalars['String'];
  /** The flag whether request view should be routed to the customer support portal. */
  routeToSupportPortal: Scalars['Boolean'];
  /** The current status of the request, for example open. */
  status: SupportRequestStatus;
  /** Gets the status transitioned on the request ID. */
  statuses: SupportRequestStatuses;
  /** The short general description of the request. */
  summary?: Maybe<Scalars['String']>;
  /** The flag whether request view should be routed to the customer support portal read/write view or gsac customer view. */
  targetScreen: Scalars['String'];
  /** Gets the possible transitions on the request ID. */
  transitions: SupportRequestTransitions;
};

export type SupportRequestCommentsArgs = {
  offset?: Maybe<Scalars['Int']>;
  size?: Maybe<Scalars['Int']>;
};

export type SupportRequestStatusesArgs = {
  offset?: Maybe<Scalars['Int']>;
  size?: Maybe<Scalars['Int']>;
};

export type SupportRequestTransitionsArgs = {
  offset?: Maybe<Scalars['Int']>;
  size?: Maybe<Scalars['Int']>;
};

export type SupportRequestAddCommentInput = {
  /** unique key/id of the request ticket */
  issueKey: Scalars['String'];
  /** The comment message in wiki markup format (Jira format). */
  message: Scalars['String'];
};

/** The top level wrapper for the CSP Support Request Mutations API. */
export type SupportRequestCatalogMutationApi = {
  __typename?: 'SupportRequestCatalogMutationApi';
  /** Add customer comment on a support request */
  addComment?: Maybe<SupportRequestComment>;
  /** Perform status transition of support request */
  statusTransition?: Maybe<Scalars['Boolean']>;
};

/** The top level wrapper for the CSP Support Request Mutations API. */
export type SupportRequestCatalogMutationApiAddCommentArgs = {
  input?: Maybe<SupportRequestAddCommentInput>;
};

/** The top level wrapper for the CSP Support Request Mutations API. */
export type SupportRequestCatalogMutationApiStatusTransitionArgs = {
  input?: Maybe<SupportRequestTransitionInput>;
};

/** Top level wrapper for CSP Support Request queries API */
export type SupportRequestCatalogQueryApi = {
  __typename?: 'SupportRequestCatalogQueryApi';
  /** Get information about the current logged in user. This can be used to get the requests for the current user. */
  me?: Maybe<SupportRequestPage>;
  /** Obtain an individual request. */
  supportRequest?: Maybe<SupportRequest>;
};

/** Top level wrapper for CSP Support Request queries API */
export type SupportRequestCatalogQueryApiSupportRequestArgs = {
  key: Scalars['ID'];
};

/** A comment for the request. These are non-heirarchical comments and are only linked to a single request. */
export type SupportRequestComment = {
  __typename?: 'SupportRequestComment';
  /** The user that created this comment. */
  author: SupportRequestUser;
  /** The date that this comment was originally created */
  createdDate: SupportRequestDisplayableDateTime;
  /** The comment message in wiki markup format (Jira format). */
  message: Scalars['String'];
};

export type SupportRequestComments = {
  __typename?: 'SupportRequestComments';
  /** Indicates whether the current page returned is the last page of results. */
  lastPage: Scalars['Boolean'];
  /** Total number of items to return, subject to server enforced limits. */
  limit: Scalars['Int'];
  /** The item used as the first item in the page of results */
  offset: Scalars['Int'];
  /** Number of items to return per page */
  size: Scalars['Int'];
  /** List of comment. */
  values: Array<SupportRequestComment>;
};

/** All of the Queries that are available. */
export type SupportRequestCommonRequest = {
  /** The date that the request was created in the format 'yyyy-MM-dd'T'HH:mm:ss.SSSX', for example 2019-10-10T10:10:10.1000Z. */
  createdDate: SupportRequestDisplayableDateTime;
  /** The full description for this request in wiki markup format (Jira format). */
  description: Scalars['String'];
  /**
   * The unique identifier for this request. It will make it unique across multiple
   * systems, for example 'GSAC-CA-1000' for GSAC requests.
   */
  id: Scalars['ID'];
  /** The users that are participants for this request */
  participants: Array<SupportRequestUser>;
  /** The user that reported this request. This value can be null if the reporter has been removed from the request. */
  reporter: SupportRequestUser;
  /** The public facing name for this request type, for example Support Request. */
  requestTypeName: Scalars['String'];
  /** The current status of the request, for example open. */
  status: SupportRequestStatus;
  /** The short general description of the request. */
  summary?: Maybe<Scalars['String']>;
};

export type SupportRequestContactRelation = {
  __typename?: 'SupportRequestContactRelation';
  /** contact details of a user */
  contact?: Maybe<SupportRequestUser>;
  /** Open request tickets for a user */
  openRequest?: Maybe<SupportRequestTicket>;
};

/** A DateTime type for the request, this contains multiple formats of datetime */
export type SupportRequestDisplayableDateTime = {
  __typename?: 'SupportRequestDisplayableDateTime';
  /** Offset friendly date time */
  dateTime: Scalars['String'];
  /** Epoch milliseconds */
  epochMillis: Scalars['Long'];
  /** Display friendly date time. */
  friendly: Scalars['String'];
};

export type SupportRequestField = {
  __typename?: 'SupportRequestField';
  /** Unique Id of the field, for example description, custom_field_1234 */
  id: Scalars['String'];
  /** The public facing name of the field, for example Priority, Customer Timezone */
  label: Scalars['String'];
  /** The public facing value of the field. */
  value: SupportRequestFieldValue;
};

/** The value of the field. This has been kept as a seperate type for extensibility, such as including icons.  */
export type SupportRequestFieldValue = {
  __typename?: 'SupportRequestFieldValue';
  /** The value of the field, e.g. Priority 4. */
  value: Scalars['String'];
};

export type SupportRequestHierarchyRequest = SupportRequestCommonRequest & {
  __typename?: 'SupportRequestHierarchyRequest';
  /** child ticket(s) to this request  */
  children?: Maybe<Array<SupportRequestHierarchyRequest>>;
  /** The date that the request was created in the format 'yyyy-MM-dd'T'HH:mm:ss.SSSX', for example 2019-10-10T10:10:10.1000Z. */
  createdDate: SupportRequestDisplayableDateTime;
  /** The full description for this request in wiki markup format (Jira format). */
  description: Scalars['String'];
  /**
   * The unique identifier for this request. It will make it unique across multiple
   * systems, for example 'GSAC-CA-1000' for GSAC requests.
   */
  id: Scalars['ID'];
  /** Parent ticket to this Request */
  parent?: Maybe<SupportRequestHierarchyRequest>;
  /** The users that are participants for this request */
  participants: Array<SupportRequestUser>;
  /** The user that reported this request. This value can be null if the reporter has been removed from the request. */
  reporter: SupportRequestUser;
  /** The public facing name for this request type, for example Support Request. */
  requestTypeName: Scalars['String'];
  /** The current status of the request, for example open. */
  status: SupportRequestStatus;
  /** The short general description of the request. */
  summary?: Maybe<Scalars['String']>;
  /** The flag whether request view should be routed to the customer support portal read/write view or gsac customer view. */
  targetScreen: Scalars['String'];
};

export type SupportRequestHierarchyRequests = {
  __typename?: 'SupportRequestHierarchyRequests';
  page: Array<SupportRequestHierarchyRequest>;
  total: Scalars['Int'];
};

export type SupportRequestNamedContactRelation = {
  __typename?: 'SupportRequestNamedContactRelation';
  /** List of named contacts relations for a user */
  contactRelations?: Maybe<Array<Maybe<SupportRequestContactRelation>>>;
  /** The unique id of the org in case of cloud enterprise */
  orgId?: Maybe<Scalars['String']>;
  /** Name of the org in case of cloud enterprise */
  orgName?: Maybe<Scalars['String']>;
  /** Support Entitlement Number. This is relevant only for premier support server business */
  sen?: Maybe<Scalars['String']>;
};

export type SupportRequestNamedContactRelations = {
  __typename?: 'SupportRequestNamedContactRelations';
  cloudEnterpriseRelations?: Maybe<
    Array<Maybe<SupportRequestNamedContactRelation>>
  >;
  premierSupportRelations?: Maybe<
    Array<Maybe<SupportRequestNamedContactRelation>>
  >;
};

/** A user (customer or agent) of the support system. */
export type SupportRequestPage = {
  __typename?: 'SupportRequestPage';
  /** Search for the migration requests that the user reported and/or participated in */
  migrationRequests?: Maybe<SupportRequestHierarchyRequests>;
  /** Search for the named contacts of the orgs/sens that user belongs to */
  namedContactRelations?: Maybe<SupportRequestNamedContactRelations>;
  profile?: Maybe<SupportRequestUser>;
  /** Search for the requests that the user reported and/or participated in */
  requests?: Maybe<SupportRequests>;
};

/** A user (customer or agent) of the support system. */
export type SupportRequestPageMigrationRequestsArgs = {
  offset?: Scalars['Int'];
  ownership?: Maybe<SupportRequestQueryOwnership>;
  size?: Scalars['Int'];
  status?: Maybe<SupportRequestQueryStatusCategory>;
};

/** A user (customer or agent) of the support system. */
export type SupportRequestPageRequestsArgs = {
  backend?: Maybe<Array<Scalars['String']>>;
  offset?: Scalars['Int'];
  ownership?: Maybe<SupportRequestQueryOwnership>;
  project?: Maybe<Scalars['String']>;
  requestType?: Maybe<Scalars['String']>;
  searchTerm?: Maybe<Scalars['String']>;
  size?: Scalars['Int'];
  status?: Maybe<SupportRequestQueryStatusCategory>;
};

/** Query parameter for how this user has access to the request, e.g. they were the reporter or added as a participant. */
export enum SupportRequestQueryOwnership {
  PARTICIPANT = 'PARTICIPANT',
  REPORTER = 'REPORTER',
}

/** The general category for the status of the ticket. */
export enum SupportRequestQueryStatusCategory {
  DONE = 'DONE',
  OPEN = 'OPEN',
}

export type SupportRequests = {
  __typename?: 'SupportRequests';
  page: Array<SupportRequest>;
  total: Scalars['Int'];
};

export type SupportRequestStatus = {
  __typename?: 'SupportRequestStatus';
  /** General category of request's status. */
  category: SupportRequestStatusCategory;
  /** The date at which the status change was done. */
  createdDate?: Maybe<SupportRequestDisplayableDateTime>;
  /** The descriptive, publically-facing text shown to customers for this request */
  text: Scalars['String'];
};

/** The general category for the status of the ticket. */
export enum SupportRequestStatusCategory {
  DONE = 'DONE',
  IN_PROGRESS = 'IN_PROGRESS',
  OPEN = 'OPEN',
}

export type SupportRequestStatuses = {
  __typename?: 'SupportRequestStatuses';
  /** Indicates whether the current page returned is the last page of results. */
  lastPage: Scalars['Boolean'];
  /** Total number of items to return, subject to server enforced limits. */
  limit: Scalars['Int'];
  /** The item used as the first item in the page of results */
  offset: Scalars['Int'];
  /** Number of items to return per page */
  size: Scalars['Int'];
  /** List of status transitions. */
  values: Array<SupportRequestStatus>;
};

export type SupportRequestTicket = {
  __typename?: 'SupportRequestTicket';
  /** unique key/id of the request ticket */
  issueKey?: Maybe<Scalars['String']>;
};

export type SupportRequestTransition = {
  __typename?: 'SupportRequestTransition';
  /** Unique transition Id of the field. */
  id: Scalars['String'];
  /** The transition name, publically-facing text shown to customers for this request */
  name: Scalars['String'];
};

export type SupportRequestTransitionInput = {
  /** The comment message in wiki markup format (Jira format). */
  comment?: Maybe<Scalars['String']>;
  /** unique key/id of the request ticket */
  requestKey: Scalars['String'];
  /** transition Id of from workflow */
  transitionId: Scalars['ID'];
};

export type SupportRequestTransitions = {
  __typename?: 'SupportRequestTransitions';
  /** Indicates whether the current page returned is the last page of results. */
  lastPage: Scalars['Boolean'];
  /** Total number of items to return, subject to server enforced limits. */
  limit: Scalars['Int'];
  /** The item used as the first item in the page of results */
  offset: Scalars['Int'];
  /** Number of items to return per page */
  size: Scalars['Int'];
  /** List of status transitions. */
  values: Array<SupportRequestTransition>;
};

export type SupportRequestUser = {
  __typename?: 'SupportRequestUser';
  /** The GSAC display name of user */
  displayName?: Maybe<Scalars['String']>;
  /** The GSAC email for this user */
  email?: Maybe<Scalars['String']>;
  /** Identity User */
  user?: Maybe<User>;
  /** The GSAC username for this user. */
  username?: Maybe<Scalars['String']>;
};

export type Swimlane = {
  __typename?: 'Swimlane';
  /** The set of card types allowed in the swimlane */
  allowedCardTypes?: Maybe<Array<CardType>>;
  /** The column data */
  columnsInSwimlane?: Maybe<Array<Maybe<ColumnInSwimlane>>>;
  /** The icon to show for the swimlane */
  iconUrl?: Maybe<Scalars['String']>;
  /**
   * The swimlane ID.  This will match the id of the object the swimlane is grouping by.  e.g. Epic's it will be the
   * epic's issue Id.  For assignees it will be the assignee's atlassian account id.   For swimlanes which do not
   * represent a object (e.g. "Issues without assignee's" swimlane) the value will be "0".
   */
  id?: Maybe<Scalars['ID']>;
  /** The name of the swimlane */
  name?: Maybe<Scalars['String']>;
};

/** How to group cards on the board into swimlanes */
export enum SwimlaneStrategy {
  ASSIGNEE = 'ASSIGNEE',
  ISSUECHILDREN = 'ISSUECHILDREN',
  ISSUEPARENT = 'ISSUEPARENT',
  NONE = 'NONE',
}

export type Team = {
  __typename?: 'Team';
  id: Scalars['ID'];
  displayName?: Maybe<Scalars['String']>;
  smallAvatarImageUrl?: Maybe<Scalars['String']>;
  largeAvatarImageUrl?: Maybe<Scalars['String']>;
};

export type TeamQuery = {
  __typename?: 'TeamQuery';
  /** Returns the team with the given ARI */
  team?: Maybe<Team>;
};

export type TeamQueryTeamArgs = {
  id: Scalars['ID'];
};

export type TenantContext = {
  __typename?: 'TenantContext';
  /** This cloud id of a tenanted Jira or Confluence instance */
  cloudId?: Maybe<Scalars['ID']>;
  /** This host name of a tenanted Jira or Confluence instance */
  hostName?: Maybe<Scalars['String']>;
  /** The organization id for this tenant */
  orgId?: Maybe<Scalars['ID']>;
};

/**
 * ### OAuth Scopes
 *
 * The following scopes will need to be present on OAuth requests to get data from this field
 *
 * * __read:jira-work__
 */
export type Testing = {
  __typename?: 'Testing';
  /** Echos the message argument back to the caller */
  echo?: Maybe<Scalars['String']>;
  /**
   * This returns a hypothetical Movie by id for testing purposes
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:jira-work__
   */
  movie?: Maybe<TestingMovie>;
  /** This returns a list of hypothetical Movies for testing purposes */
  movies?: Maybe<Array<Maybe<TestingMovie>>>;
  /** Generates a new UUID */
  uuid?: Maybe<Scalars['String']>;
};

/**
 * ### OAuth Scopes
 *
 * The following scopes will need to be present on OAuth requests to get data from this field
 *
 * * __read:jira-work__
 */
export type TestingEchoArgs = {
  message?: Maybe<Scalars['String']>;
};

/**
 * ### OAuth Scopes
 *
 * The following scopes will need to be present on OAuth requests to get data from this field
 *
 * * __read:jira-work__
 */
export type TestingMovieArgs = {
  id: Scalars['ID'];
};

export type TestingCharacter = {
  __typename?: 'TestingCharacter';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type TestingMovie = {
  __typename?: 'TestingMovie';
  characters?: Maybe<Array<Maybe<TestingCharacter>>>;
  id: Scalars['ID'];
  renamedName?: Maybe<Scalars['String']>;
};

/** The input for a Third Party Repository */
export type ThirdPartyRepositoryInput = {
  /** Avatar details for the third party repository. */
  avatar?: Maybe<AvatarInput>;
  /** The ID of the third party repository. */
  id: Scalars['ID'];
  /** The name of the third party repository. */
  name?: Maybe<Scalars['String']>;
  /** The URL of the third party repository. */
  webUrl?: Maybe<Scalars['String']>;
};

/**
 * General Report Types
 * ====================
 */
export type TimeSeriesPoint = {
  __typename?: 'TimeSeriesPoint';
  id: Scalars['ID'];
  x: Scalars['DateTime'];
  y: Scalars['Int'];
};

export type TownsquareComment = Node & {
  __typename?: 'TownsquareComment';
  creator?: Maybe<User>;
  id: Scalars['ID'];
  object?: Maybe<TownsquareCommentObject>;
  url?: Maybe<Scalars['String']>;
  uuid?: Maybe<Scalars['String']>;
};

export type TownsquareCommentConnection = {
  __typename?: 'TownsquareCommentConnection';
  edges?: Maybe<Array<Maybe<TownsquareCommentEdge>>>;
  pageInfo: PageInfo;
};

export type TownsquareCommentEdge = {
  __typename?: 'TownsquareCommentEdge';
  cursor: Scalars['String'];
  node?: Maybe<TownsquareComment>;
};

export type TownsquareCommentObject = {
  __typename?: 'TownsquareCommentObject';
  ari?: Maybe<Scalars['String']>;
  iconData?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};

export type TownsquareGoal = Node & {
  __typename?: 'TownsquareGoal';
  archived: Scalars['Boolean'];
  iconData?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  key: Scalars['String'];
  name: Scalars['String'];
  owner?: Maybe<User>;
  url: Scalars['String'];
  uuid: Scalars['String'];
};

export type TownsquareGoalConnection = {
  __typename?: 'TownsquareGoalConnection';
  edges?: Maybe<Array<Maybe<TownsquareGoalEdge>>>;
  pageInfo: PageInfo;
};

export type TownsquareGoalEdge = {
  __typename?: 'TownsquareGoalEdge';
  cursor: Scalars['String'];
  node?: Maybe<TownsquareGoal>;
};

export type TownsquareProject = Node & {
  __typename?: 'TownsquareProject';
  archived: Scalars['Boolean'];
  iconData?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  key: Scalars['String'];
  name: Scalars['String'];
  owner?: Maybe<User>;
  url: Scalars['String'];
  uuid: Scalars['String'];
};

export type TownsquareProjectConnection = {
  __typename?: 'TownsquareProjectConnection';
  edges?: Maybe<Array<Maybe<TownsquareProjectEdge>>>;
  pageInfo: PageInfo;
};

export type TownsquareProjectEdge = {
  __typename?: 'TownsquareProjectEdge';
  cursor: Scalars['String'];
  node?: Maybe<TownsquareProject>;
};

export type TownsquareQueryApi = {
  __typename?: 'TownsquareQueryApi';
  /**
   * Get comments by ARI.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: Townsquare` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  commentsByAri?: Maybe<TownsquareCommentConnection>;
  /**
   * Get goals by ARI.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: Townsquare` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  goalsByAri?: Maybe<TownsquareGoalConnection>;
  /**
   * Get projects by ARI.
   *
   * ### Beta Field
   *
   * This field is currently in a beta phase and may change without notice.
   *
   * To use this field you must set a `X-ExperimentalApi: Townsquare` HTTP header.
   *
   * Use of this header indicates that they are opting into the experimental preview of this field.
   *
   * If you do not set this header then request will be rejected outright.
   *
   * Once the field moves out of the beta phase, then the header will no longer be required or checked.
   */
  projectsByAri?: Maybe<TownsquareProjectConnection>;
};

export type TownsquareQueryApiCommentsByAriArgs = {
  after?: Maybe<Scalars['String']>;
  aris?: Maybe<Array<Maybe<Scalars['String']>>>;
  first?: Maybe<Scalars['Int']>;
};

export type TownsquareQueryApiGoalsByAriArgs = {
  after?: Maybe<Scalars['String']>;
  aris?: Maybe<Array<Maybe<Scalars['String']>>>;
  first?: Maybe<Scalars['Int']>;
};

export type TownsquareQueryApiProjectsByAriArgs = {
  after?: Maybe<Scalars['String']>;
  aris?: Maybe<Array<Maybe<Scalars['String']>>>;
  first?: Maybe<Scalars['Int']>;
};

export type TunnelDefinitionsInput = {
  customUI?: Maybe<Array<Maybe<CustomUiTunnelDefinitionInput>>>;
  /** The URL to tunnel FaaS calls to */
  faasTunnelUrl?: Maybe<Scalars['URL']>;
};

export type UnarchivePolarisInsightsPayload = Payload & {
  __typename?: 'UnarchivePolarisInsightsPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type UnassignIssueParentInput = {
  boardId: Scalars['ID'];
  issueIds: Array<Scalars['ID']>;
};

export type UnassignIssueParentOutput = MutationResponse & {
  __typename?: 'UnassignIssueParentOutput';
  boardScope?: Maybe<BoardScope>;
  clientMutationId?: Maybe<Scalars['ID']>;
  message: Scalars['String'];
  statusCode: Scalars['Int'];
  success: Scalars['Boolean'];
};

/** Handles detaching a dataManager from a Component */
export type UnlinkExternalSourceInput = {
  cloudId: Scalars['ID'];
  /** The ID of the Forge App being uninstalled */
  ecosystemAppId: Scalars['ID'];
  /** The external source name of any ExternalAliases to be removed */
  externalSource: Scalars['String'];
};

export type UnlinkExternalSourcePayload = Payload & {
  __typename?: 'UnlinkExternalSourcePayload';
  /** A list of errors that occurred during the mutation */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation succeeded or not */
  success: Scalars['Boolean'];
};

export type UnwatchMarketplaceAppPayload = Payload & {
  __typename?: 'UnwatchMarketplaceAppPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type UpdateAppDetailsInput = {
  appId: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

export type UpdateAppDetailsResponse = Payload & {
  __typename?: 'UpdateAppDetailsResponse';
  app?: Maybe<App>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Input payload for enrolling scopes to an app environment */
export type UpdateAppHostServiceScopesInput = {
  /** A unique Id representing the app */
  appId: Scalars['ID'];
  /** The key of the app's environment to enrol the scopes */
  environmentKey: Scalars['String'];
  /** The scopes this app will be enrolled to after the request succeeds */
  scopes?: Maybe<Array<Scalars['String']>>;
  /** The Id of the service for which the scopes belong to */
  serviceId: Scalars['ID'];
};

/** Response from enrolling scopes into an app environment */
export type UpdateAppHostServiceScopesResponsePayload = Payload & {
  __typename?: 'UpdateAppHostServiceScopesResponsePayload';
  /** Details about the app */
  app?: Maybe<App>;
  /** Details about the version of the app */
  appEnvironmentVersion?: Maybe<AppEnvironmentVersion>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Input payload for updating an Atlassian OAuth Client mutation */
export type UpdateAtlassianOAuthClientInput = {
  callbacks?: Maybe<Array<Scalars['String']>>;
  clientID: Scalars['ID'];
  refreshToken?: Maybe<RefreshTokenInput>;
};

/** Response from updating an oauth client */
export type UpdateAtlassianOAuthClientResponse = Payload & {
  __typename?: 'UpdateAtlassianOAuthClientResponse';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** Accepts input to update a data manager on a component. */
export type UpdateCompassComponentDataManagerMetadataInput = {
  /** The ID of the component to update a data manager on. */
  componentId: Scalars['ID'];
  /** A URL of the external source of the component's data. */
  externalSourceURL?: Maybe<Scalars['URL']>;
  /** Details about the last sync event to this component. */
  lastSyncEvent?: Maybe<ComponentSyncEventInput>;
};

/** The payload returned from updating a data manager of a component. */
export type UpdateCompassComponentDataManagerMetadataPayload = Payload & {
  __typename?: 'UpdateCompassComponentDataManagerMetadataPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input for updating an existing component. */
export type UpdateCompassComponentInput = {
  /** The description of the component. */
  description?: Maybe<Scalars['String']>;
  /** A collection of fields for storing data about the component. */
  fields?: Maybe<Array<UpdateCompassFieldInput>>;
  /** The ID of the component being updated. */
  id: Scalars['ID'];
  /** The name of the component. */
  name?: Maybe<Scalars['String']>;
  /** The unique identifier (ID) of the team that owns the component. */
  ownerId?: Maybe<Scalars['ID']>;
};

/** Accepts input for updating a component link. */
export type UpdateCompassComponentLinkInput = {
  /** The ID for the component to update the link. */
  componentId: Scalars['ID'];
  /** The link to be updated for the component. */
  link: UpdateCompassLinkInput;
};

/** The payload returned after updating a component link. */
export type UpdateCompassComponentLinkPayload = Payload & {
  __typename?: 'UpdateCompassComponentLinkPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
  /** The newly updated component link. */
  updatedComponentLink?: Maybe<CompassLink>;
};

/** The payload returned from updating an existing component. */
export type UpdateCompassComponentPayload = Payload & {
  __typename?: 'UpdateCompassComponentPayload';
  /**
   * The details of the component that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:component:compass__
   */
  componentDetails?: Maybe<CompassComponent>;
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/** Accepts input to update a field. */
export type UpdateCompassFieldInput = {
  /** The ID of the field definition. */
  definition: Scalars['ID'];
  /** The value of the field. */
  value: CompassFieldValueInput;
};

export type UpdateCompassHasDescriptionScorecardCriteriaInput = {
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID'];
  /** The weight that will be used in determining the aggregate score. */
  weight?: Maybe<Scalars['Int']>;
};

export type UpdateCompassHasFieldScorecardCriteriaInput = {
  /** The ID for the field definition which is the target of a relationship. */
  fieldDefinitionId?: Maybe<Scalars['ID']>;
  /** ID of the scorecard criteria to update */
  id: Scalars['ID'];
  /** The weight that will be used in determining the aggregate score. */
  weight?: Maybe<Scalars['Int']>;
};

export type UpdateCompassHasLinkScorecardCriteriaInput = {
  /** ID of the scorecard criteria to update */
  id: Scalars['ID'];
  /** The type of link, for example, 'Repository' if 'Has Repository'. */
  linkType?: Maybe<CompassLinkType>;
  /** The weight that will be used in determining the aggregate score. */
  weight?: Maybe<Scalars['Int']>;
};

export type UpdateCompassHasOwnerScorecardCriteriaInput = {
  /** The ID of the scorecard criterion to update. */
  id: Scalars['ID'];
  /** The weight that will be used in determining the aggregate score. */
  weight?: Maybe<Scalars['Int']>;
};

/** Accepts details of the link to be updated. */
export type UpdateCompassLinkInput = {
  /** The unique identifier (ID) of the link. */
  id: Scalars['ID'];
  /** The name of the link. */
  name?: Maybe<Scalars['String']>;
  /** The type of the link. */
  type?: Maybe<CompassLinkType>;
  /** The URL of the link. */
  url?: Maybe<Scalars['URL']>;
};

export type UpdateCompassScorecardCriteriaInput = {
  hasDescription?: Maybe<UpdateCompassHasDescriptionScorecardCriteriaInput>;
  hasField?: Maybe<UpdateCompassHasFieldScorecardCriteriaInput>;
  hasLink?: Maybe<UpdateCompassHasLinkScorecardCriteriaInput>;
  hasOwner?: Maybe<UpdateCompassHasOwnerScorecardCriteriaInput>;
};

export type UpdateCompassScorecardCriteriasInput = {
  criterias: Array<UpdateCompassScorecardCriteriaInput>;
};

/** The payload returned from updating a scorecard criterion. */
export type UpdateCompassScorecardCriteriasPayload = Payload & {
  __typename?: 'UpdateCompassScorecardCriteriasPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /**
   * The scorecard that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecard?: Maybe<CompassScorecard>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

export type UpdateCompassScorecardInput = {
  componentType?: Maybe<CompassComponentType>;
  description?: Maybe<Scalars['String']>;
  importance?: Maybe<CompassScorecardImportance>;
  name?: Maybe<Scalars['String']>;
  ownerId?: Maybe<Scalars['ID']>;
};

/** The payload returned from updating a scorecard criterion. */
export type UpdateCompassScorecardPayload = Payload & {
  __typename?: 'UpdateCompassScorecardPayload';
  /** A list of errors that occurred during the mutation. */
  errors?: Maybe<Array<MutationError>>;
  /**
   * The scorecard that was mutated.
   *
   * ### OAuth Scopes
   *
   * The following scopes will need to be present on OAuth requests to get data from this field
   *
   * * __read:scorecard:compass__
   */
  scorecardDetails?: Maybe<CompassScorecard>;
  /** Whether the mutation was successful or not. */
  success: Scalars['Boolean'];
};

/**
 * Updates a custom filter with the given id in the board with the given boardId.
 * The update will update the entire filter (ie. not a partial update)
 */
export type UpdateCustomFilterInput = {
  boardId: Scalars['ID'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  jql: Scalars['String'];
  name: Scalars['String'];
};

export type UpdateDeveloperLogAccessInput = {
  /** AppId as ARI */
  appId: Scalars['ID'];
  /** An array of context ARIs */
  contextIds: Array<Scalars['ID']>;
  /** App environment */
  environmentType: AppEnvironmentType;
  /** Boolean representing whether access should be granted or not */
  shouldHaveAccess: Scalars['Boolean'];
};

export type UpdateDeveloperLogAccessPayload = Payload & {
  __typename?: 'UpdateDeveloperLogAccessPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

/** The request input for updating relationship properties */
export type UpdateDevOpsContainerRelationshipEntityPropertiesInput = {
  /** The ARI of the relationship entity */
  id: Scalars['ID'];
  properties: Array<DevOpsContainerRelationshipEntityPropertyInput>;
};

/** The response payload of updating relationship properties */
export type UpdateDevOpsContainerRelationshipEntityPropertiesPayload = Payload & {
  __typename?: 'UpdateDevOpsContainerRelationshipEntityPropertiesPayload';
  /** The errors occurred during relationship properties update */
  errors?: Maybe<Array<MutationError>>;
  /** Look up JSON properties of the service by keys */
  properties?: Maybe<Scalars['JSON']>;
  /** The result of whether relationship properties have been successfully updated or not */
  success: Scalars['Boolean'];
};

/** The response payload of updating relationship properties */
export type UpdateDevOpsContainerRelationshipEntityPropertiesPayloadPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

/** The request input for updating a relationship between a DevOps Service and Jira Project */
export type UpdateDevOpsServiceAndJiraProjectRelationshipInput = {
  description?: Maybe<Scalars['String']>;
  /** The DevOps Graph Service_And_Jira_Project relationship ARI */
  id: Scalars['ID'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Jira Project to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

export type UpdateDevOpsServiceAndJiraProjectRelationshipPayload = Payload & {
  __typename?: 'UpdateDevOpsServiceAndJiraProjectRelationshipPayload';
  /** The list of errors occurred during create relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The updated relationship */
  serviceAndJiraProjectRelationship?: Maybe<
    DevOpsServiceAndJiraProjectRelationship
  >;
  /** The result of whether the relationship is created successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for updating a relationship between a DevOps Service and an Opsgenie Team */
export type UpdateDevOpsServiceAndOpsgenieTeamRelationshipInput = {
  /** The new description assigned to the relationship. */
  description?: Maybe<Scalars['String']>;
  /** The DevOps Graph Service_And_Opsgenie_Team relationship ARI */
  id: Scalars['ID'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and Opsgenie Team to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

/** The response payload of updating a relationship between a DevOps Service and an Opsgenie Team */
export type UpdateDevOpsServiceAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'UpdateDevOpsServiceAndOpsgenieTeamRelationshipPayload';
  /** The list of errors occurred during update relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The updated relationship between DevOps Service and Opsgenie Team */
  serviceAndOpsgenieTeamRelationship?: Maybe<
    DevOpsServiceAndOpsgenieTeamRelationship
  >;
  /** The result of whether the relationship is updated successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for updating a relationship between a DevOps Service and a Repository */
export type UpdateDevOpsServiceAndRepositoryRelationshipInput = {
  /** The description of the relationship */
  description?: Maybe<Scalars['String']>;
  /** The ARI of the relationship */
  id: Scalars['ID'];
  /**
   * The revision that must be provided when updating a relationship between DevOps Service and a Repository to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

export type UpdateDevOpsServiceAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'UpdateDevOpsServiceAndRepositoryRelationshipPayload';
  /** The list of errors occurred during update of the relationship */
  errors?: Maybe<Array<MutationError>>;
  /** The updated relationship */
  serviceAndRepositoryRelationship?: Maybe<
    DevOpsServiceAndRepositoryRelationship
  >;
  /** The result of whether the relationship is updated successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for updating DevOps Service Entity Properties */
export type UpdateDevOpsServiceEntityPropertiesInput = {
  /** The ARI of the DevOps Service */
  id: Scalars['ID'];
  properties: Array<DevOpsServiceEntityPropertyInput>;
};

/** The response payload of updating DevOps Service Entity Properties */
export type UpdateDevOpsServiceEntityPropertiesPayload = Payload & {
  __typename?: 'UpdateDevOpsServiceEntityPropertiesPayload';
  /** The errors occurred during DevOps Service Entity Properties update */
  errors?: Maybe<Array<MutationError>>;
  /** Look up JSON properties of the service by keys */
  properties?: Maybe<Scalars['JSON']>;
  /** The result of whether DevOps Service Entity Properties have been successfully updated or not */
  success: Scalars['Boolean'];
};

/** The response payload of updating DevOps Service Entity Properties */
export type UpdateDevOpsServiceEntityPropertiesPayloadPropertiesArgs = {
  keys: Array<Scalars['String']>;
};

/** The request input for updating a DevOps Service */
export type UpdateDevOpsServiceInput = {
  /** The new description assigned to the DevOps Service */
  description?: Maybe<Scalars['String']>;
  /** The DevOps Service ARI */
  id: Scalars['ID'];
  /** The new name assigned to the DevOps Service */
  name: Scalars['String'];
  /** The properties of the DevOps Service to be updated */
  properties?: Maybe<Array<DevOpsServiceEntityPropertyInput>>;
  /**
   * The revision that must be provided when updating a DevOps Service to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
  /** The id of the Tier assigned to the Service */
  serviceTier: Scalars['ID'];
};

/** The response payload of updating a DevOps Service */
export type UpdateDevOpsServicePayload = Payload & {
  __typename?: 'UpdateDevOpsServicePayload';
  /** The list of errors occurred during DevOps Service update */
  errors?: Maybe<Array<MutationError>>;
  /** The updated DevOps Service */
  service?: Maybe<DevOpsService>;
  /** The result of whether the DevOps Service is updated successfully or not */
  success: Scalars['Boolean'];
};

/** The request input for updating a DevOps Service Relationship */
export type UpdateDevOpsServiceRelationshipInput = {
  /** The description of the DevOps Service Relationship */
  description?: Maybe<Scalars['String']>;
  /** The DevOps Service Relationship ARI */
  id: Scalars['ID'];
  /**
   * The revision that must be provided when updating a DevOps Service Relationship to prevent
   * simultaneous updates from overwriting each other.
   */
  revision: Scalars['ID'];
};

/** The response payload for updating a inter DevOps Service Relationship */
export type UpdateDevOpsServiceRelationshipPayload = Payload & {
  __typename?: 'UpdateDevOpsServiceRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  /** The updated inter-service relationship */
  serviceRelationship?: Maybe<DevOpsServiceRelationship>;
  success: Scalars['Boolean'];
};

export type UpdateJiraProjectAndOpsgenieTeamRelationshipInput = {
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  revision: Scalars['ID'];
};

export type UpdateJiraProjectAndOpsgenieTeamRelationshipPayload = Payload & {
  __typename?: 'UpdateJiraProjectAndOpsgenieTeamRelationshipPayload';
  errors?: Maybe<Array<MutationError>>;
  /** The updated relationship */
  jiraProjectAndOpsgenieTeamRelationship?: Maybe<
    JiraProjectAndOpsgenieTeamRelationship
  >;
  success: Scalars['Boolean'];
};

/** The request input for updating a relationship between a Jira project and a repository */
export type UpdateJiraProjectAndRepositoryRelationshipInput = {
  /** An optional description of the relationship */
  description?: Maybe<Scalars['String']>;
  /** The relationship ARI */
  id: Scalars['ID'];
  /** Database object revision ID created for the relationship */
  revision: Scalars['ID'];
  /**
   * The third party repository details.
   * This parameter should be null when the relationship involves a Bitbucket repository.
   * When updating third party repository details, the repository ID must stay consistent with the original relationship.
   */
  thirdPartyRepository?: Maybe<ThirdPartyRepositoryInput>;
};

export type UpdateJiraProjectAndRepositoryRelationshipPayload = Payload & {
  __typename?: 'UpdateJiraProjectAndRepositoryRelationshipPayload';
  /** The list of errors occurred during relationship update */
  errors?: Maybe<Array<MutationError>>;
  /** The updated relationship */
  jiraProjectAndRepositoryRelationship?: Maybe<
    JiraProjectAndRepositoryRelationship
  >;
  /** The result of whether the relationship is updated successfully or not */
  success: Scalars['Boolean'];
};

export type UpdatePolarisCalculatedFieldInput = {
  field: Scalars['ID'];
  formula: Scalars['JSON'];
  label: Scalars['String'];
  presentation?: Maybe<PolarisPresentationInput>;
  project: Scalars['ID'];
};

export type UpdatePolarisCalculatedFieldPayload = Payload & {
  __typename?: 'UpdatePolarisCalculatedFieldPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisIdeaField>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisCommentInput = {
  content?: Maybe<Scalars['JSON']>;
  delete?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
};

export type UpdatePolarisCommentPayload = Payload & {
  __typename?: 'UpdatePolarisCommentPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisComment>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisDecorationInput = {
  /** The decoration to apply to a matched value. */
  valueDecoration: PolarisValueDecorationInput;
  /** The decoration can be applied when a value matches all rules in this array. */
  valueRules: Array<PolarisValueRuleInput>;
};

export type UpdatePolarisDecorationPayload = Payload & {
  __typename?: 'UpdatePolarisDecorationPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisDecoration>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisFieldDescriptionInput = {
  description: Scalars['String'];
  field: Scalars['ID'];
  ideaType: Scalars['ID'];
};

export type UpdatePolarisFieldDescriptionPayload = Payload & {
  __typename?: 'UpdatePolarisFieldDescriptionPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisIdeaField>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisFieldOptionWeightInput = {
  field: Scalars['ID'];
  option: Scalars['ID'];
  project: Scalars['ID'];
  weight: Scalars['Int'];
};

export type UpdatePolarisFieldOptionWeightPayload = Payload & {
  __typename?: 'UpdatePolarisFieldOptionWeightPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisIdeaInput = {
  archived?: Maybe<Scalars['Boolean']>;
  lastCommentsViewedTimestamp?: Maybe<Scalars['String']>;
  lastInsightsViewedTimestamp?: Maybe<Scalars['String']>;
};

export type UpdatePolarisIdeaPayload = Payload & {
  __typename?: 'UpdatePolarisIdeaPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisIdea>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisInsightInput = {
  description?: Maybe<Scalars['JSON']>;
  snippets?: Maybe<Array<UpdatePolarisSnippetInput>>;
};

export type UpdatePolarisInsightPayload = Payload & {
  __typename?: 'UpdatePolarisInsightPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisInsight>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisPlayContribution = {
  amount?: Maybe<Scalars['Int']>;
  /**  the extent of the contribution (null=drop value) */
  comment?: Maybe<Scalars['ID']>;
  /**  the comment (null=drop value, which is not permitted; delete the contribution if needed) */
  content?: Maybe<Scalars['JSON']>;
};

export type UpdatePolarisPlayContributionPayload = {
  __typename?: 'UpdatePolarisPlayContributionPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisPlayContribution>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisSnippetInput = {
  /** Data in JSON format. It will be validated with JSON schema of Polaris Insights Data format. */
  data?: Maybe<Scalars['JSON']>;
  deleteProperties?: Maybe<Array<Scalars['String']>>;
  /**
   * The client can specify either a specific snippet id, or an
   * oauthClientId.  In the latter case, we will create a snippet on
   * this data point (nee insight) if one doesn't exist already, and it
   * is an error for there to be more than one snippet with the same
   * oauthClientId.
   */
  id?: Maybe<Scalars['ID']>;
  /** OauthClientId of CaaS app */
  oauthClientId?: Maybe<Scalars['String']>;
  setProperties?: Maybe<Scalars['JSON']>;
  /** Snippet url that is source of data */
  url?: Maybe<Scalars['String']>;
};

export type UpdatePolarisTermsConsentInput = {
  /** Cloud ID where the terms were displayed to the user */
  cloudID: Scalars['String'];
  /** The text accepted by user as terms of service */
  displayedText: Scalars['String'];
  /** Country code for the user locale */
  locale: Scalars['String'];
  /** Has the user granted general marketing consent */
  marketingConsent: Scalars['Boolean'];
  /** URL visited by user when terms of service were accepted */
  url: Scalars['URL'];
};

export type UpdatePolarisTermsConsentPayload = Payload & {
  __typename?: 'UpdatePolarisTermsConsentPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisViewInput = {
  /**  the name of the view */
  description?: Maybe<Scalars['JSON']>;
  /**  table column sizes per field */
  fields?: Maybe<Array<Scalars['ID']>>;
  /**  a field to sort by */
  filter?: Maybe<Array<PolarisViewFilterInput>>;
  /**  the table columns list of fields (table viz) or fields to show */
  groupBy?: Maybe<Scalars['ID']>;
  /**  what field to group by (board viz) */
  groupValues?: Maybe<Array<PolarisGroupValueInput>>;
  /**  view filter congfiguration */
  hidden?: Maybe<Array<Scalars['ID']>>;
  /**  description of the view */
  jql?: Maybe<Scalars['String']>;
  lastCommentsViewedTimestamp?: Maybe<Scalars['String']>;
  /**  fields that are included in view but hidden */
  lastViewedTimestamp?: Maybe<Scalars['String']>;
  /**  view to update, if this is an UPDATE operation */
  name?: Maybe<Scalars['String']>;
  /**  the field controlling the ordinate (y coordinate) */
  sort?: Maybe<Array<PolarisSortFieldInput>>;
  /**  just the user filtering part of the JQL */
  tableColumnSizes?: Maybe<Array<PolarisViewTableColumnSizeInput>>;
  /**  the JQL (sets filter and sorting) */
  userJql?: Maybe<Scalars['String']>;
  /**  what are the (ordered) grouping values */
  verticalGroupBy?: Maybe<Scalars['ID']>;
  /**  what field to vertical group by (board viz) */
  verticalGroupValues?: Maybe<Array<PolarisGroupValueInput>>;
  view?: Maybe<Scalars['ID']>;
  /**  what are the (ordered) vertical grouping values */
  x?: Maybe<Scalars['ID']>;
  /**  the field controlling the abcissa (x coordinate) */
  y?: Maybe<Scalars['ID']>;
};

export type UpdatePolarisViewPayload = Payload & {
  __typename?: 'UpdatePolarisViewPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisView>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisViewRankInput = {
  container?: Maybe<Scalars['ID']>;
  /**  new container if needed */
  rank: Scalars['Int'];
};

export type UpdatePolarisViewRankV2Payload = Payload & {
  __typename?: 'UpdatePolarisViewRankV2Payload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisViewSet>;
  success: Scalars['Boolean'];
};

export type UpdatePolarisViewSetInput = {
  name?: Maybe<Scalars['String']>;
  viewSet: Scalars['ID'];
};

export type UpdatePolarisViewSetPayload = Payload & {
  __typename?: 'UpdatePolarisViewSetPayload';
  errors?: Maybe<Array<MutationError>>;
  node?: Maybe<PolarisViewSet>;
  success: Scalars['Boolean'];
};

/**
 * There are 3 types of accounts :
 *
 * * AtlassianAccountUser
 * * this represents a real person that has an account in a wide range of Atlassian products
 *
 * * CustomerUser
 * * This represents a real person who is a customer of an organisation who uses an
 * Atlassian product to provide service to their customers.
 * Currently, this isused within Jira Service Desk for external service desks.
 *
 * * AppUser
 * * this does not represent a real person but rather the identity that backs an installed application
 */
export type User = {
  /** The account ID for the user. */
  accountId: Scalars['ID'];
  /** The lifecycle status of the account */
  accountStatus: AccountStatus;
  /**
   * The display name of the user. This should be used when rendering a user textually within content.
   * If the user has restricted visibility of their name, their nickname will be
   * displayed as a substitute value.
   */
  name: Scalars['String'];
  /**
   * The absolute URI (RFC3986) to the avatar name of the user. This should be used
   * when rendering a user graphically within content.
   * If the user has restricted visibility of their avatar or has not set
   * an avatar, an alternative URI will be provided as a substitute value.
   */
  picture: Scalars['URL'];
};

export type UserAuthTokenForExtensionInput = {
  extensionId: Scalars['ID'];
};

export type UserAuthTokenForExtensionResponse = Payload & {
  __typename?: 'UserAuthTokenForExtensionResponse';
  authToken?: Maybe<AuthToken>;
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type UserConsentExtension = {
  __typename?: 'UserConsentExtension';
  appEnvironmentVersion: UserConsentExtensionAppEnvironmentVersion;
  consentedAt: Scalars['DateTime'];
  user: UserConsentExtensionUser;
};

export type UserConsentExtensionAppEnvironmentVersion = {
  __typename?: 'UserConsentExtensionAppEnvironmentVersion';
  id: Scalars['ID'];
};

export type UserConsentExtensionUser = {
  __typename?: 'UserConsentExtensionUser';
  aaid: Scalars['ID'];
};

export type UserGrant = {
  __typename?: 'UserGrant';
  accountId: Scalars['ID'];
  appDetails?: Maybe<UserGrantAppDetails>;
  appId: Scalars['ID'];
  id: Scalars['ID'];
  oauthClientId: Scalars['ID'];
  scopes: Array<Maybe<AppHostServiceScope>>;
};

export type UserGrantAppDetails = {
  __typename?: 'UserGrantAppDetails';
  avatarUrl?: Maybe<Scalars['String']>;
  contactLink?: Maybe<Scalars['String']>;
  description: Scalars['String'];
  name: Scalars['String'];
  privacyPolicyLink?: Maybe<Scalars['String']>;
  termsOfServiceLink?: Maybe<Scalars['String']>;
  vendorName?: Maybe<Scalars['String']>;
};

export type UserGrantConnection = {
  __typename?: 'UserGrantConnection';
  edges?: Maybe<Array<Maybe<UserGrantEdge>>>;
  nodes?: Maybe<Array<Maybe<UserGrant>>>;
  pageInfo: UserGrantPageInfo;
};

export type UserGrantEdge = {
  __typename?: 'UserGrantEdge';
  cursor: Scalars['String'];
  node?: Maybe<UserGrant>;
};

export type UserGrantPageInfo = {
  __typename?: 'UserGrantPageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
};

export type WatchMarketplaceAppPayload = Payload & {
  __typename?: 'WatchMarketplaceAppPayload';
  errors?: Maybe<Array<MutationError>>;
  success: Scalars['Boolean'];
};

export type WebTriggerUrl = Node & {
  __typename?: 'WebTriggerUrl';
  appId: Scalars['ID'];
  contextId: Scalars['ID'];
  envId: Scalars['ID'];
  extensionId: Scalars['ID'];
  id: Scalars['ID'];
  /** Product extracted from the context id (e.g. jira, confulence). Only populated if context id is a valid cloud context. */
  product?: Maybe<Scalars['String']>;
  /** The tenant context for the cloud id. Only populated if context id is a valid cloud context. */
  tenantContext?: Maybe<TenantContext>;
  triggerKey: Scalars['String'];
  url: Scalars['URL'];
};

export type WebTriggerUrlInput = {
  /** Id of the application */
  appId: Scalars['ID'];
  /**
   * context in which function should run, usually a site context.
   * E.g.: ari:cloud:jira::site/{siteId}
   */
  contextId: Scalars['ID'];
  /** Environment id of the application */
  envId: Scalars['ID'];
  /** Web trigger module key */
  triggerKey: Scalars['String'];
};

export type AppListViewFragment = { __typename?: 'App' } & Pick<
  App,
  'id' | 'name' | 'avatarFileId' | 'vendorName' | 'description'
>;

export type CommonMutationErrorFragment = {
  __typename?: 'MutationError';
} & Pick<MutationError, 'message'> & {
    extensions?: Maybe<
      | ({ __typename?: 'GenericMutationErrorExtension' } & Pick<
          GenericMutationErrorExtension,
          'errorType'
        >)
      | ({ __typename?: 'InvokeExtensionPayloadErrorExtension' } & Pick<
          InvokeExtensionPayloadErrorExtension,
          'errorType'
        >)
    >;
  };

export type CommonQueryErrorFragment = { __typename?: 'QueryError' } & Pick<
  QueryError,
  'message'
> & {
    extensions?: Maybe<
      Array<
        { __typename?: 'GenericQueryErrorExtension' } & Pick<
          GenericQueryErrorExtension,
          'statusCode' | 'errorType'
        >
      >
    >;
  };

export type CompassComponentAnnouncementFragment = {
  __typename?: 'CompassAnnouncement';
} & Pick<CompassAnnouncement, 'id' | 'title' | 'description' | 'targetDate'> & {
    acknowledgements?: Maybe<
      Array<
        { __typename?: 'CompassAnnouncementAcknowledgement' } & Pick<
          CompassAnnouncementAcknowledgement,
          'hasAcknowledged'
        > & {
            component?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'id' | 'name'
              >
            >;
          }
      >
    >;
  };

export type CompassComponentAnnouncementsFragment = {
  __typename?: 'CompassComponent';
} & {
  announcements?: Maybe<
    Array<
      {
        __typename?: 'CompassAnnouncement';
      } & CompassComponentAnnouncementFragment
    >
  >;
} & CompassComponentCoreFragment;

export type CompassComponentCommonDetailFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'id' | 'type' | 'name'> & {
    dataManager?: Maybe<
      { __typename?: 'CompassComponentDataManager' } & Pick<
        CompassComponentDataManager,
        'ecosystemAppId'
      >
    >;
  } & CompassComponentCoreFragment;

export type CompassComponentCoreFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'id' | '_isOptimistic' | '_isDeleted'>;

export type CompassComponentDetailViewFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'name' | 'type' | 'description' | 'ownerId'> & {
    links?: Maybe<
      Array<{ __typename?: 'CompassLink' } & CompassComponentLinkCommonFragment>
    >;
    fields?: Maybe<
      Array<
        { __typename?: 'CompassEnumField' } & Pick<
          CompassEnumField,
          'value'
        > & {
            definition?: Maybe<
              { __typename?: 'CompassFieldDefinition' } & Pick<
                CompassFieldDefinition,
                'id'
              >
            >;
          }
      >
    >;
    dataManager?: Maybe<
      { __typename?: 'CompassComponentDataManager' } & Pick<
        CompassComponentDataManager,
        'ecosystemAppId' | 'externalSourceURL'
      > & {
          lastSyncEvent?: Maybe<
            { __typename?: 'ComponentSyncEvent' } & Pick<
              ComponentSyncEvent,
              'time' | 'status' | 'lastSyncErrors'
            >
          >;
        }
    >;
    relationships?: Maybe<
      | ({ __typename?: 'CompassRelationshipConnection' } & {
          nodes?: Maybe<
            Array<
              { __typename?: 'CompassRelationship' } & Pick<
                CompassRelationship,
                'type'
              > & {
                  startNode?: Maybe<
                    { __typename?: 'CompassComponent' } & Pick<
                      CompassComponent,
                      'id'
                    >
                  >;
                  endNode?: Maybe<
                    { __typename?: 'CompassComponent' } & Pick<
                      CompassComponent,
                      'id'
                    >
                  >;
                }
            >
          >;
        })
      | { __typename?: 'QueryError' }
    >;
    events?: Maybe<
      | ({ __typename?: 'CompassEventConnection' } & {
          nodes?: Maybe<
            Array<
              { __typename?: 'CompassDeploymentEvent' } & Pick<
                CompassDeploymentEvent,
                'url' | 'lastUpdated' | 'displayName'
              > & {
                  environment?: Maybe<
                    { __typename?: 'CompassDeploymentEventEnvironment' } & Pick<
                      CompassDeploymentEventEnvironment,
                      'displayName'
                    >
                  >;
                }
            >
          >;
        })
      | { __typename?: 'QueryError' }
    >;
  } & CompassComponentCoreFragment &
  CompassComponentLabelsFragment;

export type CompassComponentInRelationshipViewFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'id' | 'type' | 'name'> &
  CompassComponentCoreFragment;

export type CompassComponentLabelsFragment = {
  __typename?: 'CompassComponent';
} & {
  labels?: Maybe<
    Array<
      { __typename?: 'CompassComponentLabel' } & Pick<
        CompassComponentLabel,
        'name'
      >
    >
  >;
} & CompassComponentCoreFragment;

export type CompassComponentLinkCommonFragment = {
  __typename?: 'CompassLink';
} & Pick<CompassLink, 'id' | 'name' | 'url' | 'type' | '_isDeleted'>;

export type CompassComponentListViewFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'name' | 'type'> &
  CompassComponentCoreFragment;

export type CompassComponentOverviewFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'id' | 'name' | 'type'>;

export type CompassRelationshipCoreFragment = {
  __typename?: 'CompassRelationship';
} & Pick<CompassRelationship, 'type' | '_isDeleted'> & {
    startNode?: Maybe<
      { __typename?: 'CompassComponent' } & Pick<CompassComponent, 'id'>
    >;
    endNode?: Maybe<
      { __typename?: 'CompassComponent' } & Pick<CompassComponent, 'id'>
    >;
  };

export type CompassRelationshipInRelationshipViewFragment = {
  __typename?: 'CompassRelationship';
} & {
  startNode?: Maybe<
    {
      __typename?: 'CompassComponent';
    } & CompassComponentInRelationshipViewFragment
  >;
  endNode?: Maybe<
    {
      __typename?: 'CompassComponent';
    } & CompassComponentInRelationshipViewFragment
  >;
} & CompassRelationshipCoreFragment;

export type CompassScorecardCoreFragment = {
  __typename?: 'CompassScorecard';
} & Pick<CompassScorecard, 'id' | '_isOptimistic' | '_isDeleted'>;

export type CompassSearchComponentFragment = {
  __typename?: 'CompassComponent';
} & Pick<CompassComponent, 'name' | 'description' | 'type' | 'ownerId'> &
  CompassComponentCoreFragment;

export type CompassSearchComponentNodeFragment = {
  __typename?: 'CompassSearchComponentResult';
} & Pick<CompassSearchComponentResult, 'link'> & {
    component?: Maybe<
      { __typename?: 'CompassComponent' } & CompassSearchComponentFragment
    >;
  };

export type CompassTeamCheckinCoreFragment = {
  __typename?: 'CompassTeamCheckin';
} & Pick<CompassTeamCheckin, 'id' | '_isOptimistic' | '_isDeleted'>;

export type AcknowledgeAnnouncementMutationVariables = Exact<{
  input: CompassAcknowledgeAnnouncementInput;
}>;

export type AcknowledgeAnnouncementMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      acknowledgeAnnouncement?: Maybe<
        { __typename?: 'CompassAcknowledgeAnnouncementPayload' } & Pick<
          CompassAcknowledgeAnnouncementPayload,
          'success'
        > & {
            acknowledgement?: Maybe<
              { __typename?: 'CompassAnnouncementAcknowledgement' } & Pick<
                CompassAnnouncementAcknowledgement,
                'hasAcknowledged'
              > & {
                  component?: Maybe<
                    {
                      __typename?: 'CompassComponent';
                    } & CompassComponentCoreFragment
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type AddComponentLabelsMutationVariables = Exact<{
  input: AddCompassComponentLabelsInput;
}>;

export type AddComponentLabelsMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      addComponentLabels?: Maybe<
        { __typename?: 'AddCompassComponentLabelsPayload' } & Pick<
          AddCompassComponentLabelsPayload,
          'success'
        > & {
            addedLabels?: Maybe<
              Array<
                { __typename?: 'CompassComponentLabel' } & Pick<
                  CompassComponentLabel,
                  'name'
                >
              >
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type ApplyScorecardToComponentMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  componentId: Scalars['ID'];
}>;

export type ApplyScorecardToComponentMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      applyScorecardToComponent?: Maybe<
        { __typename?: 'ApplyCompassScorecardToComponentPayload' } & Pick<
          ApplyCompassScorecardToComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateAnnouncementMutationVariables = Exact<{
  input: CompassCreateAnnouncementInput;
}>;

export type CreateAnnouncementMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createAnnouncement?: Maybe<
        { __typename?: 'CompassCreateAnnouncementPayload' } & Pick<
          CompassCreateAnnouncementPayload,
          'success'
        > & {
            createdAnnouncement?: Maybe<
              { __typename?: 'CompassAnnouncement' } & Pick<
                CompassAnnouncement,
                'id' | 'title' | 'description' | 'targetDate'
              > & {
                  acknowledgements?: Maybe<
                    Array<
                      {
                        __typename?: 'CompassAnnouncementAcknowledgement';
                      } & Pick<
                        CompassAnnouncementAcknowledgement,
                        'hasAcknowledged'
                      > & {
                          component?: Maybe<
                            { __typename?: 'CompassComponent' } & Pick<
                              CompassComponent,
                              'id' | 'name'
                            >
                          >;
                        }
                    >
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateComponentMutationVariables = Exact<{
  cloudId: Scalars['ID'];
  input: CreateCompassComponentInput;
}>;

export type CreateComponentMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createComponent?: Maybe<
        { __typename?: 'CreateCompassComponentPayload' } & Pick<
          CreateCompassComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateComponentLinkMutationVariables = Exact<{
  input: CreateCompassComponentLinkInput;
}>;

export type CreateComponentLinkMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createComponentLink?: Maybe<
        { __typename?: 'CreateCompassComponentLinkPayload' } & Pick<
          CreateCompassComponentLinkPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'id'
              > & {
                  links?: Maybe<
                    Array<
                      { __typename?: 'CompassLink' } & Pick<
                        CompassLink,
                        'id' | 'name' | 'type' | 'url'
                      >
                    >
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & Pick<
                  MutationError,
                  'message'
                > & {
                    extensions?: Maybe<
                      | ({
                          __typename?: 'GenericMutationErrorExtension';
                        } & Pick<GenericMutationErrorExtension, 'errorType'>)
                      | ({
                          __typename?: 'InvokeExtensionPayloadErrorExtension';
                        } & Pick<
                          InvokeExtensionPayloadErrorExtension,
                          'errorType'
                        >)
                    >;
                  }
              >
            >;
          }
      >;
    }
  >;
};

export type CreateRelationshipMutationVariables = Exact<{
  input: CreateCompassRelationshipInput;
}>;

export type CreateRelationshipMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createRelationship?: Maybe<
        { __typename?: 'CreateCompassRelationshipPayload' } & Pick<
          CreateCompassRelationshipPayload,
          'success'
        > & {
            createdCompassRelationship?: Maybe<
              { __typename?: 'CompassRelationship' } & Pick<
                CompassRelationship,
                'type'
              > & {
                  startNode?: Maybe<
                    { __typename?: 'CompassComponent' } & Pick<
                      CompassComponent,
                      'id' | 'name' | 'type'
                    >
                  >;
                  endNode?: Maybe<
                    { __typename?: 'CompassComponent' } & Pick<
                      CompassComponent,
                      'id' | 'name' | 'type'
                    >
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateScorecardMutationVariables = Exact<{
  cloudId: Scalars['ID'];
  input: CreateCompassScorecardInput;
}>;

export type CreateScorecardMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createScorecard?: Maybe<
        { __typename?: 'CreateCompassScorecardPayload' } & Pick<
          CreateCompassScorecardPayload,
          'success'
        > & {
            scorecardDetails?: Maybe<
              { __typename?: 'CompassScorecard' } & CompassScorecardCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateScorecardCriteriasMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  input: CreateCompassScorecardCriteriasInput;
}>;

export type CreateScorecardCriteriasMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createScorecardCriterias?: Maybe<
        { __typename?: 'CreateCompassScorecardCriteriasPayload' } & Pick<
          CreateCompassScorecardCriteriasPayload,
          'success'
        > & {
            scorecard?: Maybe<
              { __typename?: 'CompassScorecard' } & CompassScorecardCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type CreateTeamCheckinMutationVariables = Exact<{
  input: CompassCreateTeamCheckinInput;
}>;

export type CreateTeamCheckinMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      createTeamCheckin?: Maybe<
        { __typename?: 'CompassCreateTeamCheckinPayload' } & Pick<
          CompassCreateTeamCheckinPayload,
          'success'
        > & {
            createdTeamCheckin?: Maybe<
              { __typename?: 'CompassTeamCheckin' } & Pick<
                CompassTeamCheckin,
                | 'teamId'
                | 'id'
                | 'mood'
                | 'response1'
                | 'response2'
                | 'response3'
              > & {
                  changeMetadata: {
                    __typename?: 'CompassChangeMetadata';
                  } & Pick<
                    CompassChangeMetadata,
                    'createdAt' | 'lastUserModificationAt'
                  >;
                } & CompassTeamCheckinCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteAnnouncementMutationVariables = Exact<{
  input: CompassDeleteAnnouncementInput;
}>;

export type DeleteAnnouncementMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteAnnouncement?: Maybe<
        { __typename?: 'CompassDeleteAnnouncementPayload' } & Pick<
          CompassDeleteAnnouncementPayload,
          'deletedAnnouncementId' | 'success'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteComponentMutationVariables = Exact<{
  input: DeleteCompassComponentInput;
}>;

export type DeleteComponentMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteComponent?: Maybe<
        { __typename?: 'DeleteCompassComponentPayload' } & Pick<
          DeleteCompassComponentPayload,
          'deletedComponentId' | 'success' | '_isOptimistic'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteComponentLinkMutationVariables = Exact<{
  input: DeleteCompassComponentLinkInput;
}>;

export type DeleteComponentLinkMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteComponentLink?: Maybe<
        { __typename?: 'DeleteCompassComponentLinkPayload' } & Pick<
          DeleteCompassComponentLinkPayload,
          'success' | 'deletedCompassLinkId'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteRelationshipMutationVariables = Exact<{
  input: DeleteCompassRelationshipInput;
}>;

export type DeleteRelationshipMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteRelationship?: Maybe<
        { __typename?: 'DeleteCompassRelationshipPayload' } & Pick<
          DeleteCompassRelationshipPayload,
          'success'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteScorecardMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
}>;

export type DeleteScorecardMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteScorecard?: Maybe<
        { __typename?: 'DeleteCompassScorecardPayload' } & Pick<
          DeleteCompassScorecardPayload,
          'success' | 'scorecardId'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteScorecardCriteriasMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  input: DeleteCompassScorecardCriteriasInput;
}>;

export type DeleteScorecardCriteriasMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteScorecardCriterias?: Maybe<
        { __typename?: 'DeleteCompassScorecardCriteriasPayload' } & Pick<
          DeleteCompassScorecardCriteriasPayload,
          'success'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type DeleteTeamCheckinMutationVariables = Exact<{
  input: CompassDeleteTeamCheckinInput;
}>;

export type DeleteTeamCheckinMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      deleteTeamCheckin?: Maybe<
        { __typename?: 'CompassDeleteTeamCheckinPayload' } & Pick<
          CompassDeleteTeamCheckinPayload,
          'success' | 'deletedTeamCheckinId'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type InstallForgeAppMutationVariables = Exact<{
  input: AppInstallationInput;
}>;

export type InstallForgeAppMutation = { __typename?: 'Mutation' } & {
  installApp?: Maybe<
    { __typename?: 'AppInstallationResponse' } & Pick<
      AppInstallationResponse,
      'success' | 'installationId' | 'taskId'
    > & {
        errors?: Maybe<
          Array<
            { __typename?: 'MutationError' } & Pick<MutationError, 'message'>
          >
        >;
      }
  >;
};

export type RemoveComponentLabelsMutationVariables = Exact<{
  input: RemoveCompassComponentLabelsInput;
}>;

export type RemoveComponentLabelsMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      removeComponentLabels?: Maybe<
        { __typename?: 'RemoveCompassComponentLabelsPayload' } & Pick<
          RemoveCompassComponentLabelsPayload,
          'success' | 'removedLabelNames'
        > & {
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type RemoveScorecardFromComponentMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  componentId: Scalars['ID'];
}>;

export type RemoveScorecardFromComponentMutation = {
  __typename?: 'Mutation';
} & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      removeScorecardFromComponent?: Maybe<
        { __typename?: 'RemoveCompassScorecardFromComponentPayload' } & Pick<
          RemoveCompassScorecardFromComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UninstallForgeAppMutationVariables = Exact<{
  input: AppUninstallationInput;
}>;

export type UninstallForgeAppMutation = { __typename?: 'Mutation' } & {
  uninstallApp?: Maybe<
    { __typename?: 'AppUninstallationResponse' } & Pick<
      AppUninstallationResponse,
      'success' | 'taskId'
    > & {
        errors?: Maybe<
          Array<
            { __typename?: 'MutationError' } & Pick<MutationError, 'message'>
          >
        >;
      }
  >;
};

export type UpdateAnnouncementMutationVariables = Exact<{
  input: CompassUpdateAnnouncementInput;
}>;

export type UpdateAnnouncementMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateAnnouncement?: Maybe<
        { __typename?: 'CompassUpdateAnnouncementPayload' } & Pick<
          CompassUpdateAnnouncementPayload,
          'success'
        > & {
            updatedAnnouncement?: Maybe<
              { __typename?: 'CompassAnnouncement' } & Pick<
                CompassAnnouncement,
                'id' | 'title' | 'description' | 'targetDate'
              > & {
                  acknowledgements?: Maybe<
                    Array<
                      {
                        __typename?: 'CompassAnnouncementAcknowledgement';
                      } & Pick<
                        CompassAnnouncementAcknowledgement,
                        'hasAcknowledged'
                      > & {
                          component?: Maybe<
                            { __typename?: 'CompassComponent' } & Pick<
                              CompassComponent,
                              'id' | 'name'
                            >
                          >;
                        }
                    >
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateComponentDescriptionMutationVariables = Exact<{
  input: UpdateCompassComponentInput;
}>;

export type UpdateComponentDescriptionMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateComponent?: Maybe<
        { __typename?: 'UpdateCompassComponentPayload' } & Pick<
          UpdateCompassComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'description'
              > &
                CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateComponentFieldTierMutationVariables = Exact<{
  input: UpdateCompassComponentInput;
}>;

export type UpdateComponentFieldTierMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateComponent?: Maybe<
        { __typename?: 'UpdateCompassComponentPayload' } & Pick<
          UpdateCompassComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & {
                fields?: Maybe<
                  Array<
                    { __typename?: 'CompassEnumField' } & Pick<
                      CompassEnumField,
                      'value'
                    > & {
                        definition?: Maybe<
                          { __typename?: 'CompassFieldDefinition' } & Pick<
                            CompassFieldDefinition,
                            'id'
                          >
                        >;
                      }
                  >
                >;
              } & CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateComponentLinkMutationVariables = Exact<{
  input: UpdateCompassComponentLinkInput;
}>;

export type UpdateComponentLinkMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateComponentLink?: Maybe<
        { __typename?: 'UpdateCompassComponentLinkPayload' } & Pick<
          UpdateCompassComponentLinkPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'id'
              > & {
                  links?: Maybe<
                    Array<
                      { __typename?: 'CompassLink' } & Pick<
                        CompassLink,
                        'id' | 'name' | 'type' | 'url'
                      >
                    >
                  >;
                }
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & Pick<
                  MutationError,
                  'message'
                > & {
                    extensions?: Maybe<
                      | ({
                          __typename?: 'GenericMutationErrorExtension';
                        } & Pick<GenericMutationErrorExtension, 'errorType'>)
                      | ({
                          __typename?: 'InvokeExtensionPayloadErrorExtension';
                        } & Pick<
                          InvokeExtensionPayloadErrorExtension,
                          'errorType'
                        >)
                    >;
                  }
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateComponentNameMutationVariables = Exact<{
  input: UpdateCompassComponentInput;
}>;

export type UpdateComponentNameMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateComponent?: Maybe<
        { __typename?: 'UpdateCompassComponentPayload' } & Pick<
          UpdateCompassComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'name'
              > &
                CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateComponentOwnerMutationVariables = Exact<{
  input: UpdateCompassComponentInput;
}>;

export type UpdateComponentOwnerMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateComponent?: Maybe<
        { __typename?: 'UpdateCompassComponentPayload' } & Pick<
          UpdateCompassComponentPayload,
          'success'
        > & {
            componentDetails?: Maybe<
              { __typename?: 'CompassComponent' } & Pick<
                CompassComponent,
                'ownerId'
              > &
                CompassComponentCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateScorecardMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  input: UpdateCompassScorecardInput;
}>;

export type UpdateScorecardMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateScorecard?: Maybe<
        { __typename?: 'UpdateCompassScorecardPayload' } & Pick<
          UpdateCompassScorecardPayload,
          'success'
        > & {
            scorecardDetails?: Maybe<
              { __typename?: 'CompassScorecard' } & Pick<
                CompassScorecard,
                'name' | 'description' | 'importance' | 'componentType'
              > & {
                  owner?: Maybe<
                    | ({ __typename?: 'AppUser' } & Pick<AppUser, 'name'>)
                    | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                        AtlassianAccountUser,
                        'name'
                      >)
                    | ({ __typename?: 'CustomerUser' } & Pick<
                        CustomerUser,
                        'name'
                      >)
                  >;
                } & CompassScorecardCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateScorecardCriteriaMutationVariables = Exact<{
  scorecardId: Scalars['ID'];
  input: UpdateCompassScorecardCriteriasInput;
}>;

export type UpdateScorecardCriteriaMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateScorecardCriterias?: Maybe<
        { __typename?: 'UpdateCompassScorecardCriteriasPayload' } & Pick<
          UpdateCompassScorecardCriteriasPayload,
          'success'
        > & {
            scorecard?: Maybe<
              { __typename?: 'CompassScorecard' } & CompassScorecardCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type UpdateTeamCheckinMutationVariables = Exact<{
  input: CompassUpdateTeamCheckinInput;
}>;

export type UpdateTeamCheckinMutation = { __typename?: 'Mutation' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogMutationApi' } & {
      updateTeamCheckin?: Maybe<
        { __typename?: 'CompassUpdateTeamCheckinPayload' } & Pick<
          CompassUpdateTeamCheckinPayload,
          'success'
        > & {
            updatedTeamCheckin?: Maybe<
              { __typename: 'CompassTeamCheckin' } & Pick<
                CompassTeamCheckin,
                | 'teamId'
                | 'id'
                | 'mood'
                | 'response1'
                | 'response2'
                | 'response3'
              > & {
                  changeMetadata: {
                    __typename?: 'CompassChangeMetadata';
                  } & Pick<
                    CompassChangeMetadata,
                    'createdAt' | 'lastUserModificationAt'
                  >;
                } & CompassTeamCheckinCoreFragment
            >;
            errors?: Maybe<
              Array<
                { __typename?: 'MutationError' } & CommonMutationErrorFragment
              >
            >;
          }
      >;
    }
  >;
};

export type GetComponentAnnouncementsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type GetComponentAnnouncementsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & Pick<CompassComponent, 'id'> &
            CompassComponentAnnouncementsFragment)
        | { __typename: 'QueryError' }
      >;
    }
  >;
};

export type GetComponentApplicableScorecardsQueryVariables = Exact<{
  componentId: Scalars['ID'];
}>;

export type GetComponentApplicableScorecardsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & {
            applicableScorecards?: Maybe<
              Array<
                { __typename?: 'CompassScorecard' } & Pick<
                  CompassScorecard,
                  'id' | 'name' | 'description' | 'componentType' | 'importance'
                >
              >
            >;
          } & CompassComponentCoreFragment)
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetComponentDependencyAnnouncementsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type GetComponentDependencyAnnouncementsQuery = {
  __typename?: 'Query';
} & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & Pick<CompassComponent, 'id'> & {
              relationships?: Maybe<
                | ({ __typename: 'CompassRelationshipConnection' } & {
                    nodes?: Maybe<
                      Array<
                        { __typename?: 'CompassRelationship' } & Pick<
                          CompassRelationship,
                          'type'
                        > & {
                            startNode?: Maybe<
                              { __typename?: 'CompassComponent' } & Pick<
                                CompassComponent,
                                'id'
                              >
                            >;
                            endNode?: Maybe<
                              { __typename?: 'CompassComponent' } & Pick<
                                CompassComponent,
                                'id' | 'name' | 'type'
                              > & {
                                  announcements?: Maybe<
                                    Array<
                                      {
                                        __typename?: 'CompassAnnouncement';
                                      } & Pick<
                                        CompassAnnouncement,
                                        | 'id'
                                        | 'title'
                                        | 'description'
                                        | 'targetDate'
                                      > & {
                                          component?: Maybe<
                                            {
                                              __typename?: 'CompassComponent';
                                            } & Pick<
                                              CompassComponent,
                                              'id' | 'name' | 'type'
                                            >
                                          >;
                                          acknowledgements?: Maybe<
                                            Array<
                                              {
                                                __typename?: 'CompassAnnouncementAcknowledgement';
                                              } & Pick<
                                                CompassAnnouncementAcknowledgement,
                                                'hasAcknowledged'
                                              > & {
                                                  component?: Maybe<
                                                    {
                                                      __typename?: 'CompassComponent';
                                                    } & Pick<
                                                      CompassComponent,
                                                      'id'
                                                    >
                                                  >;
                                                }
                                            >
                                          >;
                                        }
                                    >
                                  >;
                                }
                            >;
                          }
                      >
                    >;
                  })
                | { __typename: 'QueryError' }
              >;
            })
        | { __typename: 'QueryError' }
      >;
    }
  >;
};

export type GetComponentDetailsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type GetComponentDetailsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({
            __typename: 'CompassComponent';
          } & CompassComponentDetailViewFragment)
        | ({ __typename: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type GetComponentEventsQueryVariables = Exact<{
  id: Scalars['ID'];
  query?: Maybe<CompassEventsQuery>;
}>;

export type GetComponentEventsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & Pick<CompassComponent, 'id'> & {
              events?: Maybe<
                | ({ __typename: 'CompassEventConnection' } & {
                    nodes?: Maybe<
                      Array<
                        { __typename?: 'CompassDeploymentEvent' } & Pick<
                          CompassDeploymentEvent,
                          | 'eventType'
                          | 'lastUpdated'
                          | 'displayName'
                          | 'state'
                          | 'description'
                          | 'url'
                        > & {
                            environment?: Maybe<
                              {
                                __typename?: 'CompassDeploymentEventEnvironment';
                              } & Pick<
                                CompassDeploymentEventEnvironment,
                                'displayName' | 'category'
                              >
                            >;
                          }
                      >
                    >;
                  })
                | { __typename: 'QueryError' }
              >;
            })
        | ({ __typename: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type GetComponentLinksQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type GetComponentLinksQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & Pick<CompassComponent, 'id'> & {
              links?: Maybe<
                Array<
                  { __typename?: 'CompassLink' } & Pick<
                    CompassLink,
                    'id' | 'name' | 'url' | 'type'
                  >
                >
              >;
            })
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetComponentRelationshipsQueryVariables = Exact<{
  id: Scalars['ID'];
  outwardRelationshipsQuery: CompassRelationshipQuery;
  inwardRelationshipsQuery: CompassRelationshipQuery;
}>;

export type GetComponentRelationshipsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & {
            dataManager?: Maybe<
              { __typename?: 'CompassComponentDataManager' } & Pick<
                CompassComponentDataManager,
                'ecosystemAppId' | 'externalSourceURL'
              >
            >;
            outwardRelationships?: Maybe<
              | ({ __typename: 'CompassRelationshipConnection' } & {
                  nodes?: Maybe<
                    Array<
                      {
                        __typename?: 'CompassRelationship';
                      } & CompassRelationshipInRelationshipViewFragment
                    >
                  >;
                })
              | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
                    extensions?: Maybe<
                      Array<
                        { __typename?: 'GenericQueryErrorExtension' } & Pick<
                          GenericQueryErrorExtension,
                          'statusCode' | 'errorType'
                        >
                      >
                    >;
                  })
            >;
            inwardRelationships?: Maybe<
              | ({ __typename: 'CompassRelationshipConnection' } & {
                  nodes?: Maybe<
                    Array<
                      {
                        __typename?: 'CompassRelationship';
                      } & CompassRelationshipInRelationshipViewFragment
                    >
                  >;
                })
              | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
                    extensions?: Maybe<
                      Array<
                        { __typename?: 'GenericQueryErrorExtension' } & Pick<
                          GenericQueryErrorExtension,
                          'statusCode' | 'errorType'
                        >
                      >
                    >;
                  })
            >;
          } & CompassComponentCoreFragment)
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetComponentRelationshipsOldQueryVariables = Exact<{
  id: Scalars['ID'];
  query: CompassRelationshipQuery;
}>;

export type GetComponentRelationshipsOldQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & {
            dataManager?: Maybe<
              { __typename?: 'CompassComponentDataManager' } & Pick<
                CompassComponentDataManager,
                'ecosystemAppId' | 'externalSourceURL'
              >
            >;
            relationships?: Maybe<
              | ({ __typename: 'CompassRelationshipConnection' } & {
                  nodes?: Maybe<
                    Array<
                      {
                        __typename?: 'CompassRelationship';
                      } & CompassRelationshipInRelationshipViewFragment
                    >
                  >;
                })
              | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
                    extensions?: Maybe<
                      Array<
                        { __typename?: 'GenericQueryErrorExtension' } & Pick<
                          GenericQueryErrorExtension,
                          'statusCode' | 'errorType'
                        >
                      >
                    >;
                  })
            >;
          } & CompassComponentCoreFragment)
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetComponentScorecardWithScoresByIdQueryVariables = Exact<{
  componentId: Scalars['ID'];
  scorecardId: Scalars['ID'];
}>;

export type GetComponentScorecardWithScoresByIdQuery = {
  __typename?: 'Query';
} & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      scorecard?: Maybe<
        | ({ __typename: 'CompassScorecard' } & Pick<
            CompassScorecard,
            'id' | 'name' | 'description' | 'componentType' | 'importance'
          > & {
              owner?: Maybe<
                | ({ __typename?: 'AppUser' } & Pick<
                    AppUser,
                    'name' | 'picture'
                  >)
                | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                    AtlassianAccountUser,
                    'name' | 'picture'
                  >)
                | ({ __typename?: 'CustomerUser' } & Pick<
                    CustomerUser,
                    'name' | 'picture'
                  >)
              >;
              scorecardScore?: Maybe<
                { __typename?: 'CompassScorecardScore' } & Pick<
                  CompassScorecardScore,
                  'totalScore' | 'maxTotalScore'
                >
              >;
              criterias?: Maybe<
                Array<
                  | ({
                      __typename: 'CompassHasDescriptionScorecardCriteria';
                    } & Pick<
                      CompassHasDescriptionScorecardCriteria,
                      'id' | 'weight'
                    > & {
                        scorecardCriteriaScore?: Maybe<
                          {
                            __typename?: 'CompassScorecardCriteriaScore';
                          } & Pick<
                            CompassScorecardCriteriaScore,
                            'score' | 'maxScore'
                          >
                        >;
                      })
                  | ({ __typename: 'CompassHasFieldScorecardCriteria' } & Pick<
                      CompassHasFieldScorecardCriteria,
                      'id' | 'weight'
                    > & {
                        fieldDefinition: {
                          __typename?: 'CompassFieldDefinition';
                        } & Pick<CompassFieldDefinition, 'id' | 'name'>;
                        scorecardCriteriaScore?: Maybe<
                          {
                            __typename?: 'CompassScorecardCriteriaScore';
                          } & Pick<
                            CompassScorecardCriteriaScore,
                            'score' | 'maxScore'
                          >
                        >;
                      })
                  | ({ __typename: 'CompassHasLinkScorecardCriteria' } & Pick<
                      CompassHasLinkScorecardCriteria,
                      'linkType' | 'id' | 'weight'
                    > & {
                        scorecardCriteriaScore?: Maybe<
                          {
                            __typename?: 'CompassScorecardCriteriaScore';
                          } & Pick<
                            CompassScorecardCriteriaScore,
                            'score' | 'maxScore'
                          >
                        >;
                      })
                  | ({ __typename: 'CompassHasOwnerScorecardCriteria' } & Pick<
                      CompassHasOwnerScorecardCriteria,
                      'id' | 'weight'
                    > & {
                        scorecardCriteriaScore?: Maybe<
                          {
                            __typename?: 'CompassScorecardCriteriaScore';
                          } & Pick<
                            CompassScorecardCriteriaScore,
                            'score' | 'maxScore'
                          >
                        >;
                      })
                >
              >;
            })
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetComponentScorecardsWithScoresQueryVariables = Exact<{
  componentId: Scalars['ID'];
}>;

export type GetComponentScorecardsWithScoresQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      component?: Maybe<
        | ({ __typename: 'CompassComponent' } & Pick<
            CompassComponent,
            'name'
          > & {
              scorecards?: Maybe<
                Array<
                  { __typename?: 'CompassScorecard' } & Pick<
                    CompassScorecard,
                    'id' | 'name' | 'componentType' | 'importance'
                  > & {
                      scorecardScore?: Maybe<
                        { __typename?: 'CompassScorecardScore' } & Pick<
                          CompassScorecardScore,
                          'totalScore' | 'maxTotalScore'
                        >
                      >;
                      criterias?: Maybe<
                        Array<
                          | ({
                              __typename: 'CompassHasDescriptionScorecardCriteria';
                            } & Pick<
                              CompassHasDescriptionScorecardCriteria,
                              'id' | 'weight'
                            > & {
                                scorecardCriteriaScore?: Maybe<
                                  {
                                    __typename?: 'CompassScorecardCriteriaScore';
                                  } & Pick<
                                    CompassScorecardCriteriaScore,
                                    'score' | 'maxScore'
                                  >
                                >;
                              })
                          | ({
                              __typename: 'CompassHasFieldScorecardCriteria';
                            } & Pick<
                              CompassHasFieldScorecardCriteria,
                              'id' | 'weight'
                            > & {
                                fieldDefinition: {
                                  __typename?: 'CompassFieldDefinition';
                                } & Pick<CompassFieldDefinition, 'id' | 'name'>;
                                scorecardCriteriaScore?: Maybe<
                                  {
                                    __typename?: 'CompassScorecardCriteriaScore';
                                  } & Pick<
                                    CompassScorecardCriteriaScore,
                                    'score' | 'maxScore'
                                  >
                                >;
                              })
                          | ({
                              __typename: 'CompassHasLinkScorecardCriteria';
                            } & Pick<
                              CompassHasLinkScorecardCriteria,
                              'linkType' | 'id' | 'weight'
                            > & {
                                scorecardCriteriaScore?: Maybe<
                                  {
                                    __typename?: 'CompassScorecardCriteriaScore';
                                  } & Pick<
                                    CompassScorecardCriteriaScore,
                                    'score' | 'maxScore'
                                  >
                                >;
                              })
                          | ({
                              __typename: 'CompassHasOwnerScorecardCriteria';
                            } & Pick<
                              CompassHasOwnerScorecardCriteria,
                              'id' | 'weight'
                            > & {
                                scorecardCriteriaScore?: Maybe<
                                  {
                                    __typename?: 'CompassScorecardCriteriaScore';
                                  } & Pick<
                                    CompassScorecardCriteriaScore,
                                    'score' | 'maxScore'
                                  >
                                >;
                              })
                        >
                      >;
                    }
                >
              >;
            } & CompassComponentCoreFragment)
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetFieldDefinitionsByComponentTypeQueryVariables = Exact<{
  cloudId: Scalars['ID'];
  type: CompassComponentType;
}>;

export type GetFieldDefinitionsByComponentTypeQuery = {
  __typename?: 'Query';
} & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      fieldDefinitionsByComponentType?: Maybe<
        | ({ __typename?: 'CompassFieldDefinitions' } & {
            definitions: Array<
              { __typename?: 'CompassFieldDefinition' } & Pick<
                CompassFieldDefinition,
                'id' | 'name' | 'type' | 'description'
              > & {
                  options: {
                    __typename?: 'CompassEnumFieldDefinitionOptions';
                  } & Pick<
                    CompassEnumFieldDefinitionOptions,
                    'values' | 'default'
                  >;
                }
            >;
          })
        | ({ __typename?: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type GetInstalledAppsQueryVariables = Exact<{
  contextId: Scalars['ID'];
}>;

export type GetInstalledAppsQuery = { __typename?: 'Query' } & {
  extensionContexts?: Maybe<
    Array<
      { __typename?: 'ExtensionContext' } & {
        extensionsByType: Array<
          { __typename?: 'Extension' } & Pick<
            Extension,
            | 'id'
            | 'properties'
            | 'environmentId'
            | 'environmentType'
            | 'type'
            | 'appVersion'
            | 'consentUrl'
            | 'installationId'
            | 'requiresUserConsent'
          > & {
              appOwner?: Maybe<
                | ({ __typename?: 'AppUser' } & Pick<
                    AppUser,
                    'accountId' | 'name' | 'picture'
                  >)
                | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                    AtlassianAccountUser,
                    'accountId' | 'name' | 'picture'
                  >)
                | ({ __typename?: 'CustomerUser' } & Pick<
                    CustomerUser,
                    'accountId' | 'name' | 'picture'
                  >)
              >;
              currentUserConsent?: Maybe<
                { __typename?: 'UserConsentExtension' } & Pick<
                  UserConsentExtension,
                  'consentedAt'
                > & {
                    user: { __typename?: 'UserConsentExtensionUser' } & Pick<
                      UserConsentExtensionUser,
                      'aaid'
                    >;
                    appEnvironmentVersion: {
                      __typename?: 'UserConsentExtensionAppEnvironmentVersion';
                    } & Pick<UserConsentExtensionAppEnvironmentVersion, 'id'>;
                  }
              >;
            }
        >;
        installations?: Maybe<
          { __typename?: 'AppInstallationConnection' } & {
            nodes?: Maybe<
              Array<
                Maybe<
                  { __typename?: 'AppInstallation' } & Pick<
                    AppInstallation,
                    'id'
                  > & {
                      app?: Maybe<{ __typename?: 'App' } & AppListViewFragment>;
                      appEnvironment?: Maybe<
                        { __typename?: 'AppEnvironment' } & Pick<
                          AppEnvironment,
                          'key'
                        >
                      >;
                    }
                >
              >
            >;
          }
        >;
      }
    >
  >;
};

export type GetInstalledComponentDetailAppsQueryVariables = Exact<{
  contextId: Scalars['ID'];
}>;

export type GetInstalledComponentDetailAppsQuery = { __typename?: 'Query' } & {
  extensionContexts?: Maybe<
    Array<
      { __typename?: 'ExtensionContext' } & {
        extensionsByType: Array<
          { __typename?: 'Extension' } & Pick<
            Extension,
            | 'id'
            | 'properties'
            | 'environmentId'
            | 'environmentType'
            | 'type'
            | 'appVersion'
            | 'consentUrl'
            | 'installationId'
            | 'requiresUserConsent'
          > & {
              appOwner?: Maybe<
                | ({ __typename?: 'AppUser' } & Pick<
                    AppUser,
                    'accountId' | 'name' | 'picture'
                  >)
                | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                    AtlassianAccountUser,
                    'accountId' | 'name' | 'picture'
                  >)
                | ({ __typename?: 'CustomerUser' } & Pick<
                    CustomerUser,
                    'accountId' | 'name' | 'picture'
                  >)
              >;
              currentUserConsent?: Maybe<
                { __typename?: 'UserConsentExtension' } & Pick<
                  UserConsentExtension,
                  'consentedAt'
                > & {
                    user: { __typename?: 'UserConsentExtensionUser' } & Pick<
                      UserConsentExtensionUser,
                      'aaid'
                    >;
                    appEnvironmentVersion: {
                      __typename?: 'UserConsentExtensionAppEnvironmentVersion';
                    } & Pick<UserConsentExtensionAppEnvironmentVersion, 'id'>;
                  }
              >;
            }
        >;
      }
    >
  >;
};

export type GetScorecardQueryVariables = Exact<{
  id: Scalars['ID'];
}>;

export type GetScorecardQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      scorecard?: Maybe<
        | ({ __typename: 'CompassScorecard' } & Pick<
            CompassScorecard,
            'id' | 'name' | 'description' | 'componentType' | 'importance'
          > & {
              owner?: Maybe<
                | ({ __typename?: 'AppUser' } & Pick<
                    AppUser,
                    'name' | 'accountId' | 'picture' | 'accountStatus'
                  >)
                | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                    AtlassianAccountUser,
                    'name' | 'accountId' | 'picture' | 'accountStatus'
                  >)
                | ({ __typename?: 'CustomerUser' } & Pick<
                    CustomerUser,
                    'name' | 'accountId' | 'picture' | 'accountStatus'
                  >)
              >;
              criterias?: Maybe<
                Array<
                  | ({
                      __typename: 'CompassHasDescriptionScorecardCriteria';
                    } & Pick<
                      CompassHasDescriptionScorecardCriteria,
                      'id' | 'weight'
                    >)
                  | ({ __typename: 'CompassHasFieldScorecardCriteria' } & Pick<
                      CompassHasFieldScorecardCriteria,
                      'id' | 'weight'
                    >)
                  | ({ __typename: 'CompassHasLinkScorecardCriteria' } & Pick<
                      CompassHasLinkScorecardCriteria,
                      'id' | 'linkType' | 'weight'
                    >)
                  | ({ __typename: 'CompassHasOwnerScorecardCriteria' } & Pick<
                      CompassHasOwnerScorecardCriteria,
                      'id' | 'weight'
                    >)
                >
              >;
            })
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetScorecardAppliedToComponentsWithScoresQueryVariables = Exact<{
  scorecardId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
}>;

export type GetScorecardAppliedToComponentsWithScoresQuery = {
  __typename?: 'Query';
} & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      scorecard?: Maybe<
        | ({ __typename: 'CompassScorecard' } & Pick<CompassScorecard, 'id'> & {
              appliedToComponents?: Maybe<
                | ({
                    __typename: 'CompassScorecardAppliedToComponentsConnection';
                  } & {
                    nodes?: Maybe<
                      Array<
                        { __typename?: 'CompassComponent' } & Pick<
                          CompassComponent,
                          'id' | 'name' | 'description' | 'type' | 'ownerId'
                        > & {
                            scorecardScore?: Maybe<
                              { __typename?: 'CompassScorecardScore' } & Pick<
                                CompassScorecardScore,
                                'totalScore'
                              >
                            >;
                          }
                      >
                    >;
                    pageInfo: { __typename: 'PageInfo' } & Pick<
                      PageInfo,
                      | 'hasNextPage'
                      | 'hasPreviousPage'
                      | 'endCursor'
                      | 'startCursor'
                    >;
                  })
                | { __typename: 'QueryError' }
              >;
            })
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetScorecardsQueryVariables = Exact<{
  cloudId: Scalars['ID'];
}>;

export type GetScorecardsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      scorecards?: Maybe<
        | ({ __typename: 'CompassScorecardConnection' } & {
            nodes?: Maybe<
              Array<
                { __typename?: 'CompassScorecard' } & Pick<
                  CompassScorecard,
                  'id' | 'name' | 'description' | 'importance' | 'componentType'
                > & {
                    owner?: Maybe<
                      | ({ __typename?: 'AppUser' } & Pick<
                          AppUser,
                          'accountId' | 'name'
                        >)
                      | ({ __typename?: 'AtlassianAccountUser' } & Pick<
                          AtlassianAccountUser,
                          'accountId' | 'name'
                        >)
                      | ({ __typename?: 'CustomerUser' } & Pick<
                          CustomerUser,
                          'accountId' | 'name'
                        >)
                    >;
                  } & CompassScorecardCoreFragment
              >
            >;
          })
        | ({ __typename: 'QueryError' } & Pick<QueryError, 'message'> & {
              extensions?: Maybe<
                Array<
                  { __typename?: 'GenericQueryErrorExtension' } & Pick<
                    GenericQueryErrorExtension,
                    'statusCode' | 'errorType'
                  >
                >
              >;
            })
      >;
    }
  >;
};

export type GetTeamCheckinsQueryVariables = Exact<{
  input: CompassTeamCheckinsInput;
}>;

export type GetTeamCheckinsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      teamCheckins?: Maybe<
        Array<
          { __typename: 'CompassTeamCheckin' } & Pick<
            CompassTeamCheckin,
            'teamId' | 'id' | 'mood' | 'response1' | 'response2' | 'response3'
          > & {
              changeMetadata: { __typename?: 'CompassChangeMetadata' } & Pick<
                CompassChangeMetadata,
                'createdAt' | 'lastUserModificationAt'
              >;
            } & CompassTeamCheckinCoreFragment
        >
      >;
    }
  >;
};

export type SearchComponentLabelsQueryVariables = Exact<{
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentLabelsQuery>;
}>;

export type SearchComponentLabelsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      searchComponentLabels?: Maybe<
        | ({ __typename?: 'CompassSearchComponentLabelsConnection' } & {
            nodes?: Maybe<
              Array<
                { __typename?: 'CompassComponentLabel' } & Pick<
                  CompassComponentLabel,
                  'name'
                >
              >
            >;
          })
        | ({ __typename?: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type SearchComponentsQueryVariables = Exact<{
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentQuery>;
}>;

export type SearchComponentsQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      searchComponents?: Maybe<
        | ({ __typename?: 'CompassSearchComponentConnection' } & {
            nodes?: Maybe<
              Array<
                {
                  __typename?: 'CompassSearchComponentResult';
                } & CompassSearchComponentNodeFragment
              >
            >;
            pageInfo: { __typename?: 'PageInfo' } & Pick<
              PageInfo,
              'hasNextPage' | 'endCursor'
            >;
          })
        | ({ __typename?: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type SearchComponentsAddTeamOwnerQueryVariables = Exact<{
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentQuery>;
}>;

export type SearchComponentsAddTeamOwnerQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      searchComponents?: Maybe<
        | ({ __typename?: 'CompassSearchComponentConnection' } & {
            nodes?: Maybe<
              Array<
                { __typename?: 'CompassSearchComponentResult' } & {
                  component?: Maybe<
                    { __typename?: 'CompassComponent' } & {
                      dataManager?: Maybe<
                        { __typename?: 'CompassComponentDataManager' } & Pick<
                          CompassComponentDataManager,
                          'ecosystemAppId'
                        >
                      >;
                    }
                  >;
                } & CompassSearchComponentNodeFragment
              >
            >;
            pageInfo: { __typename?: 'PageInfo' } & Pick<
              PageInfo,
              'hasNextPage' | 'endCursor'
            >;
          })
        | ({ __typename?: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type SearchComponentsPickerQueryVariables = Exact<{
  cloudId: Scalars['String'];
  query?: Maybe<CompassSearchComponentQuery>;
}>;

export type SearchComponentsPickerQuery = { __typename?: 'Query' } & {
  compass?: Maybe<
    { __typename?: 'CompassCatalogQueryApi' } & {
      searchComponents?: Maybe<
        | ({ __typename?: 'CompassSearchComponentConnection' } & {
            nodes?: Maybe<
              Array<
                { __typename?: 'CompassSearchComponentResult' } & {
                  component?: Maybe<
                    { __typename?: 'CompassComponent' } & Pick<
                      CompassComponent,
                      'name' | 'type'
                    > &
                      CompassComponentCoreFragment
                  >;
                }
              >
            >;
          })
        | ({ __typename?: 'QueryError' } & CommonQueryErrorFragment)
      >;
    }
  >;
};

export type SearchJiraProjectsQueryVariables = Exact<{
  cloudId: Scalars['ID'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filter: JiraProjectFilterInput;
}>;

export type SearchJiraProjectsQuery = { __typename?: 'Query' } & {
  jira?: Maybe<
    { __typename?: 'JiraQuery' } & {
      allJiraProjects?: Maybe<
        { __typename?: 'JiraProjectConnection' } & {
          edges?: Maybe<
            Array<
              Maybe<
                { __typename?: 'JiraProjectEdge' } & Pick<
                  JiraProjectEdge,
                  'cursor'
                > & {
                    node?: Maybe<
                      { __typename?: 'JiraProject' } & Pick<
                        JiraProject,
                        'id' | 'key' | 'name' | 'cloudId' | 'description'
                      > & {
                          avatar?: Maybe<
                            { __typename?: 'JiraAvatar' } & Pick<
                              JiraAvatar,
                              'xsmall'
                            >
                          >;
                        }
                    >;
                  }
              >
            >
          >;
          pageInfo: { __typename?: 'PageInfo' } & Pick<
            PageInfo,
            'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'
          >;
        }
      >;
    }
  >;
};

export const AppListViewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'AppListView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'App' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'avatarFileId' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vendorName' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
        ],
      },
    },
  ],
};
export const CommonMutationErrorFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export const CommonQueryErrorFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export const CompassComponentCoreFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentAnnouncementFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentAnnouncement' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassAnnouncement' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'title' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'targetDate' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'acknowledgements' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'hasAcknowledged' },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};
export const CompassComponentAnnouncementsFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentAnnouncements' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'announcements' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassComponentAnnouncement' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentAnnouncement' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassAnnouncement' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'title' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'targetDate' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'acknowledgements' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'hasAcknowledged' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentCommonDetailFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCommonDetail' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'dataManager' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'ecosystemAppId' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentLinkCommonFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLinkCommon' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassLink' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'url' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentLabelsFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLabels' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'labels' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'name' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentDetailViewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentDetailView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'links' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassComponentLinkCommon' },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'fields' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: { kind: 'Name', value: 'CompassEnumField' },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'value' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'definition' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'dataManager' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'ecosystemAppId' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'externalSourceURL' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'lastSyncEvent' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'time' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'status' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'lastSyncErrors' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'relationships' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: {
                      kind: 'Name',
                      value: 'CompassRelationshipConnection',
                    },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'nodes' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'type' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'startNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'endNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'events' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'query' },
                value: {
                  kind: 'ObjectValue',
                  fields: [
                    {
                      kind: 'ObjectField',
                      name: { kind: 'Name', value: 'eventTypes' },
                      value: {
                        kind: 'ListValue',
                        values: [{ kind: 'EnumValue', value: 'DEPLOYMENT' }],
                      },
                    },
                    {
                      kind: 'ObjectField',
                      name: { kind: 'Name', value: 'first' },
                      value: { kind: 'IntValue', value: '1' },
                    },
                  ],
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: { kind: 'Name', value: 'CompassEventConnection' },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'nodes' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'InlineFragment',
                              typeCondition: {
                                kind: 'NamedType',
                                name: {
                                  kind: 'Name',
                                  value: 'CompassDeploymentEvent',
                                },
                              },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'url' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'lastUpdated',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'environment',
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'displayName',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'displayName',
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentLabels' },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLabels' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'labels' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'name' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLinkCommon' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassLink' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'url' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentListViewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentListView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentOverviewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentOverview' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
        ],
      },
    },
  ],
};
export const CompassRelationshipCoreFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassComponentInRelationshipViewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassRelationshipInRelationshipViewFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassRelationshipCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassScorecardCoreFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassSearchComponentFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponent' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const CompassSearchComponentNodeFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponentNode' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassSearchComponentResult' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'link' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'component' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassSearchComponent' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponent' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
        ],
      },
    },
  ],
};
export const CompassTeamCheckinCoreFragmentDoc: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassTeamCheckinCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassTeamCheckin' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export const AcknowledgeAnnouncementDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'acknowledgeAnnouncement' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: 'CompassAcknowledgeAnnouncementInput',
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'acknowledgeAnnouncement' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'acknowledgement' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'component' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'FragmentSpread',
                                    name: {
                                      kind: 'Name',
                                      value: 'CompassComponentCore',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'hasAcknowledged' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type AcknowledgeAnnouncementMutationFn = Apollo.MutationFunction<
  AcknowledgeAnnouncementMutation,
  AcknowledgeAnnouncementMutationVariables
>;

/**
 * __useAcknowledgeAnnouncementMutation__
 *
 * To run a mutation, you first call `useAcknowledgeAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcknowledgeAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acknowledgeAnnouncementMutation, { data, loading, error }] = useAcknowledgeAnnouncementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAcknowledgeAnnouncementMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AcknowledgeAnnouncementMutation,
    AcknowledgeAnnouncementMutationVariables
  >,
) {
  return Apollo.useMutation<
    AcknowledgeAnnouncementMutation,
    AcknowledgeAnnouncementMutationVariables
  >(AcknowledgeAnnouncementDocument, baseOptions);
}
export type AcknowledgeAnnouncementMutationHookResult = ReturnType<
  typeof useAcknowledgeAnnouncementMutation
>;
export type AcknowledgeAnnouncementMutationResult = Apollo.MutationResult<
  AcknowledgeAnnouncementMutation
>;
export type AcknowledgeAnnouncementMutationOptions = Apollo.BaseMutationOptions<
  AcknowledgeAnnouncementMutation,
  AcknowledgeAnnouncementMutationVariables
>;
export const AddComponentLabelsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'addComponentLabels' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'AddCompassComponentLabelsInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'addComponentLabels' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'addedLabels' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type AddComponentLabelsMutationFn = Apollo.MutationFunction<
  AddComponentLabelsMutation,
  AddComponentLabelsMutationVariables
>;

/**
 * __useAddComponentLabelsMutation__
 *
 * To run a mutation, you first call `useAddComponentLabelsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddComponentLabelsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addComponentLabelsMutation, { data, loading, error }] = useAddComponentLabelsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddComponentLabelsMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddComponentLabelsMutation,
    AddComponentLabelsMutationVariables
  >,
) {
  return Apollo.useMutation<
    AddComponentLabelsMutation,
    AddComponentLabelsMutationVariables
  >(AddComponentLabelsDocument, baseOptions);
}
export type AddComponentLabelsMutationHookResult = ReturnType<
  typeof useAddComponentLabelsMutation
>;
export type AddComponentLabelsMutationResult = Apollo.MutationResult<
  AddComponentLabelsMutation
>;
export type AddComponentLabelsMutationOptions = Apollo.BaseMutationOptions<
  AddComponentLabelsMutation,
  AddComponentLabelsMutationVariables
>;
export const ApplyScorecardToComponentDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'applyScorecardToComponent' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'componentId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'applyScorecardToComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'componentId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'componentId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type ApplyScorecardToComponentMutationFn = Apollo.MutationFunction<
  ApplyScorecardToComponentMutation,
  ApplyScorecardToComponentMutationVariables
>;

/**
 * __useApplyScorecardToComponentMutation__
 *
 * To run a mutation, you first call `useApplyScorecardToComponentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyScorecardToComponentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyScorecardToComponentMutation, { data, loading, error }] = useApplyScorecardToComponentMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      componentId: // value for 'componentId'
 *   },
 * });
 */
export function useApplyScorecardToComponentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ApplyScorecardToComponentMutation,
    ApplyScorecardToComponentMutationVariables
  >,
) {
  return Apollo.useMutation<
    ApplyScorecardToComponentMutation,
    ApplyScorecardToComponentMutationVariables
  >(ApplyScorecardToComponentDocument, baseOptions);
}
export type ApplyScorecardToComponentMutationHookResult = ReturnType<
  typeof useApplyScorecardToComponentMutation
>;
export type ApplyScorecardToComponentMutationResult = Apollo.MutationResult<
  ApplyScorecardToComponentMutation
>;
export type ApplyScorecardToComponentMutationOptions = Apollo.BaseMutationOptions<
  ApplyScorecardToComponentMutation,
  ApplyScorecardToComponentMutationVariables
>;
export const CreateAnnouncementDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createAnnouncement' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassCreateAnnouncementInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createAnnouncement' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'createdAnnouncement' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'title' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'targetDate' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'acknowledgements' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'component' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'id' },
                                        },
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'name' },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'hasAcknowledged',
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type CreateAnnouncementMutationFn = Apollo.MutationFunction<
  CreateAnnouncementMutation,
  CreateAnnouncementMutationVariables
>;

/**
 * __useCreateAnnouncementMutation__
 *
 * To run a mutation, you first call `useCreateAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAnnouncementMutation, { data, loading, error }] = useCreateAnnouncementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAnnouncementMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateAnnouncementMutation,
    CreateAnnouncementMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateAnnouncementMutation,
    CreateAnnouncementMutationVariables
  >(CreateAnnouncementDocument, baseOptions);
}
export type CreateAnnouncementMutationHookResult = ReturnType<
  typeof useCreateAnnouncementMutation
>;
export type CreateAnnouncementMutationResult = Apollo.MutationResult<
  CreateAnnouncementMutation
>;
export type CreateAnnouncementMutationOptions = Apollo.BaseMutationOptions<
  CreateAnnouncementMutation,
  CreateAnnouncementMutationVariables
>;
export const CreateComponentDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createComponent' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type CreateComponentMutationFn = Apollo.MutationFunction<
  CreateComponentMutation,
  CreateComponentMutationVariables
>;

/**
 * __useCreateComponentMutation__
 *
 * To run a mutation, you first call `useCreateComponentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateComponentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createComponentMutation, { data, loading, error }] = useCreateComponentMutation({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateComponentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateComponentMutation,
    CreateComponentMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateComponentMutation,
    CreateComponentMutationVariables
  >(CreateComponentDocument, baseOptions);
}
export type CreateComponentMutationHookResult = ReturnType<
  typeof useCreateComponentMutation
>;
export type CreateComponentMutationResult = Apollo.MutationResult<
  CreateComponentMutation
>;
export type CreateComponentMutationOptions = Apollo.BaseMutationOptions<
  CreateComponentMutation,
  CreateComponentMutationVariables
>;
export const CreateComponentLinkDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createComponentLink' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateCompassComponentLinkInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createComponentLink' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'links' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'url' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type CreateComponentLinkMutationFn = Apollo.MutationFunction<
  CreateComponentLinkMutation,
  CreateComponentLinkMutationVariables
>;

/**
 * __useCreateComponentLinkMutation__
 *
 * To run a mutation, you first call `useCreateComponentLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateComponentLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createComponentLinkMutation, { data, loading, error }] = useCreateComponentLinkMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateComponentLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateComponentLinkMutation,
    CreateComponentLinkMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateComponentLinkMutation,
    CreateComponentLinkMutationVariables
  >(CreateComponentLinkDocument, baseOptions);
}
export type CreateComponentLinkMutationHookResult = ReturnType<
  typeof useCreateComponentLinkMutation
>;
export type CreateComponentLinkMutationResult = Apollo.MutationResult<
  CreateComponentLinkMutation
>;
export type CreateComponentLinkMutationOptions = Apollo.BaseMutationOptions<
  CreateComponentLinkMutation,
  CreateComponentLinkMutationVariables
>;
export const CreateRelationshipDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createRelationship' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateCompassRelationshipInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createRelationship' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: {
                          kind: 'Name',
                          value: 'createdCompassRelationship',
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'type' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'startNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'endNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type CreateRelationshipMutationFn = Apollo.MutationFunction<
  CreateRelationshipMutation,
  CreateRelationshipMutationVariables
>;

/**
 * __useCreateRelationshipMutation__
 *
 * To run a mutation, you first call `useCreateRelationshipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRelationshipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRelationshipMutation, { data, loading, error }] = useCreateRelationshipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRelationshipMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateRelationshipMutation,
    CreateRelationshipMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateRelationshipMutation,
    CreateRelationshipMutationVariables
  >(CreateRelationshipDocument, baseOptions);
}
export type CreateRelationshipMutationHookResult = ReturnType<
  typeof useCreateRelationshipMutation
>;
export type CreateRelationshipMutationResult = Apollo.MutationResult<
  CreateRelationshipMutation
>;
export type CreateRelationshipMutationOptions = Apollo.BaseMutationOptions<
  CreateRelationshipMutation,
  CreateRelationshipMutationVariables
>;
export const CreateScorecardDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createScorecard' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CreateCompassScorecardInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createScorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'scorecardDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassScorecardCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type CreateScorecardMutationFn = Apollo.MutationFunction<
  CreateScorecardMutation,
  CreateScorecardMutationVariables
>;

/**
 * __useCreateScorecardMutation__
 *
 * To run a mutation, you first call `useCreateScorecardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateScorecardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createScorecardMutation, { data, loading, error }] = useCreateScorecardMutation({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateScorecardMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateScorecardMutation,
    CreateScorecardMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateScorecardMutation,
    CreateScorecardMutationVariables
  >(CreateScorecardDocument, baseOptions);
}
export type CreateScorecardMutationHookResult = ReturnType<
  typeof useCreateScorecardMutation
>;
export type CreateScorecardMutationResult = Apollo.MutationResult<
  CreateScorecardMutation
>;
export type CreateScorecardMutationOptions = Apollo.BaseMutationOptions<
  CreateScorecardMutation,
  CreateScorecardMutationVariables
>;
export const CreateScorecardCriteriasDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createScorecardCriterias' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: 'CreateCompassScorecardCriteriasInput',
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createScorecardCriterias' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'scorecard' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassScorecardCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type CreateScorecardCriteriasMutationFn = Apollo.MutationFunction<
  CreateScorecardCriteriasMutation,
  CreateScorecardCriteriasMutationVariables
>;

/**
 * __useCreateScorecardCriteriasMutation__
 *
 * To run a mutation, you first call `useCreateScorecardCriteriasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateScorecardCriteriasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createScorecardCriteriasMutation, { data, loading, error }] = useCreateScorecardCriteriasMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateScorecardCriteriasMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateScorecardCriteriasMutation,
    CreateScorecardCriteriasMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateScorecardCriteriasMutation,
    CreateScorecardCriteriasMutationVariables
  >(CreateScorecardCriteriasDocument, baseOptions);
}
export type CreateScorecardCriteriasMutationHookResult = ReturnType<
  typeof useCreateScorecardCriteriasMutation
>;
export type CreateScorecardCriteriasMutationResult = Apollo.MutationResult<
  CreateScorecardCriteriasMutation
>;
export type CreateScorecardCriteriasMutationOptions = Apollo.BaseMutationOptions<
  CreateScorecardCriteriasMutation,
  CreateScorecardCriteriasMutationVariables
>;
export const CreateTeamCheckinDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'createTeamCheckin' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassCreateTeamCheckinInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'createTeamCheckin' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'createdTeamCheckin' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'teamId' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'mood' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response1' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response2' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response3' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'changeMetadata' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'createdAt' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'lastUserModificationAt',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassTeamCheckinCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassTeamCheckinCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassTeamCheckin' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type CreateTeamCheckinMutationFn = Apollo.MutationFunction<
  CreateTeamCheckinMutation,
  CreateTeamCheckinMutationVariables
>;

/**
 * __useCreateTeamCheckinMutation__
 *
 * To run a mutation, you first call `useCreateTeamCheckinMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTeamCheckinMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTeamCheckinMutation, { data, loading, error }] = useCreateTeamCheckinMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTeamCheckinMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateTeamCheckinMutation,
    CreateTeamCheckinMutationVariables
  >,
) {
  return Apollo.useMutation<
    CreateTeamCheckinMutation,
    CreateTeamCheckinMutationVariables
  >(CreateTeamCheckinDocument, baseOptions);
}
export type CreateTeamCheckinMutationHookResult = ReturnType<
  typeof useCreateTeamCheckinMutation
>;
export type CreateTeamCheckinMutationResult = Apollo.MutationResult<
  CreateTeamCheckinMutation
>;
export type CreateTeamCheckinMutationOptions = Apollo.BaseMutationOptions<
  CreateTeamCheckinMutation,
  CreateTeamCheckinMutationVariables
>;
export const DeleteAnnouncementDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteAnnouncement' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassDeleteAnnouncementInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteAnnouncement' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'deletedAnnouncementId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteAnnouncementMutationFn = Apollo.MutationFunction<
  DeleteAnnouncementMutation,
  DeleteAnnouncementMutationVariables
>;

/**
 * __useDeleteAnnouncementMutation__
 *
 * To run a mutation, you first call `useDeleteAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAnnouncementMutation, { data, loading, error }] = useDeleteAnnouncementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteAnnouncementMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteAnnouncementMutation,
    DeleteAnnouncementMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteAnnouncementMutation,
    DeleteAnnouncementMutationVariables
  >(DeleteAnnouncementDocument, baseOptions);
}
export type DeleteAnnouncementMutationHookResult = ReturnType<
  typeof useDeleteAnnouncementMutation
>;
export type DeleteAnnouncementMutationResult = Apollo.MutationResult<
  DeleteAnnouncementMutation
>;
export type DeleteAnnouncementMutationOptions = Apollo.BaseMutationOptions<
  DeleteAnnouncementMutation,
  DeleteAnnouncementMutationVariables
>;
export const DeleteComponentDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteComponent' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'DeleteCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'deletedComponentId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '_isOptimistic' },
                        directives: [
                          {
                            kind: 'Directive',
                            name: { kind: 'Name', value: 'client' },
                          },
                        ],
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteComponentMutationFn = Apollo.MutationFunction<
  DeleteComponentMutation,
  DeleteComponentMutationVariables
>;

/**
 * __useDeleteComponentMutation__
 *
 * To run a mutation, you first call `useDeleteComponentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteComponentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteComponentMutation, { data, loading, error }] = useDeleteComponentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteComponentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteComponentMutation,
    DeleteComponentMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteComponentMutation,
    DeleteComponentMutationVariables
  >(DeleteComponentDocument, baseOptions);
}
export type DeleteComponentMutationHookResult = ReturnType<
  typeof useDeleteComponentMutation
>;
export type DeleteComponentMutationResult = Apollo.MutationResult<
  DeleteComponentMutation
>;
export type DeleteComponentMutationOptions = Apollo.BaseMutationOptions<
  DeleteComponentMutation,
  DeleteComponentMutationVariables
>;
export const DeleteComponentLinkDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteComponentLink' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'DeleteCompassComponentLinkInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteComponentLink' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'deletedCompassLinkId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteComponentLinkMutationFn = Apollo.MutationFunction<
  DeleteComponentLinkMutation,
  DeleteComponentLinkMutationVariables
>;

/**
 * __useDeleteComponentLinkMutation__
 *
 * To run a mutation, you first call `useDeleteComponentLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteComponentLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteComponentLinkMutation, { data, loading, error }] = useDeleteComponentLinkMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteComponentLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteComponentLinkMutation,
    DeleteComponentLinkMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteComponentLinkMutation,
    DeleteComponentLinkMutationVariables
  >(DeleteComponentLinkDocument, baseOptions);
}
export type DeleteComponentLinkMutationHookResult = ReturnType<
  typeof useDeleteComponentLinkMutation
>;
export type DeleteComponentLinkMutationResult = Apollo.MutationResult<
  DeleteComponentLinkMutation
>;
export type DeleteComponentLinkMutationOptions = Apollo.BaseMutationOptions<
  DeleteComponentLinkMutation,
  DeleteComponentLinkMutationVariables
>;
export const DeleteRelationshipDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteRelationship' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'DeleteCompassRelationshipInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteRelationship' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteRelationshipMutationFn = Apollo.MutationFunction<
  DeleteRelationshipMutation,
  DeleteRelationshipMutationVariables
>;

/**
 * __useDeleteRelationshipMutation__
 *
 * To run a mutation, you first call `useDeleteRelationshipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRelationshipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRelationshipMutation, { data, loading, error }] = useDeleteRelationshipMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteRelationshipMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteRelationshipMutation,
    DeleteRelationshipMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteRelationshipMutation,
    DeleteRelationshipMutationVariables
  >(DeleteRelationshipDocument, baseOptions);
}
export type DeleteRelationshipMutationHookResult = ReturnType<
  typeof useDeleteRelationshipMutation
>;
export type DeleteRelationshipMutationResult = Apollo.MutationResult<
  DeleteRelationshipMutation
>;
export type DeleteRelationshipMutationOptions = Apollo.BaseMutationOptions<
  DeleteRelationshipMutation,
  DeleteRelationshipMutationVariables
>;
export const DeleteScorecardDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteScorecard' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteScorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteScorecardMutationFn = Apollo.MutationFunction<
  DeleteScorecardMutation,
  DeleteScorecardMutationVariables
>;

/**
 * __useDeleteScorecardMutation__
 *
 * To run a mutation, you first call `useDeleteScorecardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteScorecardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteScorecardMutation, { data, loading, error }] = useDeleteScorecardMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *   },
 * });
 */
export function useDeleteScorecardMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteScorecardMutation,
    DeleteScorecardMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteScorecardMutation,
    DeleteScorecardMutationVariables
  >(DeleteScorecardDocument, baseOptions);
}
export type DeleteScorecardMutationHookResult = ReturnType<
  typeof useDeleteScorecardMutation
>;
export type DeleteScorecardMutationResult = Apollo.MutationResult<
  DeleteScorecardMutation
>;
export type DeleteScorecardMutationOptions = Apollo.BaseMutationOptions<
  DeleteScorecardMutation,
  DeleteScorecardMutationVariables
>;
export const DeleteScorecardCriteriasDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteScorecardCriterias' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: 'DeleteCompassScorecardCriteriasInput',
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteScorecardCriterias' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteScorecardCriteriasMutationFn = Apollo.MutationFunction<
  DeleteScorecardCriteriasMutation,
  DeleteScorecardCriteriasMutationVariables
>;

/**
 * __useDeleteScorecardCriteriasMutation__
 *
 * To run a mutation, you first call `useDeleteScorecardCriteriasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteScorecardCriteriasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteScorecardCriteriasMutation, { data, loading, error }] = useDeleteScorecardCriteriasMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteScorecardCriteriasMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteScorecardCriteriasMutation,
    DeleteScorecardCriteriasMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteScorecardCriteriasMutation,
    DeleteScorecardCriteriasMutationVariables
  >(DeleteScorecardCriteriasDocument, baseOptions);
}
export type DeleteScorecardCriteriasMutationHookResult = ReturnType<
  typeof useDeleteScorecardCriteriasMutation
>;
export type DeleteScorecardCriteriasMutationResult = Apollo.MutationResult<
  DeleteScorecardCriteriasMutation
>;
export type DeleteScorecardCriteriasMutationOptions = Apollo.BaseMutationOptions<
  DeleteScorecardCriteriasMutation,
  DeleteScorecardCriteriasMutationVariables
>;
export const DeleteTeamCheckinDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'deleteTeamCheckin' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassDeleteTeamCheckinInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'deleteTeamCheckin' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'deletedTeamCheckinId' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type DeleteTeamCheckinMutationFn = Apollo.MutationFunction<
  DeleteTeamCheckinMutation,
  DeleteTeamCheckinMutationVariables
>;

/**
 * __useDeleteTeamCheckinMutation__
 *
 * To run a mutation, you first call `useDeleteTeamCheckinMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTeamCheckinMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTeamCheckinMutation, { data, loading, error }] = useDeleteTeamCheckinMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTeamCheckinMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteTeamCheckinMutation,
    DeleteTeamCheckinMutationVariables
  >,
) {
  return Apollo.useMutation<
    DeleteTeamCheckinMutation,
    DeleteTeamCheckinMutationVariables
  >(DeleteTeamCheckinDocument, baseOptions);
}
export type DeleteTeamCheckinMutationHookResult = ReturnType<
  typeof useDeleteTeamCheckinMutation
>;
export type DeleteTeamCheckinMutationResult = Apollo.MutationResult<
  DeleteTeamCheckinMutation
>;
export type DeleteTeamCheckinMutationOptions = Apollo.BaseMutationOptions<
  DeleteTeamCheckinMutation,
  DeleteTeamCheckinMutationVariables
>;
export const InstallForgeAppDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'installForgeApp' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'AppInstallationInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'installApp' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'input' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'input' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'success' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'installationId' },
                },
                { kind: 'Field', name: { kind: 'Name', value: 'taskId' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'errors' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'message' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type InstallForgeAppMutationFn = Apollo.MutationFunction<
  InstallForgeAppMutation,
  InstallForgeAppMutationVariables
>;

/**
 * __useInstallForgeAppMutation__
 *
 * To run a mutation, you first call `useInstallForgeAppMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInstallForgeAppMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [installForgeAppMutation, { data, loading, error }] = useInstallForgeAppMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useInstallForgeAppMutation(
  baseOptions?: Apollo.MutationHookOptions<
    InstallForgeAppMutation,
    InstallForgeAppMutationVariables
  >,
) {
  return Apollo.useMutation<
    InstallForgeAppMutation,
    InstallForgeAppMutationVariables
  >(InstallForgeAppDocument, baseOptions);
}
export type InstallForgeAppMutationHookResult = ReturnType<
  typeof useInstallForgeAppMutation
>;
export type InstallForgeAppMutationResult = Apollo.MutationResult<
  InstallForgeAppMutation
>;
export type InstallForgeAppMutationOptions = Apollo.BaseMutationOptions<
  InstallForgeAppMutation,
  InstallForgeAppMutationVariables
>;
export const RemoveComponentLabelsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'removeComponentLabels' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: 'RemoveCompassComponentLabelsInput',
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'removeComponentLabels' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'removedLabelNames' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type RemoveComponentLabelsMutationFn = Apollo.MutationFunction<
  RemoveComponentLabelsMutation,
  RemoveComponentLabelsMutationVariables
>;

/**
 * __useRemoveComponentLabelsMutation__
 *
 * To run a mutation, you first call `useRemoveComponentLabelsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveComponentLabelsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeComponentLabelsMutation, { data, loading, error }] = useRemoveComponentLabelsMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useRemoveComponentLabelsMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RemoveComponentLabelsMutation,
    RemoveComponentLabelsMutationVariables
  >,
) {
  return Apollo.useMutation<
    RemoveComponentLabelsMutation,
    RemoveComponentLabelsMutationVariables
  >(RemoveComponentLabelsDocument, baseOptions);
}
export type RemoveComponentLabelsMutationHookResult = ReturnType<
  typeof useRemoveComponentLabelsMutation
>;
export type RemoveComponentLabelsMutationResult = Apollo.MutationResult<
  RemoveComponentLabelsMutation
>;
export type RemoveComponentLabelsMutationOptions = Apollo.BaseMutationOptions<
  RemoveComponentLabelsMutation,
  RemoveComponentLabelsMutationVariables
>;
export const RemoveScorecardFromComponentDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'removeScorecardFromComponent' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'componentId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'removeScorecardFromComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'componentId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'componentId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type RemoveScorecardFromComponentMutationFn = Apollo.MutationFunction<
  RemoveScorecardFromComponentMutation,
  RemoveScorecardFromComponentMutationVariables
>;

/**
 * __useRemoveScorecardFromComponentMutation__
 *
 * To run a mutation, you first call `useRemoveScorecardFromComponentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveScorecardFromComponentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeScorecardFromComponentMutation, { data, loading, error }] = useRemoveScorecardFromComponentMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      componentId: // value for 'componentId'
 *   },
 * });
 */
export function useRemoveScorecardFromComponentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RemoveScorecardFromComponentMutation,
    RemoveScorecardFromComponentMutationVariables
  >,
) {
  return Apollo.useMutation<
    RemoveScorecardFromComponentMutation,
    RemoveScorecardFromComponentMutationVariables
  >(RemoveScorecardFromComponentDocument, baseOptions);
}
export type RemoveScorecardFromComponentMutationHookResult = ReturnType<
  typeof useRemoveScorecardFromComponentMutation
>;
export type RemoveScorecardFromComponentMutationResult = Apollo.MutationResult<
  RemoveScorecardFromComponentMutation
>;
export type RemoveScorecardFromComponentMutationOptions = Apollo.BaseMutationOptions<
  RemoveScorecardFromComponentMutation,
  RemoveScorecardFromComponentMutationVariables
>;
export const UninstallForgeAppDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'uninstallForgeApp' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'AppUninstallationInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'uninstallApp' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'input' },
                value: {
                  kind: 'Variable',
                  name: { kind: 'Name', value: 'input' },
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'success' } },
                { kind: 'Field', name: { kind: 'Name', value: 'taskId' } },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'errors' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'message' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type UninstallForgeAppMutationFn = Apollo.MutationFunction<
  UninstallForgeAppMutation,
  UninstallForgeAppMutationVariables
>;

/**
 * __useUninstallForgeAppMutation__
 *
 * To run a mutation, you first call `useUninstallForgeAppMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUninstallForgeAppMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uninstallForgeAppMutation, { data, loading, error }] = useUninstallForgeAppMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUninstallForgeAppMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UninstallForgeAppMutation,
    UninstallForgeAppMutationVariables
  >,
) {
  return Apollo.useMutation<
    UninstallForgeAppMutation,
    UninstallForgeAppMutationVariables
  >(UninstallForgeAppDocument, baseOptions);
}
export type UninstallForgeAppMutationHookResult = ReturnType<
  typeof useUninstallForgeAppMutation
>;
export type UninstallForgeAppMutationResult = Apollo.MutationResult<
  UninstallForgeAppMutation
>;
export type UninstallForgeAppMutationOptions = Apollo.BaseMutationOptions<
  UninstallForgeAppMutation,
  UninstallForgeAppMutationVariables
>;
export const UpdateAnnouncementDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateAnnouncement' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassUpdateAnnouncementInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateAnnouncement' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'updatedAnnouncement' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'title' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'targetDate' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'acknowledgements' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'component' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'id' },
                                        },
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'name' },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'hasAcknowledged',
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type UpdateAnnouncementMutationFn = Apollo.MutationFunction<
  UpdateAnnouncementMutation,
  UpdateAnnouncementMutationVariables
>;

/**
 * __useUpdateAnnouncementMutation__
 *
 * To run a mutation, you first call `useUpdateAnnouncementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAnnouncementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAnnouncementMutation, { data, loading, error }] = useUpdateAnnouncementMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAnnouncementMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateAnnouncementMutation,
    UpdateAnnouncementMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateAnnouncementMutation,
    UpdateAnnouncementMutationVariables
  >(UpdateAnnouncementDocument, baseOptions);
}
export type UpdateAnnouncementMutationHookResult = ReturnType<
  typeof useUpdateAnnouncementMutation
>;
export type UpdateAnnouncementMutationResult = Apollo.MutationResult<
  UpdateAnnouncementMutation
>;
export type UpdateAnnouncementMutationOptions = Apollo.BaseMutationOptions<
  UpdateAnnouncementMutation,
  UpdateAnnouncementMutationVariables
>;
export const UpdateComponentDescriptionDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateComponentDescription' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateComponentDescriptionMutationFn = Apollo.MutationFunction<
  UpdateComponentDescriptionMutation,
  UpdateComponentDescriptionMutationVariables
>;

/**
 * __useUpdateComponentDescriptionMutation__
 *
 * To run a mutation, you first call `useUpdateComponentDescriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateComponentDescriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateComponentDescriptionMutation, { data, loading, error }] = useUpdateComponentDescriptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateComponentDescriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateComponentDescriptionMutation,
    UpdateComponentDescriptionMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateComponentDescriptionMutation,
    UpdateComponentDescriptionMutationVariables
  >(UpdateComponentDescriptionDocument, baseOptions);
}
export type UpdateComponentDescriptionMutationHookResult = ReturnType<
  typeof useUpdateComponentDescriptionMutation
>;
export type UpdateComponentDescriptionMutationResult = Apollo.MutationResult<
  UpdateComponentDescriptionMutation
>;
export type UpdateComponentDescriptionMutationOptions = Apollo.BaseMutationOptions<
  UpdateComponentDescriptionMutation,
  UpdateComponentDescriptionMutationVariables
>;
export const UpdateComponentFieldTierDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateComponentFieldTier' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'fields' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassEnumField',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'definition',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'id',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'value',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateComponentFieldTierMutationFn = Apollo.MutationFunction<
  UpdateComponentFieldTierMutation,
  UpdateComponentFieldTierMutationVariables
>;

/**
 * __useUpdateComponentFieldTierMutation__
 *
 * To run a mutation, you first call `useUpdateComponentFieldTierMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateComponentFieldTierMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateComponentFieldTierMutation, { data, loading, error }] = useUpdateComponentFieldTierMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateComponentFieldTierMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateComponentFieldTierMutation,
    UpdateComponentFieldTierMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateComponentFieldTierMutation,
    UpdateComponentFieldTierMutationVariables
  >(UpdateComponentFieldTierDocument, baseOptions);
}
export type UpdateComponentFieldTierMutationHookResult = ReturnType<
  typeof useUpdateComponentFieldTierMutation
>;
export type UpdateComponentFieldTierMutationResult = Apollo.MutationResult<
  UpdateComponentFieldTierMutation
>;
export type UpdateComponentFieldTierMutationOptions = Apollo.BaseMutationOptions<
  UpdateComponentFieldTierMutation,
  UpdateComponentFieldTierMutationVariables
>;
export const UpdateComponentLinkDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateComponentLink' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassComponentLinkInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateComponentLink' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'links' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'url' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};
export type UpdateComponentLinkMutationFn = Apollo.MutationFunction<
  UpdateComponentLinkMutation,
  UpdateComponentLinkMutationVariables
>;

/**
 * __useUpdateComponentLinkMutation__
 *
 * To run a mutation, you first call `useUpdateComponentLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateComponentLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateComponentLinkMutation, { data, loading, error }] = useUpdateComponentLinkMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateComponentLinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateComponentLinkMutation,
    UpdateComponentLinkMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateComponentLinkMutation,
    UpdateComponentLinkMutationVariables
  >(UpdateComponentLinkDocument, baseOptions);
}
export type UpdateComponentLinkMutationHookResult = ReturnType<
  typeof useUpdateComponentLinkMutation
>;
export type UpdateComponentLinkMutationResult = Apollo.MutationResult<
  UpdateComponentLinkMutation
>;
export type UpdateComponentLinkMutationOptions = Apollo.BaseMutationOptions<
  UpdateComponentLinkMutation,
  UpdateComponentLinkMutationVariables
>;
export const UpdateComponentNameDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateComponentName' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateComponentNameMutationFn = Apollo.MutationFunction<
  UpdateComponentNameMutation,
  UpdateComponentNameMutationVariables
>;

/**
 * __useUpdateComponentNameMutation__
 *
 * To run a mutation, you first call `useUpdateComponentNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateComponentNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateComponentNameMutation, { data, loading, error }] = useUpdateComponentNameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateComponentNameMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateComponentNameMutation,
    UpdateComponentNameMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateComponentNameMutation,
    UpdateComponentNameMutationVariables
  >(UpdateComponentNameDocument, baseOptions);
}
export type UpdateComponentNameMutationHookResult = ReturnType<
  typeof useUpdateComponentNameMutation
>;
export type UpdateComponentNameMutationResult = Apollo.MutationResult<
  UpdateComponentNameMutation
>;
export type UpdateComponentNameMutationOptions = Apollo.BaseMutationOptions<
  UpdateComponentNameMutation,
  UpdateComponentNameMutationVariables
>;
export const UpdateComponentOwnerDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateComponentOwner' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassComponentInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateComponent' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'componentDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'ownerId' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateComponentOwnerMutationFn = Apollo.MutationFunction<
  UpdateComponentOwnerMutation,
  UpdateComponentOwnerMutationVariables
>;

/**
 * __useUpdateComponentOwnerMutation__
 *
 * To run a mutation, you first call `useUpdateComponentOwnerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateComponentOwnerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateComponentOwnerMutation, { data, loading, error }] = useUpdateComponentOwnerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateComponentOwnerMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateComponentOwnerMutation,
    UpdateComponentOwnerMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateComponentOwnerMutation,
    UpdateComponentOwnerMutationVariables
  >(UpdateComponentOwnerDocument, baseOptions);
}
export type UpdateComponentOwnerMutationHookResult = ReturnType<
  typeof useUpdateComponentOwnerMutation
>;
export type UpdateComponentOwnerMutationResult = Apollo.MutationResult<
  UpdateComponentOwnerMutation
>;
export type UpdateComponentOwnerMutationOptions = Apollo.BaseMutationOptions<
  UpdateComponentOwnerMutation,
  UpdateComponentOwnerMutationVariables
>;
export const UpdateScorecardDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateScorecard' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'UpdateCompassScorecardInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateScorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'scorecardDetails' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassScorecardCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'importance' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'componentType' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'owner' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateScorecardMutationFn = Apollo.MutationFunction<
  UpdateScorecardMutation,
  UpdateScorecardMutationVariables
>;

/**
 * __useUpdateScorecardMutation__
 *
 * To run a mutation, you first call `useUpdateScorecardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateScorecardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateScorecardMutation, { data, loading, error }] = useUpdateScorecardMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateScorecardMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateScorecardMutation,
    UpdateScorecardMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateScorecardMutation,
    UpdateScorecardMutationVariables
  >(UpdateScorecardDocument, baseOptions);
}
export type UpdateScorecardMutationHookResult = ReturnType<
  typeof useUpdateScorecardMutation
>;
export type UpdateScorecardMutationResult = Apollo.MutationResult<
  UpdateScorecardMutation
>;
export type UpdateScorecardMutationOptions = Apollo.BaseMutationOptions<
  UpdateScorecardMutation,
  UpdateScorecardMutationVariables
>;
export const UpdateScorecardCriteriaDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateScorecardCriteria' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: 'UpdateCompassScorecardCriteriasInput',
              },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateScorecardCriterias' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'scorecardId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'scorecard' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassScorecardCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateScorecardCriteriaMutationFn = Apollo.MutationFunction<
  UpdateScorecardCriteriaMutation,
  UpdateScorecardCriteriaMutationVariables
>;

/**
 * __useUpdateScorecardCriteriaMutation__
 *
 * To run a mutation, you first call `useUpdateScorecardCriteriaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateScorecardCriteriaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateScorecardCriteriaMutation, { data, loading, error }] = useUpdateScorecardCriteriaMutation({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateScorecardCriteriaMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateScorecardCriteriaMutation,
    UpdateScorecardCriteriaMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateScorecardCriteriaMutation,
    UpdateScorecardCriteriaMutationVariables
  >(UpdateScorecardCriteriaDocument, baseOptions);
}
export type UpdateScorecardCriteriaMutationHookResult = ReturnType<
  typeof useUpdateScorecardCriteriaMutation
>;
export type UpdateScorecardCriteriaMutationResult = Apollo.MutationResult<
  UpdateScorecardCriteriaMutation
>;
export type UpdateScorecardCriteriaMutationOptions = Apollo.BaseMutationOptions<
  UpdateScorecardCriteriaMutation,
  UpdateScorecardCriteriaMutationVariables
>;
export const UpdateTeamCheckinDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'mutation',
      name: { kind: 'Name', value: 'updateTeamCheckin' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassUpdateTeamCheckinInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'updateTeamCheckin' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'success' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'updatedTeamCheckin' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: '__typename' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'teamId' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'mood' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response1' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response2' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'response3' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'changeMetadata' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'createdAt' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'lastUserModificationAt',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassTeamCheckinCore',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'errors' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CommonMutationError',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonMutationError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'MutationError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassTeamCheckinCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassTeamCheckin' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};
export type UpdateTeamCheckinMutationFn = Apollo.MutationFunction<
  UpdateTeamCheckinMutation,
  UpdateTeamCheckinMutationVariables
>;

/**
 * __useUpdateTeamCheckinMutation__
 *
 * To run a mutation, you first call `useUpdateTeamCheckinMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTeamCheckinMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTeamCheckinMutation, { data, loading, error }] = useUpdateTeamCheckinMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTeamCheckinMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateTeamCheckinMutation,
    UpdateTeamCheckinMutationVariables
  >,
) {
  return Apollo.useMutation<
    UpdateTeamCheckinMutation,
    UpdateTeamCheckinMutationVariables
  >(UpdateTeamCheckinDocument, baseOptions);
}
export type UpdateTeamCheckinMutationHookResult = ReturnType<
  typeof useUpdateTeamCheckinMutation
>;
export type UpdateTeamCheckinMutationResult = Apollo.MutationResult<
  UpdateTeamCheckinMutation
>;
export type UpdateTeamCheckinMutationOptions = Apollo.BaseMutationOptions<
  UpdateTeamCheckinMutation,
  UpdateTeamCheckinMutationVariables
>;
export const GetComponentAnnouncementsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentAnnouncements' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentAnnouncements',
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentAnnouncement' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassAnnouncement' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'title' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'targetDate' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'acknowledgements' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'hasAcknowledged' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentAnnouncements' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'announcements' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassComponentAnnouncement' },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentAnnouncementsQuery__
 *
 * To run a query within a React component, call `useGetComponentAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentAnnouncementsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetComponentAnnouncementsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentAnnouncementsQuery,
    GetComponentAnnouncementsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentAnnouncementsQuery,
    GetComponentAnnouncementsQueryVariables
  >(GetComponentAnnouncementsDocument, baseOptions);
}
export function useGetComponentAnnouncementsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentAnnouncementsQuery,
    GetComponentAnnouncementsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentAnnouncementsQuery,
    GetComponentAnnouncementsQueryVariables
  >(GetComponentAnnouncementsDocument, baseOptions);
}
export type GetComponentAnnouncementsQueryHookResult = ReturnType<
  typeof useGetComponentAnnouncementsQuery
>;
export type GetComponentAnnouncementsLazyQueryHookResult = ReturnType<
  typeof useGetComponentAnnouncementsLazyQuery
>;
export type GetComponentAnnouncementsQueryResult = Apollo.QueryResult<
  GetComponentAnnouncementsQuery,
  GetComponentAnnouncementsQueryVariables
>;
export function refetchGetComponentAnnouncementsQuery(
  variables?: GetComponentAnnouncementsQueryVariables,
) {
  return { query: GetComponentAnnouncementsDocument, variables: variables };
}
export const GetComponentApplicableScorecardsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentApplicableScorecards' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'componentId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'componentId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: {
                                kind: 'Name',
                                value: 'applicableScorecards',
                              },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'description',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'componentType',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'importance' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentApplicableScorecardsQuery__
 *
 * To run a query within a React component, call `useGetComponentApplicableScorecardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentApplicableScorecardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentApplicableScorecardsQuery({
 *   variables: {
 *      componentId: // value for 'componentId'
 *   },
 * });
 */
export function useGetComponentApplicableScorecardsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentApplicableScorecardsQuery,
    GetComponentApplicableScorecardsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentApplicableScorecardsQuery,
    GetComponentApplicableScorecardsQueryVariables
  >(GetComponentApplicableScorecardsDocument, baseOptions);
}
export function useGetComponentApplicableScorecardsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentApplicableScorecardsQuery,
    GetComponentApplicableScorecardsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentApplicableScorecardsQuery,
    GetComponentApplicableScorecardsQueryVariables
  >(GetComponentApplicableScorecardsDocument, baseOptions);
}
export type GetComponentApplicableScorecardsQueryHookResult = ReturnType<
  typeof useGetComponentApplicableScorecardsQuery
>;
export type GetComponentApplicableScorecardsLazyQueryHookResult = ReturnType<
  typeof useGetComponentApplicableScorecardsLazyQuery
>;
export type GetComponentApplicableScorecardsQueryResult = Apollo.QueryResult<
  GetComponentApplicableScorecardsQuery,
  GetComponentApplicableScorecardsQueryVariables
>;
export function refetchGetComponentApplicableScorecardsQuery(
  variables?: GetComponentApplicableScorecardsQueryVariables,
) {
  return {
    query: GetComponentApplicableScorecardsDocument,
    variables: variables,
  };
}
export const GetComponentDependencyAnnouncementsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentDependencyAnnouncements' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'relationships' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'ObjectValue',
                                    fields: [
                                      {
                                        kind: 'ObjectField',
                                        name: {
                                          kind: 'Name',
                                          value: 'filters',
                                        },
                                        value: {
                                          kind: 'ObjectValue',
                                          fields: [
                                            {
                                              kind: 'ObjectField',
                                              name: {
                                                kind: 'Name',
                                                value: 'types',
                                              },
                                              value: {
                                                kind: 'ListValue',
                                                values: [
                                                  {
                                                    kind: 'EnumValue',
                                                    value: 'DEPENDS_ON',
                                                  },
                                                ],
                                              },
                                            },
                                          ],
                                        },
                                      },
                                    ],
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassRelationshipConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'type',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'startNode',
                                                },
                                                selectionSet: {
                                                  kind: 'SelectionSet',
                                                  selections: [
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'id',
                                                      },
                                                    },
                                                  ],
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'endNode',
                                                },
                                                selectionSet: {
                                                  kind: 'SelectionSet',
                                                  selections: [
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'id',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'name',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'type',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'announcements',
                                                      },
                                                      selectionSet: {
                                                        kind: 'SelectionSet',
                                                        selections: [
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value: 'id',
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'component',
                                                            },
                                                            selectionSet: {
                                                              kind:
                                                                'SelectionSet',
                                                              selections: [
                                                                {
                                                                  kind: 'Field',
                                                                  name: {
                                                                    kind:
                                                                      'Name',
                                                                    value: 'id',
                                                                  },
                                                                },
                                                                {
                                                                  kind: 'Field',
                                                                  name: {
                                                                    kind:
                                                                      'Name',
                                                                    value:
                                                                      'name',
                                                                  },
                                                                },
                                                                {
                                                                  kind: 'Field',
                                                                  name: {
                                                                    kind:
                                                                      'Name',
                                                                    value:
                                                                      'type',
                                                                  },
                                                                },
                                                              ],
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value: 'title',
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'description',
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'targetDate',
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'acknowledgements',
                                                            },
                                                            selectionSet: {
                                                              kind:
                                                                'SelectionSet',
                                                              selections: [
                                                                {
                                                                  kind: 'Field',
                                                                  name: {
                                                                    kind:
                                                                      'Name',
                                                                    value:
                                                                      'component',
                                                                  },
                                                                  selectionSet: {
                                                                    kind:
                                                                      'SelectionSet',
                                                                    selections: [
                                                                      {
                                                                        kind:
                                                                          'Field',
                                                                        name: {
                                                                          kind:
                                                                            'Name',
                                                                          value:
                                                                            'id',
                                                                        },
                                                                      },
                                                                    ],
                                                                  },
                                                                },
                                                                {
                                                                  kind: 'Field',
                                                                  name: {
                                                                    kind:
                                                                      'Name',
                                                                    value:
                                                                      'hasAcknowledged',
                                                                  },
                                                                },
                                                              ],
                                                            },
                                                          },
                                                        ],
                                                      },
                                                    },
                                                  ],
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentDependencyAnnouncementsQuery__
 *
 * To run a query within a React component, call `useGetComponentDependencyAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentDependencyAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentDependencyAnnouncementsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetComponentDependencyAnnouncementsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentDependencyAnnouncementsQuery,
    GetComponentDependencyAnnouncementsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentDependencyAnnouncementsQuery,
    GetComponentDependencyAnnouncementsQueryVariables
  >(GetComponentDependencyAnnouncementsDocument, baseOptions);
}
export function useGetComponentDependencyAnnouncementsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentDependencyAnnouncementsQuery,
    GetComponentDependencyAnnouncementsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentDependencyAnnouncementsQuery,
    GetComponentDependencyAnnouncementsQueryVariables
  >(GetComponentDependencyAnnouncementsDocument, baseOptions);
}
export type GetComponentDependencyAnnouncementsQueryHookResult = ReturnType<
  typeof useGetComponentDependencyAnnouncementsQuery
>;
export type GetComponentDependencyAnnouncementsLazyQueryHookResult = ReturnType<
  typeof useGetComponentDependencyAnnouncementsLazyQuery
>;
export type GetComponentDependencyAnnouncementsQueryResult = Apollo.QueryResult<
  GetComponentDependencyAnnouncementsQuery,
  GetComponentDependencyAnnouncementsQueryVariables
>;
export function refetchGetComponentDependencyAnnouncementsQuery(
  variables?: GetComponentDependencyAnnouncementsQueryVariables,
) {
  return {
    query: GetComponentDependencyAnnouncementsDocument,
    variables: variables,
  };
}
export const GetComponentDetailsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentDetails' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentDetailView',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentDetailView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'links' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassComponentLinkCommon' },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'fields' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: { kind: 'Name', value: 'CompassEnumField' },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'value' } },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'definition' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'dataManager' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'ecosystemAppId' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'externalSourceURL' },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'lastSyncEvent' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'time' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'status' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'lastSyncErrors' },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'relationships' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: {
                      kind: 'Name',
                      value: 'CompassRelationshipConnection',
                    },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'nodes' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'type' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'startNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'endNode' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'events' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'query' },
                value: {
                  kind: 'ObjectValue',
                  fields: [
                    {
                      kind: 'ObjectField',
                      name: { kind: 'Name', value: 'eventTypes' },
                      value: {
                        kind: 'ListValue',
                        values: [{ kind: 'EnumValue', value: 'DEPLOYMENT' }],
                      },
                    },
                    {
                      kind: 'ObjectField',
                      name: { kind: 'Name', value: 'first' },
                      value: { kind: 'IntValue', value: '1' },
                    },
                  ],
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'InlineFragment',
                  typeCondition: {
                    kind: 'NamedType',
                    name: { kind: 'Name', value: 'CompassEventConnection' },
                  },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'nodes' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'InlineFragment',
                              typeCondition: {
                                kind: 'NamedType',
                                name: {
                                  kind: 'Name',
                                  value: 'CompassDeploymentEvent',
                                },
                              },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'url' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'lastUpdated',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'environment',
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'displayName',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'displayName',
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentLabels' },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLabels' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'labels' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'name' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentLinkCommon' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassLink' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'url' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentDetailsQuery__
 *
 * To run a query within a React component, call `useGetComponentDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetComponentDetailsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentDetailsQuery,
    GetComponentDetailsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentDetailsQuery,
    GetComponentDetailsQueryVariables
  >(GetComponentDetailsDocument, baseOptions);
}
export function useGetComponentDetailsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentDetailsQuery,
    GetComponentDetailsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentDetailsQuery,
    GetComponentDetailsQueryVariables
  >(GetComponentDetailsDocument, baseOptions);
}
export type GetComponentDetailsQueryHookResult = ReturnType<
  typeof useGetComponentDetailsQuery
>;
export type GetComponentDetailsLazyQueryHookResult = ReturnType<
  typeof useGetComponentDetailsLazyQuery
>;
export type GetComponentDetailsQueryResult = Apollo.QueryResult<
  GetComponentDetailsQuery,
  GetComponentDetailsQueryVariables
>;
export function refetchGetComponentDetailsQuery(
  variables?: GetComponentDetailsQueryVariables,
) {
  return { query: GetComponentDetailsDocument, variables: variables };
}
export const GetComponentEventsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentEvents' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompassEventsQuery' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'events' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'Variable',
                                    name: { kind: 'Name', value: 'query' },
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassEventConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'InlineFragment',
                                                typeCondition: {
                                                  kind: 'NamedType',
                                                  name: {
                                                    kind: 'Name',
                                                    value:
                                                      'CompassDeploymentEvent',
                                                  },
                                                },
                                                selectionSet: {
                                                  kind: 'SelectionSet',
                                                  selections: [
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'eventType',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'lastUpdated',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'displayName',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'state',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'description',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'environment',
                                                      },
                                                      selectionSet: {
                                                        kind: 'SelectionSet',
                                                        selections: [
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'displayName',
                                                            },
                                                          },
                                                          {
                                                            kind: 'Field',
                                                            name: {
                                                              kind: 'Name',
                                                              value: 'category',
                                                            },
                                                          },
                                                        ],
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'url',
                                                      },
                                                    },
                                                  ],
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentEventsQuery__
 *
 * To run a query within a React component, call `useGetComponentEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentEventsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useGetComponentEventsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentEventsQuery,
    GetComponentEventsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentEventsQuery,
    GetComponentEventsQueryVariables
  >(GetComponentEventsDocument, baseOptions);
}
export function useGetComponentEventsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentEventsQuery,
    GetComponentEventsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentEventsQuery,
    GetComponentEventsQueryVariables
  >(GetComponentEventsDocument, baseOptions);
}
export type GetComponentEventsQueryHookResult = ReturnType<
  typeof useGetComponentEventsQuery
>;
export type GetComponentEventsLazyQueryHookResult = ReturnType<
  typeof useGetComponentEventsLazyQuery
>;
export type GetComponentEventsQueryResult = Apollo.QueryResult<
  GetComponentEventsQuery,
  GetComponentEventsQueryVariables
>;
export function refetchGetComponentEventsQuery(
  variables?: GetComponentEventsQueryVariables,
) {
  return { query: GetComponentEventsDocument, variables: variables };
}
export const GetComponentLinksDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentLinks' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'links' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'url' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentLinksQuery__
 *
 * To run a query within a React component, call `useGetComponentLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentLinksQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetComponentLinksQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentLinksQuery,
    GetComponentLinksQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentLinksQuery,
    GetComponentLinksQueryVariables
  >(GetComponentLinksDocument, baseOptions);
}
export function useGetComponentLinksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentLinksQuery,
    GetComponentLinksQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentLinksQuery,
    GetComponentLinksQueryVariables
  >(GetComponentLinksDocument, baseOptions);
}
export type GetComponentLinksQueryHookResult = ReturnType<
  typeof useGetComponentLinksQuery
>;
export type GetComponentLinksLazyQueryHookResult = ReturnType<
  typeof useGetComponentLinksLazyQuery
>;
export type GetComponentLinksQueryResult = Apollo.QueryResult<
  GetComponentLinksQuery,
  GetComponentLinksQueryVariables
>;
export function refetchGetComponentLinksQuery(
  variables?: GetComponentLinksQueryVariables,
) {
  return { query: GetComponentLinksDocument, variables: variables };
}
export const GetComponentRelationshipsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentRelationships' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'outwardRelationshipsQuery' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassRelationshipQuery' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'inwardRelationshipsQuery' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassRelationshipQuery' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'dataManager' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'ecosystemAppId',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'externalSourceURL',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              alias: {
                                kind: 'Name',
                                value: 'outwardRelationships',
                              },
                              name: { kind: 'Name', value: 'relationships' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'Variable',
                                    name: {
                                      kind: 'Name',
                                      value: 'outwardRelationshipsQuery',
                                    },
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassRelationshipConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'FragmentSpread',
                                                name: {
                                                  kind: 'Name',
                                                  value:
                                                    'CompassRelationshipInRelationshipView',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'QueryError',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'message',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'extensions',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'statusCode',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'errorType',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              alias: {
                                kind: 'Name',
                                value: 'inwardRelationships',
                              },
                              name: { kind: 'Name', value: 'relationships' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'Variable',
                                    name: {
                                      kind: 'Name',
                                      value: 'inwardRelationshipsQuery',
                                    },
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassRelationshipConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'FragmentSpread',
                                                name: {
                                                  kind: 'Name',
                                                  value:
                                                    'CompassRelationshipInRelationshipView',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'QueryError',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'message',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'extensions',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'statusCode',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'errorType',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassRelationshipCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentRelationshipsQuery__
 *
 * To run a query within a React component, call `useGetComponentRelationshipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentRelationshipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentRelationshipsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      outwardRelationshipsQuery: // value for 'outwardRelationshipsQuery'
 *      inwardRelationshipsQuery: // value for 'inwardRelationshipsQuery'
 *   },
 * });
 */
export function useGetComponentRelationshipsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentRelationshipsQuery,
    GetComponentRelationshipsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentRelationshipsQuery,
    GetComponentRelationshipsQueryVariables
  >(GetComponentRelationshipsDocument, baseOptions);
}
export function useGetComponentRelationshipsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentRelationshipsQuery,
    GetComponentRelationshipsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentRelationshipsQuery,
    GetComponentRelationshipsQueryVariables
  >(GetComponentRelationshipsDocument, baseOptions);
}
export type GetComponentRelationshipsQueryHookResult = ReturnType<
  typeof useGetComponentRelationshipsQuery
>;
export type GetComponentRelationshipsLazyQueryHookResult = ReturnType<
  typeof useGetComponentRelationshipsLazyQuery
>;
export type GetComponentRelationshipsQueryResult = Apollo.QueryResult<
  GetComponentRelationshipsQuery,
  GetComponentRelationshipsQueryVariables
>;
export function refetchGetComponentRelationshipsQuery(
  variables?: GetComponentRelationshipsQueryVariables,
) {
  return { query: GetComponentRelationshipsDocument, variables: variables };
}
export const GetComponentRelationshipsOldDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentRelationshipsOld' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassRelationshipQuery' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'dataManager' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'ecosystemAppId',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'externalSourceURL',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'relationships' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'Variable',
                                    name: { kind: 'Name', value: 'query' },
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'CompassRelationshipConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'FragmentSpread',
                                                name: {
                                                  kind: 'Name',
                                                  value:
                                                    'CompassRelationshipInRelationshipView',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value: 'QueryError',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'message',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'extensions',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'statusCode',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'errorType',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'id' } },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassRelationshipInRelationshipView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassRelationship' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassRelationshipCore' },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'startNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'endNode' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: {
                    kind: 'Name',
                    value: 'CompassComponentInRelationshipView',
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentRelationshipsOldQuery__
 *
 * To run a query within a React component, call `useGetComponentRelationshipsOldQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentRelationshipsOldQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentRelationshipsOldQuery({
 *   variables: {
 *      id: // value for 'id'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useGetComponentRelationshipsOldQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentRelationshipsOldQuery,
    GetComponentRelationshipsOldQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentRelationshipsOldQuery,
    GetComponentRelationshipsOldQueryVariables
  >(GetComponentRelationshipsOldDocument, baseOptions);
}
export function useGetComponentRelationshipsOldLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentRelationshipsOldQuery,
    GetComponentRelationshipsOldQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentRelationshipsOldQuery,
    GetComponentRelationshipsOldQueryVariables
  >(GetComponentRelationshipsOldDocument, baseOptions);
}
export type GetComponentRelationshipsOldQueryHookResult = ReturnType<
  typeof useGetComponentRelationshipsOldQuery
>;
export type GetComponentRelationshipsOldLazyQueryHookResult = ReturnType<
  typeof useGetComponentRelationshipsOldLazyQuery
>;
export type GetComponentRelationshipsOldQueryResult = Apollo.QueryResult<
  GetComponentRelationshipsOldQuery,
  GetComponentRelationshipsOldQueryVariables
>;
export function refetchGetComponentRelationshipsOldQuery(
  variables?: GetComponentRelationshipsOldQueryVariables,
) {
  return { query: GetComponentRelationshipsOldDocument, variables: variables };
}
export const GetComponentScorecardWithScoresByIdDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentScorecardWithScoresById' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'componentId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'scorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassScorecard' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'componentType' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'importance' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'owner' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'picture' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'scorecardScore' },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'ObjectValue',
                                    fields: [
                                      {
                                        kind: 'ObjectField',
                                        name: {
                                          kind: 'Name',
                                          value: 'componentId',
                                        },
                                        value: {
                                          kind: 'Variable',
                                          name: {
                                            kind: 'Name',
                                            value: 'componentId',
                                          },
                                        },
                                      },
                                    ],
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'totalScore' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'maxTotalScore',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'criterias' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'weight' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value:
                                          'CompassHasLinkScorecardCriteria',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'linkType',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value:
                                          'CompassHasFieldScorecardCriteria',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'fieldDefinition',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'id',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'name',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'scorecardCriteriaScore',
                                    },
                                    arguments: [
                                      {
                                        kind: 'Argument',
                                        name: { kind: 'Name', value: 'query' },
                                        value: {
                                          kind: 'ObjectValue',
                                          fields: [
                                            {
                                              kind: 'ObjectField',
                                              name: {
                                                kind: 'Name',
                                                value: 'componentId',
                                              },
                                              value: {
                                                kind: 'Variable',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'componentId',
                                                },
                                              },
                                            },
                                          ],
                                        },
                                      },
                                    ],
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'score',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'maxScore',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentScorecardWithScoresByIdQuery__
 *
 * To run a query within a React component, call `useGetComponentScorecardWithScoresByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentScorecardWithScoresByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentScorecardWithScoresByIdQuery({
 *   variables: {
 *      componentId: // value for 'componentId'
 *      scorecardId: // value for 'scorecardId'
 *   },
 * });
 */
export function useGetComponentScorecardWithScoresByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentScorecardWithScoresByIdQuery,
    GetComponentScorecardWithScoresByIdQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentScorecardWithScoresByIdQuery,
    GetComponentScorecardWithScoresByIdQueryVariables
  >(GetComponentScorecardWithScoresByIdDocument, baseOptions);
}
export function useGetComponentScorecardWithScoresByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentScorecardWithScoresByIdQuery,
    GetComponentScorecardWithScoresByIdQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentScorecardWithScoresByIdQuery,
    GetComponentScorecardWithScoresByIdQueryVariables
  >(GetComponentScorecardWithScoresByIdDocument, baseOptions);
}
export type GetComponentScorecardWithScoresByIdQueryHookResult = ReturnType<
  typeof useGetComponentScorecardWithScoresByIdQuery
>;
export type GetComponentScorecardWithScoresByIdLazyQueryHookResult = ReturnType<
  typeof useGetComponentScorecardWithScoresByIdLazyQuery
>;
export type GetComponentScorecardWithScoresByIdQueryResult = Apollo.QueryResult<
  GetComponentScorecardWithScoresByIdQuery,
  GetComponentScorecardWithScoresByIdQueryVariables
>;
export function refetchGetComponentScorecardWithScoresByIdQuery(
  variables?: GetComponentScorecardWithScoresByIdQueryVariables,
) {
  return {
    query: GetComponentScorecardWithScoresByIdDocument,
    variables: variables,
  };
}
export const GetComponentScorecardsWithScoresDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getComponentScorecardsWithScores' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'componentId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'component' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'componentId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassComponent' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: {
                                kind: 'Name',
                                value: 'CompassComponentCore',
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'scorecards' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'componentType',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'importance' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'scorecardScore',
                                    },
                                    arguments: [
                                      {
                                        kind: 'Argument',
                                        name: { kind: 'Name', value: 'query' },
                                        value: {
                                          kind: 'ObjectValue',
                                          fields: [
                                            {
                                              kind: 'ObjectField',
                                              name: {
                                                kind: 'Name',
                                                value: 'componentId',
                                              },
                                              value: {
                                                kind: 'Variable',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'componentId',
                                                },
                                              },
                                            },
                                          ],
                                        },
                                      },
                                    ],
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'totalScore',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'maxTotalScore',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'criterias' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'id' },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'weight',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: '__typename',
                                          },
                                        },
                                        {
                                          kind: 'InlineFragment',
                                          typeCondition: {
                                            kind: 'NamedType',
                                            name: {
                                              kind: 'Name',
                                              value:
                                                'CompassHasLinkScorecardCriteria',
                                            },
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'linkType',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                        {
                                          kind: 'InlineFragment',
                                          typeCondition: {
                                            kind: 'NamedType',
                                            name: {
                                              kind: 'Name',
                                              value:
                                                'CompassHasFieldScorecardCriteria',
                                            },
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'fieldDefinition',
                                                },
                                                selectionSet: {
                                                  kind: 'SelectionSet',
                                                  selections: [
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'id',
                                                      },
                                                    },
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'name',
                                                      },
                                                    },
                                                  ],
                                                },
                                              },
                                            ],
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'scorecardCriteriaScore',
                                          },
                                          arguments: [
                                            {
                                              kind: 'Argument',
                                              name: {
                                                kind: 'Name',
                                                value: 'query',
                                              },
                                              value: {
                                                kind: 'ObjectValue',
                                                fields: [
                                                  {
                                                    kind: 'ObjectField',
                                                    name: {
                                                      kind: 'Name',
                                                      value: 'componentId',
                                                    },
                                                    value: {
                                                      kind: 'Variable',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'componentId',
                                                      },
                                                    },
                                                  },
                                                ],
                                              },
                                            },
                                          ],
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'score',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'maxScore',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetComponentScorecardsWithScoresQuery__
 *
 * To run a query within a React component, call `useGetComponentScorecardsWithScoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetComponentScorecardsWithScoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetComponentScorecardsWithScoresQuery({
 *   variables: {
 *      componentId: // value for 'componentId'
 *   },
 * });
 */
export function useGetComponentScorecardsWithScoresQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetComponentScorecardsWithScoresQuery,
    GetComponentScorecardsWithScoresQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetComponentScorecardsWithScoresQuery,
    GetComponentScorecardsWithScoresQueryVariables
  >(GetComponentScorecardsWithScoresDocument, baseOptions);
}
export function useGetComponentScorecardsWithScoresLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetComponentScorecardsWithScoresQuery,
    GetComponentScorecardsWithScoresQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetComponentScorecardsWithScoresQuery,
    GetComponentScorecardsWithScoresQueryVariables
  >(GetComponentScorecardsWithScoresDocument, baseOptions);
}
export type GetComponentScorecardsWithScoresQueryHookResult = ReturnType<
  typeof useGetComponentScorecardsWithScoresQuery
>;
export type GetComponentScorecardsWithScoresLazyQueryHookResult = ReturnType<
  typeof useGetComponentScorecardsWithScoresLazyQuery
>;
export type GetComponentScorecardsWithScoresQueryResult = Apollo.QueryResult<
  GetComponentScorecardsWithScoresQuery,
  GetComponentScorecardsWithScoresQueryVariables
>;
export function refetchGetComponentScorecardsWithScoresQuery(
  variables?: GetComponentScorecardsWithScoresQueryVariables,
) {
  return {
    query: GetComponentScorecardsWithScoresDocument,
    variables: variables,
  };
}
export const GetFieldDefinitionsByComponentTypeDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getFieldDefinitionsByComponentType' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'type' } },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassComponentType' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: {
                    kind: 'Name',
                    value: 'fieldDefinitionsByComponentType',
                  },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'type' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassFieldDefinitions',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'definitions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'type' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'description',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'options' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'InlineFragment',
                                          typeCondition: {
                                            kind: 'NamedType',
                                            name: {
                                              kind: 'Name',
                                              value:
                                                'CompassEnumFieldDefinitionOptions',
                                            },
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'values',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'default',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetFieldDefinitionsByComponentTypeQuery__
 *
 * To run a query within a React component, call `useGetFieldDefinitionsByComponentTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFieldDefinitionsByComponentTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFieldDefinitionsByComponentTypeQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetFieldDefinitionsByComponentTypeQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetFieldDefinitionsByComponentTypeQuery,
    GetFieldDefinitionsByComponentTypeQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetFieldDefinitionsByComponentTypeQuery,
    GetFieldDefinitionsByComponentTypeQueryVariables
  >(GetFieldDefinitionsByComponentTypeDocument, baseOptions);
}
export function useGetFieldDefinitionsByComponentTypeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetFieldDefinitionsByComponentTypeQuery,
    GetFieldDefinitionsByComponentTypeQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetFieldDefinitionsByComponentTypeQuery,
    GetFieldDefinitionsByComponentTypeQueryVariables
  >(GetFieldDefinitionsByComponentTypeDocument, baseOptions);
}
export type GetFieldDefinitionsByComponentTypeQueryHookResult = ReturnType<
  typeof useGetFieldDefinitionsByComponentTypeQuery
>;
export type GetFieldDefinitionsByComponentTypeLazyQueryHookResult = ReturnType<
  typeof useGetFieldDefinitionsByComponentTypeLazyQuery
>;
export type GetFieldDefinitionsByComponentTypeQueryResult = Apollo.QueryResult<
  GetFieldDefinitionsByComponentTypeQuery,
  GetFieldDefinitionsByComponentTypeQueryVariables
>;
export function refetchGetFieldDefinitionsByComponentTypeQuery(
  variables?: GetFieldDefinitionsByComponentTypeQueryVariables,
) {
  return {
    query: GetFieldDefinitionsByComponentTypeDocument,
    variables: variables,
  };
}
export const GetInstalledAppsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getInstalledApps' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'contextId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensionContexts' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'contextIds' },
                value: {
                  kind: 'ListValue',
                  values: [
                    {
                      kind: 'Variable',
                      name: { kind: 'Name', value: 'contextId' },
                    },
                  ],
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'extensionsByType' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'type' },
                      value: {
                        kind: 'StringValue',
                        value: 'compass:adminPage',
                        block: false,
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'properties' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'environmentId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'environmentType' },
                      },
                      { kind: 'Field', name: { kind: 'Name', value: 'type' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appVersion' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'consentUrl' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'installationId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appVersion' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appOwner' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'accountId' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'picture' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'consentUrl' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'currentUserConsent' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'user' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'aaid' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: {
                                kind: 'Name',
                                value: 'appEnvironmentVersion',
                              },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'consentedAt' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'requiresUserConsent' },
                      },
                    ],
                  },
                },
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'installations' },
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'nodes' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'app' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'FragmentSpread',
                                    name: {
                                      kind: 'Name',
                                      value: 'AppListView',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'appEnvironment' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'key' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'AppListView' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'App' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'avatarFileId' } },
          { kind: 'Field', name: { kind: 'Name', value: 'vendorName' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
        ],
      },
    },
  ],
};

/**
 * __useGetInstalledAppsQuery__
 *
 * To run a query within a React component, call `useGetInstalledAppsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInstalledAppsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInstalledAppsQuery({
 *   variables: {
 *      contextId: // value for 'contextId'
 *   },
 * });
 */
export function useGetInstalledAppsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetInstalledAppsQuery,
    GetInstalledAppsQueryVariables
  >,
) {
  return Apollo.useQuery<GetInstalledAppsQuery, GetInstalledAppsQueryVariables>(
    GetInstalledAppsDocument,
    baseOptions,
  );
}
export function useGetInstalledAppsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetInstalledAppsQuery,
    GetInstalledAppsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetInstalledAppsQuery,
    GetInstalledAppsQueryVariables
  >(GetInstalledAppsDocument, baseOptions);
}
export type GetInstalledAppsQueryHookResult = ReturnType<
  typeof useGetInstalledAppsQuery
>;
export type GetInstalledAppsLazyQueryHookResult = ReturnType<
  typeof useGetInstalledAppsLazyQuery
>;
export type GetInstalledAppsQueryResult = Apollo.QueryResult<
  GetInstalledAppsQuery,
  GetInstalledAppsQueryVariables
>;
export function refetchGetInstalledAppsQuery(
  variables?: GetInstalledAppsQueryVariables,
) {
  return { query: GetInstalledAppsDocument, variables: variables };
}
export const GetInstalledComponentDetailAppsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getInstalledComponentDetailApps' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'contextId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensionContexts' },
            arguments: [
              {
                kind: 'Argument',
                name: { kind: 'Name', value: 'contextIds' },
                value: {
                  kind: 'ListValue',
                  values: [
                    {
                      kind: 'Variable',
                      name: { kind: 'Name', value: 'contextId' },
                    },
                  ],
                },
              },
            ],
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'extensionsByType' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'type' },
                      value: {
                        kind: 'StringValue',
                        value: 'compass:componentPage',
                        block: false,
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'properties' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'environmentId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'environmentType' },
                      },
                      { kind: 'Field', name: { kind: 'Name', value: 'type' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appVersion' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'consentUrl' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'installationId' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appVersion' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'appOwner' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'accountId' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'picture' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'consentUrl' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'currentUserConsent' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'user' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'aaid' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: {
                                kind: 'Name',
                                value: 'appEnvironmentVersion',
                              },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'consentedAt' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'requiresUserConsent' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetInstalledComponentDetailAppsQuery__
 *
 * To run a query within a React component, call `useGetInstalledComponentDetailAppsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInstalledComponentDetailAppsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInstalledComponentDetailAppsQuery({
 *   variables: {
 *      contextId: // value for 'contextId'
 *   },
 * });
 */
export function useGetInstalledComponentDetailAppsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetInstalledComponentDetailAppsQuery,
    GetInstalledComponentDetailAppsQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetInstalledComponentDetailAppsQuery,
    GetInstalledComponentDetailAppsQueryVariables
  >(GetInstalledComponentDetailAppsDocument, baseOptions);
}
export function useGetInstalledComponentDetailAppsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetInstalledComponentDetailAppsQuery,
    GetInstalledComponentDetailAppsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetInstalledComponentDetailAppsQuery,
    GetInstalledComponentDetailAppsQueryVariables
  >(GetInstalledComponentDetailAppsDocument, baseOptions);
}
export type GetInstalledComponentDetailAppsQueryHookResult = ReturnType<
  typeof useGetInstalledComponentDetailAppsQuery
>;
export type GetInstalledComponentDetailAppsLazyQueryHookResult = ReturnType<
  typeof useGetInstalledComponentDetailAppsLazyQuery
>;
export type GetInstalledComponentDetailAppsQueryResult = Apollo.QueryResult<
  GetInstalledComponentDetailAppsQuery,
  GetInstalledComponentDetailAppsQueryVariables
>;
export function refetchGetInstalledComponentDetailAppsQuery(
  variables?: GetInstalledComponentDetailAppsQueryVariables,
) {
  return {
    query: GetInstalledComponentDetailAppsDocument,
    variables: variables,
  };
}
export const GetScorecardDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getScorecard' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'id' } },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'scorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'id' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassScorecard' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'name' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'description' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'componentType' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'importance' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'owner' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'accountId' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'picture' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'accountStatus',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'criterias' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'weight' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value:
                                          'CompassHasLinkScorecardCriteria',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'id' },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'linkType',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetScorecardQuery__
 *
 * To run a query within a React component, call `useGetScorecardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScorecardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScorecardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetScorecardQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScorecardQuery,
    GetScorecardQueryVariables
  >,
) {
  return Apollo.useQuery<GetScorecardQuery, GetScorecardQueryVariables>(
    GetScorecardDocument,
    baseOptions,
  );
}
export function useGetScorecardLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScorecardQuery,
    GetScorecardQueryVariables
  >,
) {
  return Apollo.useLazyQuery<GetScorecardQuery, GetScorecardQueryVariables>(
    GetScorecardDocument,
    baseOptions,
  );
}
export type GetScorecardQueryHookResult = ReturnType<
  typeof useGetScorecardQuery
>;
export type GetScorecardLazyQueryHookResult = ReturnType<
  typeof useGetScorecardLazyQuery
>;
export type GetScorecardQueryResult = Apollo.QueryResult<
  GetScorecardQuery,
  GetScorecardQueryVariables
>;
export function refetchGetScorecardQuery(
  variables?: GetScorecardQueryVariables,
) {
  return { query: GetScorecardDocument, variables: variables };
}
export const GetScorecardAppliedToComponentsWithScoresDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: {
        kind: 'Name',
        value: 'getScorecardAppliedToComponentsWithScores',
      },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'scorecardId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'first' },
          },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Int' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'after' },
          },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'String' } },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'scorecard' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'id' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'scorecardId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'CompassScorecard' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'id' },
                            },
                            {
                              kind: 'Field',
                              name: {
                                kind: 'Name',
                                value: 'appliedToComponents',
                              },
                              arguments: [
                                {
                                  kind: 'Argument',
                                  name: { kind: 'Name', value: 'query' },
                                  value: {
                                    kind: 'ObjectValue',
                                    fields: [
                                      {
                                        kind: 'ObjectField',
                                        name: { kind: 'Name', value: 'first' },
                                        value: {
                                          kind: 'Variable',
                                          name: {
                                            kind: 'Name',
                                            value: 'first',
                                          },
                                        },
                                      },
                                      {
                                        kind: 'ObjectField',
                                        name: { kind: 'Name', value: 'after' },
                                        value: {
                                          kind: 'Variable',
                                          name: {
                                            kind: 'Name',
                                            value: 'after',
                                          },
                                        },
                                      },
                                    ],
                                  },
                                },
                              ],
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: '__typename' },
                                  },
                                  {
                                    kind: 'InlineFragment',
                                    typeCondition: {
                                      kind: 'NamedType',
                                      name: {
                                        kind: 'Name',
                                        value:
                                          'CompassScorecardAppliedToComponentsConnection',
                                      },
                                    },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'nodes',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'id',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'name',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'description',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'type',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'ownerId',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'scorecardScore',
                                                },
                                                arguments: [
                                                  {
                                                    kind: 'Argument',
                                                    name: {
                                                      kind: 'Name',
                                                      value: 'query',
                                                    },
                                                    value: {
                                                      kind: 'ObjectValue',
                                                      fields: [
                                                        {
                                                          kind: 'ObjectField',
                                                          name: {
                                                            kind: 'Name',
                                                            value:
                                                              'scorecardId',
                                                          },
                                                          value: {
                                                            kind: 'Variable',
                                                            name: {
                                                              kind: 'Name',
                                                              value:
                                                                'scorecardId',
                                                            },
                                                          },
                                                        },
                                                      ],
                                                    },
                                                  },
                                                ],
                                                selectionSet: {
                                                  kind: 'SelectionSet',
                                                  selections: [
                                                    {
                                                      kind: 'Field',
                                                      name: {
                                                        kind: 'Name',
                                                        value: 'totalScore',
                                                      },
                                                    },
                                                  ],
                                                },
                                              },
                                            ],
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'pageInfo',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'hasNextPage',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'hasPreviousPage',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'endCursor',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'startCursor',
                                                },
                                              },
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: '__typename',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useGetScorecardAppliedToComponentsWithScoresQuery__
 *
 * To run a query within a React component, call `useGetScorecardAppliedToComponentsWithScoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScorecardAppliedToComponentsWithScoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScorecardAppliedToComponentsWithScoresQuery({
 *   variables: {
 *      scorecardId: // value for 'scorecardId'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetScorecardAppliedToComponentsWithScoresQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScorecardAppliedToComponentsWithScoresQuery,
    GetScorecardAppliedToComponentsWithScoresQueryVariables
  >,
) {
  return Apollo.useQuery<
    GetScorecardAppliedToComponentsWithScoresQuery,
    GetScorecardAppliedToComponentsWithScoresQueryVariables
  >(GetScorecardAppliedToComponentsWithScoresDocument, baseOptions);
}
export function useGetScorecardAppliedToComponentsWithScoresLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScorecardAppliedToComponentsWithScoresQuery,
    GetScorecardAppliedToComponentsWithScoresQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetScorecardAppliedToComponentsWithScoresQuery,
    GetScorecardAppliedToComponentsWithScoresQueryVariables
  >(GetScorecardAppliedToComponentsWithScoresDocument, baseOptions);
}
export type GetScorecardAppliedToComponentsWithScoresQueryHookResult = ReturnType<
  typeof useGetScorecardAppliedToComponentsWithScoresQuery
>;
export type GetScorecardAppliedToComponentsWithScoresLazyQueryHookResult = ReturnType<
  typeof useGetScorecardAppliedToComponentsWithScoresLazyQuery
>;
export type GetScorecardAppliedToComponentsWithScoresQueryResult = Apollo.QueryResult<
  GetScorecardAppliedToComponentsWithScoresQuery,
  GetScorecardAppliedToComponentsWithScoresQueryVariables
>;
export function refetchGetScorecardAppliedToComponentsWithScoresQuery(
  variables?: GetScorecardAppliedToComponentsWithScoresQueryVariables,
) {
  return {
    query: GetScorecardAppliedToComponentsWithScoresDocument,
    variables: variables,
  };
}
export const GetScorecardsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getScorecards' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'scorecards' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassScorecardConnection',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'nodes' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'description',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'importance' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'componentType',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'owner' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'accountId',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'name' },
                                        },
                                      ],
                                    },
                                  },
                                  {
                                    kind: 'FragmentSpread',
                                    name: {
                                      kind: 'Name',
                                      value: 'CompassScorecardCore',
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'message' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'extensions' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'statusCode' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'errorType' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassScorecardCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassScorecard' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetScorecardsQuery__
 *
 * To run a query within a React component, call `useGetScorecardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScorecardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScorecardsQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *   },
 * });
 */
export function useGetScorecardsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScorecardsQuery,
    GetScorecardsQueryVariables
  >,
) {
  return Apollo.useQuery<GetScorecardsQuery, GetScorecardsQueryVariables>(
    GetScorecardsDocument,
    baseOptions,
  );
}
export function useGetScorecardsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScorecardsQuery,
    GetScorecardsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<GetScorecardsQuery, GetScorecardsQueryVariables>(
    GetScorecardsDocument,
    baseOptions,
  );
}
export type GetScorecardsQueryHookResult = ReturnType<
  typeof useGetScorecardsQuery
>;
export type GetScorecardsLazyQueryHookResult = ReturnType<
  typeof useGetScorecardsLazyQuery
>;
export type GetScorecardsQueryResult = Apollo.QueryResult<
  GetScorecardsQuery,
  GetScorecardsQueryVariables
>;
export function refetchGetScorecardsQuery(
  variables?: GetScorecardsQueryVariables,
) {
  return { query: GetScorecardsDocument, variables: variables };
}
export const GetTeamCheckinsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'getTeamCheckins' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'input' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'CompassTeamCheckinsInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'teamCheckins' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'input' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'input' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: '__typename' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'teamId' },
                      },
                      { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                      { kind: 'Field', name: { kind: 'Name', value: 'mood' } },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'response1' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'response2' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'response3' },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'changeMetadata' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'createdAt' },
                            },
                            {
                              kind: 'Field',
                              name: {
                                kind: 'Name',
                                value: 'lastUserModificationAt',
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'FragmentSpread',
                        name: { kind: 'Name', value: 'CompassTeamCheckinCore' },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassTeamCheckinCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassTeamCheckin' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useGetTeamCheckinsQuery__
 *
 * To run a query within a React component, call `useGetTeamCheckinsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTeamCheckinsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTeamCheckinsQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGetTeamCheckinsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetTeamCheckinsQuery,
    GetTeamCheckinsQueryVariables
  >,
) {
  return Apollo.useQuery<GetTeamCheckinsQuery, GetTeamCheckinsQueryVariables>(
    GetTeamCheckinsDocument,
    baseOptions,
  );
}
export function useGetTeamCheckinsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetTeamCheckinsQuery,
    GetTeamCheckinsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    GetTeamCheckinsQuery,
    GetTeamCheckinsQueryVariables
  >(GetTeamCheckinsDocument, baseOptions);
}
export type GetTeamCheckinsQueryHookResult = ReturnType<
  typeof useGetTeamCheckinsQuery
>;
export type GetTeamCheckinsLazyQueryHookResult = ReturnType<
  typeof useGetTeamCheckinsLazyQuery
>;
export type GetTeamCheckinsQueryResult = Apollo.QueryResult<
  GetTeamCheckinsQuery,
  GetTeamCheckinsQueryVariables
>;
export function refetchGetTeamCheckinsQuery(
  variables?: GetTeamCheckinsQueryVariables,
) {
  return { query: GetTeamCheckinsDocument, variables: variables };
}
export const SearchComponentLabelsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'searchComponentLabels' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompassSearchComponentLabelsQuery' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'searchComponentLabels' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'query' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'query' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassSearchComponentLabelsConnection',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'nodes' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useSearchComponentLabelsQuery__
 *
 * To run a query within a React component, call `useSearchComponentLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchComponentLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchComponentLabelsQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useSearchComponentLabelsQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchComponentLabelsQuery,
    SearchComponentLabelsQueryVariables
  >,
) {
  return Apollo.useQuery<
    SearchComponentLabelsQuery,
    SearchComponentLabelsQueryVariables
  >(SearchComponentLabelsDocument, baseOptions);
}
export function useSearchComponentLabelsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchComponentLabelsQuery,
    SearchComponentLabelsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    SearchComponentLabelsQuery,
    SearchComponentLabelsQueryVariables
  >(SearchComponentLabelsDocument, baseOptions);
}
export type SearchComponentLabelsQueryHookResult = ReturnType<
  typeof useSearchComponentLabelsQuery
>;
export type SearchComponentLabelsLazyQueryHookResult = ReturnType<
  typeof useSearchComponentLabelsLazyQuery
>;
export type SearchComponentLabelsQueryResult = Apollo.QueryResult<
  SearchComponentLabelsQuery,
  SearchComponentLabelsQueryVariables
>;
export function refetchSearchComponentLabelsQuery(
  variables?: SearchComponentLabelsQueryVariables,
) {
  return { query: SearchComponentLabelsDocument, variables: variables };
}
export const SearchComponentsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'searchComponents' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompassSearchComponentQuery' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'searchComponents' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'query' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'query' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassSearchComponentConnection',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'nodes' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'FragmentSpread',
                                    name: {
                                      kind: 'Name',
                                      value: 'CompassSearchComponentNode',
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'pageInfo' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'hasNextPage',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'endCursor' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponent' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponentNode' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassSearchComponentResult' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'link' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'component' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassSearchComponent' },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useSearchComponentsQuery__
 *
 * To run a query within a React component, call `useSearchComponentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchComponentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchComponentsQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useSearchComponentsQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchComponentsQuery,
    SearchComponentsQueryVariables
  >,
) {
  return Apollo.useQuery<SearchComponentsQuery, SearchComponentsQueryVariables>(
    SearchComponentsDocument,
    baseOptions,
  );
}
export function useSearchComponentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchComponentsQuery,
    SearchComponentsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    SearchComponentsQuery,
    SearchComponentsQueryVariables
  >(SearchComponentsDocument, baseOptions);
}
export type SearchComponentsQueryHookResult = ReturnType<
  typeof useSearchComponentsQuery
>;
export type SearchComponentsLazyQueryHookResult = ReturnType<
  typeof useSearchComponentsLazyQuery
>;
export type SearchComponentsQueryResult = Apollo.QueryResult<
  SearchComponentsQuery,
  SearchComponentsQueryVariables
>;
export function refetchSearchComponentsQuery(
  variables?: SearchComponentsQueryVariables,
) {
  return { query: SearchComponentsDocument, variables: variables };
}
export const SearchComponentsAddTeamOwnerDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'searchComponentsAddTeamOwner' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompassSearchComponentQuery' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'searchComponents' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'query' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'query' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassSearchComponentConnection',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'nodes' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'FragmentSpread',
                                    name: {
                                      kind: 'Name',
                                      value: 'CompassSearchComponentNode',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'component' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'dataManager',
                                          },
                                          selectionSet: {
                                            kind: 'SelectionSet',
                                            selections: [
                                              {
                                                kind: 'Field',
                                                name: {
                                                  kind: 'Name',
                                                  value: 'ecosystemAppId',
                                                },
                                              },
                                            ],
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'pageInfo' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'hasNextPage',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'endCursor' },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponent' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'FragmentSpread',
            name: { kind: 'Name', value: 'CompassComponentCore' },
          },
          { kind: 'Field', name: { kind: 'Name', value: 'name' } },
          { kind: 'Field', name: { kind: 'Name', value: 'description' } },
          { kind: 'Field', name: { kind: 'Name', value: 'type' } },
          { kind: 'Field', name: { kind: 'Name', value: 'ownerId' } },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassSearchComponentNode' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassSearchComponentResult' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'link' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'component' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'FragmentSpread',
                  name: { kind: 'Name', value: 'CompassSearchComponent' },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useSearchComponentsAddTeamOwnerQuery__
 *
 * To run a query within a React component, call `useSearchComponentsAddTeamOwnerQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchComponentsAddTeamOwnerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchComponentsAddTeamOwnerQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useSearchComponentsAddTeamOwnerQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchComponentsAddTeamOwnerQuery,
    SearchComponentsAddTeamOwnerQueryVariables
  >,
) {
  return Apollo.useQuery<
    SearchComponentsAddTeamOwnerQuery,
    SearchComponentsAddTeamOwnerQueryVariables
  >(SearchComponentsAddTeamOwnerDocument, baseOptions);
}
export function useSearchComponentsAddTeamOwnerLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchComponentsAddTeamOwnerQuery,
    SearchComponentsAddTeamOwnerQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    SearchComponentsAddTeamOwnerQuery,
    SearchComponentsAddTeamOwnerQueryVariables
  >(SearchComponentsAddTeamOwnerDocument, baseOptions);
}
export type SearchComponentsAddTeamOwnerQueryHookResult = ReturnType<
  typeof useSearchComponentsAddTeamOwnerQuery
>;
export type SearchComponentsAddTeamOwnerLazyQueryHookResult = ReturnType<
  typeof useSearchComponentsAddTeamOwnerLazyQuery
>;
export type SearchComponentsAddTeamOwnerQueryResult = Apollo.QueryResult<
  SearchComponentsAddTeamOwnerQuery,
  SearchComponentsAddTeamOwnerQueryVariables
>;
export function refetchSearchComponentsAddTeamOwnerQuery(
  variables?: SearchComponentsAddTeamOwnerQueryVariables,
) {
  return { query: SearchComponentsAddTeamOwnerDocument, variables: variables };
}
export const SearchComponentsPickerDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'searchComponentsPicker' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'String' },
            },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'query' },
          },
          type: {
            kind: 'NamedType',
            name: { kind: 'Name', value: 'CompassSearchComponentQuery' },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'compass' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'searchComponents' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'query' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'query' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: {
                            kind: 'Name',
                            value: 'CompassSearchComponentConnection',
                          },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'nodes' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'component' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'FragmentSpread',
                                          name: {
                                            kind: 'Name',
                                            value: 'CompassComponentCore',
                                          },
                                        },
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'name' },
                                        },
                                        {
                                          kind: 'Field',
                                          name: { kind: 'Name', value: 'type' },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'InlineFragment',
                        typeCondition: {
                          kind: 'NamedType',
                          name: { kind: 'Name', value: 'QueryError' },
                        },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'FragmentSpread',
                              name: { kind: 'Name', value: 'CommonQueryError' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CommonQueryError' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'QueryError' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'message' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'extensions' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                { kind: 'Field', name: { kind: 'Name', value: 'statusCode' } },
                { kind: 'Field', name: { kind: 'Name', value: 'errorType' } },
              ],
            },
          },
        ],
      },
    },
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: 'CompassComponentCore' },
      typeCondition: {
        kind: 'NamedType',
        name: { kind: 'Name', value: 'CompassComponent' },
      },
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          { kind: 'Field', name: { kind: 'Name', value: 'id' } },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isOptimistic' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
          {
            kind: 'Field',
            name: { kind: 'Name', value: '_isDeleted' },
            directives: [
              { kind: 'Directive', name: { kind: 'Name', value: 'client' } },
            ],
          },
        ],
      },
    },
  ],
};

/**
 * __useSearchComponentsPickerQuery__
 *
 * To run a query within a React component, call `useSearchComponentsPickerQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchComponentsPickerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchComponentsPickerQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useSearchComponentsPickerQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchComponentsPickerQuery,
    SearchComponentsPickerQueryVariables
  >,
) {
  return Apollo.useQuery<
    SearchComponentsPickerQuery,
    SearchComponentsPickerQueryVariables
  >(SearchComponentsPickerDocument, baseOptions);
}
export function useSearchComponentsPickerLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchComponentsPickerQuery,
    SearchComponentsPickerQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    SearchComponentsPickerQuery,
    SearchComponentsPickerQueryVariables
  >(SearchComponentsPickerDocument, baseOptions);
}
export type SearchComponentsPickerQueryHookResult = ReturnType<
  typeof useSearchComponentsPickerQuery
>;
export type SearchComponentsPickerLazyQueryHookResult = ReturnType<
  typeof useSearchComponentsPickerLazyQuery
>;
export type SearchComponentsPickerQueryResult = Apollo.QueryResult<
  SearchComponentsPickerQuery,
  SearchComponentsPickerQueryVariables
>;
export function refetchSearchComponentsPickerQuery(
  variables?: SearchComponentsPickerQueryVariables,
) {
  return { query: SearchComponentsPickerDocument, variables: variables };
}
export const SearchJiraProjectsDocument: DocumentNode = /*#__PURE__*/ {
  kind: 'Document',
  definitions: [
    {
      kind: 'OperationDefinition',
      operation: 'query',
      name: { kind: 'Name', value: 'searchJiraProjects' },
      variableDefinitions: [
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'cloudId' },
          },
          type: {
            kind: 'NonNullType',
            type: { kind: 'NamedType', name: { kind: 'Name', value: 'ID' } },
          },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'first' },
          },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Int' } },
        },
        {
          kind: 'VariableDefinition',
          variable: { kind: 'Variable', name: { kind: 'Name', value: 'last' } },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'Int' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'after' },
          },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'String' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'before' },
          },
          type: { kind: 'NamedType', name: { kind: 'Name', value: 'String' } },
        },
        {
          kind: 'VariableDefinition',
          variable: {
            kind: 'Variable',
            name: { kind: 'Name', value: 'filter' },
          },
          type: {
            kind: 'NonNullType',
            type: {
              kind: 'NamedType',
              name: { kind: 'Name', value: 'JiraProjectFilterInput' },
            },
          },
        },
      ],
      selectionSet: {
        kind: 'SelectionSet',
        selections: [
          {
            kind: 'Field',
            name: { kind: 'Name', value: 'jira' },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [
                {
                  kind: 'Field',
                  name: { kind: 'Name', value: 'allJiraProjects' },
                  arguments: [
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'cloudId' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'cloudId' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'first' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'first' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'last' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'last' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'after' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'after' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'before' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'before' },
                      },
                    },
                    {
                      kind: 'Argument',
                      name: { kind: 'Name', value: 'filter' },
                      value: {
                        kind: 'Variable',
                        name: { kind: 'Name', value: 'filter' },
                      },
                    },
                  ],
                  selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'edges' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'node' },
                              selectionSet: {
                                kind: 'SelectionSet',
                                selections: [
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'id' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'key' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'name' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'cloudId' },
                                  },
                                  {
                                    kind: 'Field',
                                    name: {
                                      kind: 'Name',
                                      value: 'description',
                                    },
                                  },
                                  {
                                    kind: 'Field',
                                    name: { kind: 'Name', value: 'avatar' },
                                    selectionSet: {
                                      kind: 'SelectionSet',
                                      selections: [
                                        {
                                          kind: 'Field',
                                          name: {
                                            kind: 'Name',
                                            value: 'xsmall',
                                          },
                                        },
                                      ],
                                    },
                                  },
                                ],
                              },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'cursor' },
                            },
                          ],
                        },
                      },
                      {
                        kind: 'Field',
                        name: { kind: 'Name', value: 'pageInfo' },
                        selectionSet: {
                          kind: 'SelectionSet',
                          selections: [
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'hasNextPage' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'hasPreviousPage' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'startCursor' },
                            },
                            {
                              kind: 'Field',
                              name: { kind: 'Name', value: 'endCursor' },
                            },
                          ],
                        },
                      },
                    ],
                  },
                },
              ],
            },
          },
        ],
      },
    },
  ],
};

/**
 * __useSearchJiraProjectsQuery__
 *
 * To run a query within a React component, call `useSearchJiraProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchJiraProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchJiraProjectsQuery({
 *   variables: {
 *      cloudId: // value for 'cloudId'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useSearchJiraProjectsQuery(
  baseOptions: Apollo.QueryHookOptions<
    SearchJiraProjectsQuery,
    SearchJiraProjectsQueryVariables
  >,
) {
  return Apollo.useQuery<
    SearchJiraProjectsQuery,
    SearchJiraProjectsQueryVariables
  >(SearchJiraProjectsDocument, baseOptions);
}
export function useSearchJiraProjectsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchJiraProjectsQuery,
    SearchJiraProjectsQueryVariables
  >,
) {
  return Apollo.useLazyQuery<
    SearchJiraProjectsQuery,
    SearchJiraProjectsQueryVariables
  >(SearchJiraProjectsDocument, baseOptions);
}
export type SearchJiraProjectsQueryHookResult = ReturnType<
  typeof useSearchJiraProjectsQuery
>;
export type SearchJiraProjectsLazyQueryHookResult = ReturnType<
  typeof useSearchJiraProjectsLazyQuery
>;
export type SearchJiraProjectsQueryResult = Apollo.QueryResult<
  SearchJiraProjectsQuery,
  SearchJiraProjectsQueryVariables
>;
export function refetchSearchJiraProjectsQuery(
  variables?: SearchJiraProjectsQueryVariables,
) {
  return { query: SearchJiraProjectsDocument, variables: variables };
}
